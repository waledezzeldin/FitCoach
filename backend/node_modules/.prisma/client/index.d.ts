
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Coach
 * 
 */
export type Coach = $Result.DefaultSelection<Prisma.$CoachPayload>
/**
 * Model CoachCertificate
 * 
 */
export type CoachCertificate = $Result.DefaultSelection<Prisma.$CoachCertificatePayload>
/**
 * Model CoachExperience
 * 
 */
export type CoachExperience = $Result.DefaultSelection<Prisma.$CoachExperiencePayload>
/**
 * Model CoachAchievement
 * 
 */
export type CoachAchievement = $Result.DefaultSelection<Prisma.$CoachAchievementPayload>
/**
 * Model WorkoutLog
 * 
 */
export type WorkoutLog = $Result.DefaultSelection<Prisma.$WorkoutLogPayload>
/**
 * Model NutritionLog
 * 
 */
export type NutritionLog = $Result.DefaultSelection<Prisma.$NutritionLogPayload>
/**
 * Model SupplementLog
 * 
 */
export type SupplementLog = $Result.DefaultSelection<Prisma.$SupplementLogPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Recommendation
 * 
 */
export type Recommendation = $Result.DefaultSelection<Prisma.$RecommendationPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Bundle
 * 
 */
export type Bundle = $Result.DefaultSelection<Prisma.$BundlePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Delivery
 * 
 */
export type Delivery = $Result.DefaultSelection<Prisma.$DeliveryPayload>
/**
 * Model Affiliate
 * 
 */
export type Affiliate = $Result.DefaultSelection<Prisma.$AffiliatePayload>
/**
 * Model CoachMessage
 * 
 */
export type CoachMessage = $Result.DefaultSelection<Prisma.$CoachMessagePayload>
/**
 * Model Commission
 * 
 */
export type Commission = $Result.DefaultSelection<Prisma.$CommissionPayload>
/**
 * Model Analytics
 * 
 */
export type Analytics = $Result.DefaultSelection<Prisma.$AnalyticsPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model WebhookEvent
 * 
 */
export type WebhookEvent = $Result.DefaultSelection<Prisma.$WebhookEventPayload>
/**
 * Model CoachRequest
 * 
 */
export type CoachRequest = $Result.DefaultSelection<Prisma.$CoachRequestPayload>
/**
 * Model UserIntake
 * 
 */
export type UserIntake = $Result.DefaultSelection<Prisma.$UserIntakePayload>
/**
 * Model SubscriptionQuota
 * 
 */
export type SubscriptionQuota = $Result.DefaultSelection<Prisma.$SubscriptionQuotaPayload>
/**
 * Model NutritionPreference
 * 
 */
export type NutritionPreference = $Result.DefaultSelection<Prisma.$NutritionPreferencePayload>
/**
 * Model NutritionAccess
 * 
 */
export type NutritionAccess = $Result.DefaultSelection<Prisma.$NutritionAccessPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  user: 'user',
  coach: 'coach',
  admin: 'admin',
  pending_coach: 'pending_coach'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const SubscriptionTier: {
  freemium: 'freemium',
  premium: 'premium',
  smart_premium: 'smart_premium'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.coach`: Exposes CRUD operations for the **Coach** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coaches
    * const coaches = await prisma.coach.findMany()
    * ```
    */
  get coach(): Prisma.CoachDelegate<ExtArgs>;

  /**
   * `prisma.coachCertificate`: Exposes CRUD operations for the **CoachCertificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachCertificates
    * const coachCertificates = await prisma.coachCertificate.findMany()
    * ```
    */
  get coachCertificate(): Prisma.CoachCertificateDelegate<ExtArgs>;

  /**
   * `prisma.coachExperience`: Exposes CRUD operations for the **CoachExperience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachExperiences
    * const coachExperiences = await prisma.coachExperience.findMany()
    * ```
    */
  get coachExperience(): Prisma.CoachExperienceDelegate<ExtArgs>;

  /**
   * `prisma.coachAchievement`: Exposes CRUD operations for the **CoachAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachAchievements
    * const coachAchievements = await prisma.coachAchievement.findMany()
    * ```
    */
  get coachAchievement(): Prisma.CoachAchievementDelegate<ExtArgs>;

  /**
   * `prisma.workoutLog`: Exposes CRUD operations for the **WorkoutLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutLogs
    * const workoutLogs = await prisma.workoutLog.findMany()
    * ```
    */
  get workoutLog(): Prisma.WorkoutLogDelegate<ExtArgs>;

  /**
   * `prisma.nutritionLog`: Exposes CRUD operations for the **NutritionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionLogs
    * const nutritionLogs = await prisma.nutritionLog.findMany()
    * ```
    */
  get nutritionLog(): Prisma.NutritionLogDelegate<ExtArgs>;

  /**
   * `prisma.supplementLog`: Exposes CRUD operations for the **SupplementLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplementLogs
    * const supplementLogs = await prisma.supplementLog.findMany()
    * ```
    */
  get supplementLog(): Prisma.SupplementLogDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.recommendation`: Exposes CRUD operations for the **Recommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recommendations
    * const recommendations = await prisma.recommendation.findMany()
    * ```
    */
  get recommendation(): Prisma.RecommendationDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.bundle`: Exposes CRUD operations for the **Bundle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bundles
    * const bundles = await prisma.bundle.findMany()
    * ```
    */
  get bundle(): Prisma.BundleDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.delivery`: Exposes CRUD operations for the **Delivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.delivery.findMany()
    * ```
    */
  get delivery(): Prisma.DeliveryDelegate<ExtArgs>;

  /**
   * `prisma.affiliate`: Exposes CRUD operations for the **Affiliate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Affiliates
    * const affiliates = await prisma.affiliate.findMany()
    * ```
    */
  get affiliate(): Prisma.AffiliateDelegate<ExtArgs>;

  /**
   * `prisma.coachMessage`: Exposes CRUD operations for the **CoachMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachMessages
    * const coachMessages = await prisma.coachMessage.findMany()
    * ```
    */
  get coachMessage(): Prisma.CoachMessageDelegate<ExtArgs>;

  /**
   * `prisma.commission`: Exposes CRUD operations for the **Commission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commissions
    * const commissions = await prisma.commission.findMany()
    * ```
    */
  get commission(): Prisma.CommissionDelegate<ExtArgs>;

  /**
   * `prisma.analytics`: Exposes CRUD operations for the **Analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analytics
    * const analytics = await prisma.analytics.findMany()
    * ```
    */
  get analytics(): Prisma.AnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.webhookEvent`: Exposes CRUD operations for the **WebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEvents
    * const webhookEvents = await prisma.webhookEvent.findMany()
    * ```
    */
  get webhookEvent(): Prisma.WebhookEventDelegate<ExtArgs>;

  /**
   * `prisma.coachRequest`: Exposes CRUD operations for the **CoachRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachRequests
    * const coachRequests = await prisma.coachRequest.findMany()
    * ```
    */
  get coachRequest(): Prisma.CoachRequestDelegate<ExtArgs>;

  /**
   * `prisma.userIntake`: Exposes CRUD operations for the **UserIntake** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserIntakes
    * const userIntakes = await prisma.userIntake.findMany()
    * ```
    */
  get userIntake(): Prisma.UserIntakeDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionQuota`: Exposes CRUD operations for the **SubscriptionQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionQuotas
    * const subscriptionQuotas = await prisma.subscriptionQuota.findMany()
    * ```
    */
  get subscriptionQuota(): Prisma.SubscriptionQuotaDelegate<ExtArgs>;

  /**
   * `prisma.nutritionPreference`: Exposes CRUD operations for the **NutritionPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionPreferences
    * const nutritionPreferences = await prisma.nutritionPreference.findMany()
    * ```
    */
  get nutritionPreference(): Prisma.NutritionPreferenceDelegate<ExtArgs>;

  /**
   * `prisma.nutritionAccess`: Exposes CRUD operations for the **NutritionAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionAccesses
    * const nutritionAccesses = await prisma.nutritionAccess.findMany()
    * ```
    */
  get nutritionAccess(): Prisma.NutritionAccessDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Coach: 'Coach',
    CoachCertificate: 'CoachCertificate',
    CoachExperience: 'CoachExperience',
    CoachAchievement: 'CoachAchievement',
    WorkoutLog: 'WorkoutLog',
    NutritionLog: 'NutritionLog',
    SupplementLog: 'SupplementLog',
    Subscription: 'Subscription',
    Recommendation: 'Recommendation',
    Category: 'Category',
    Bundle: 'Bundle',
    Product: 'Product',
    Delivery: 'Delivery',
    Affiliate: 'Affiliate',
    CoachMessage: 'CoachMessage',
    Commission: 'Commission',
    Analytics: 'Analytics',
    Notification: 'Notification',
    Milestone: 'Milestone',
    Payment: 'Payment',
    WebhookEvent: 'WebhookEvent',
    CoachRequest: 'CoachRequest',
    UserIntake: 'UserIntake',
    SubscriptionQuota: 'SubscriptionQuota',
    NutritionPreference: 'NutritionPreference',
    NutritionAccess: 'NutritionAccess'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "order" | "orderItem" | "coach" | "coachCertificate" | "coachExperience" | "coachAchievement" | "workoutLog" | "nutritionLog" | "supplementLog" | "subscription" | "recommendation" | "category" | "bundle" | "product" | "delivery" | "affiliate" | "coachMessage" | "commission" | "analytics" | "notification" | "milestone" | "payment" | "webhookEvent" | "coachRequest" | "userIntake" | "subscriptionQuota" | "nutritionPreference" | "nutritionAccess"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Coach: {
        payload: Prisma.$CoachPayload<ExtArgs>
        fields: Prisma.CoachFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          findFirst: {
            args: Prisma.CoachFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          findMany: {
            args: Prisma.CoachFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>[]
          }
          create: {
            args: Prisma.CoachCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          createMany: {
            args: Prisma.CoachCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>[]
          }
          delete: {
            args: Prisma.CoachDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          update: {
            args: Prisma.CoachUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          deleteMany: {
            args: Prisma.CoachDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoachUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPayload>
          }
          aggregate: {
            args: Prisma.CoachAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoach>
          }
          groupBy: {
            args: Prisma.CoachGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachCountArgs<ExtArgs>
            result: $Utils.Optional<CoachCountAggregateOutputType> | number
          }
        }
      }
      CoachCertificate: {
        payload: Prisma.$CoachCertificatePayload<ExtArgs>
        fields: Prisma.CoachCertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachCertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachCertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachCertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachCertificatePayload>
          }
          findFirst: {
            args: Prisma.CoachCertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachCertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachCertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachCertificatePayload>
          }
          findMany: {
            args: Prisma.CoachCertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachCertificatePayload>[]
          }
          create: {
            args: Prisma.CoachCertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachCertificatePayload>
          }
          createMany: {
            args: Prisma.CoachCertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachCertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachCertificatePayload>[]
          }
          delete: {
            args: Prisma.CoachCertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachCertificatePayload>
          }
          update: {
            args: Prisma.CoachCertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachCertificatePayload>
          }
          deleteMany: {
            args: Prisma.CoachCertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachCertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoachCertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachCertificatePayload>
          }
          aggregate: {
            args: Prisma.CoachCertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachCertificate>
          }
          groupBy: {
            args: Prisma.CoachCertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachCertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachCertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CoachCertificateCountAggregateOutputType> | number
          }
        }
      }
      CoachExperience: {
        payload: Prisma.$CoachExperiencePayload<ExtArgs>
        fields: Prisma.CoachExperienceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachExperienceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachExperiencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachExperienceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachExperiencePayload>
          }
          findFirst: {
            args: Prisma.CoachExperienceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachExperiencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachExperienceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachExperiencePayload>
          }
          findMany: {
            args: Prisma.CoachExperienceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachExperiencePayload>[]
          }
          create: {
            args: Prisma.CoachExperienceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachExperiencePayload>
          }
          createMany: {
            args: Prisma.CoachExperienceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachExperienceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachExperiencePayload>[]
          }
          delete: {
            args: Prisma.CoachExperienceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachExperiencePayload>
          }
          update: {
            args: Prisma.CoachExperienceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachExperiencePayload>
          }
          deleteMany: {
            args: Prisma.CoachExperienceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachExperienceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoachExperienceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachExperiencePayload>
          }
          aggregate: {
            args: Prisma.CoachExperienceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachExperience>
          }
          groupBy: {
            args: Prisma.CoachExperienceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachExperienceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachExperienceCountArgs<ExtArgs>
            result: $Utils.Optional<CoachExperienceCountAggregateOutputType> | number
          }
        }
      }
      CoachAchievement: {
        payload: Prisma.$CoachAchievementPayload<ExtArgs>
        fields: Prisma.CoachAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAchievementPayload>
          }
          findFirst: {
            args: Prisma.CoachAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAchievementPayload>
          }
          findMany: {
            args: Prisma.CoachAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAchievementPayload>[]
          }
          create: {
            args: Prisma.CoachAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAchievementPayload>
          }
          createMany: {
            args: Prisma.CoachAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAchievementPayload>[]
          }
          delete: {
            args: Prisma.CoachAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAchievementPayload>
          }
          update: {
            args: Prisma.CoachAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAchievementPayload>
          }
          deleteMany: {
            args: Prisma.CoachAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoachAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachAchievementPayload>
          }
          aggregate: {
            args: Prisma.CoachAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachAchievement>
          }
          groupBy: {
            args: Prisma.CoachAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<CoachAchievementCountAggregateOutputType> | number
          }
        }
      }
      WorkoutLog: {
        payload: Prisma.$WorkoutLogPayload<ExtArgs>
        fields: Prisma.WorkoutLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutLogPayload>
          }
          findFirst: {
            args: Prisma.WorkoutLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutLogPayload>
          }
          findMany: {
            args: Prisma.WorkoutLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutLogPayload>[]
          }
          create: {
            args: Prisma.WorkoutLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutLogPayload>
          }
          createMany: {
            args: Prisma.WorkoutLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutLogPayload>[]
          }
          delete: {
            args: Prisma.WorkoutLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutLogPayload>
          }
          update: {
            args: Prisma.WorkoutLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutLogPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkoutLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutLogPayload>
          }
          aggregate: {
            args: Prisma.WorkoutLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkoutLog>
          }
          groupBy: {
            args: Prisma.WorkoutLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutLogCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutLogCountAggregateOutputType> | number
          }
        }
      }
      NutritionLog: {
        payload: Prisma.$NutritionLogPayload<ExtArgs>
        fields: Prisma.NutritionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutritionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutritionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionLogPayload>
          }
          findFirst: {
            args: Prisma.NutritionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutritionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionLogPayload>
          }
          findMany: {
            args: Prisma.NutritionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionLogPayload>[]
          }
          create: {
            args: Prisma.NutritionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionLogPayload>
          }
          createMany: {
            args: Prisma.NutritionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NutritionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionLogPayload>[]
          }
          delete: {
            args: Prisma.NutritionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionLogPayload>
          }
          update: {
            args: Prisma.NutritionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionLogPayload>
          }
          deleteMany: {
            args: Prisma.NutritionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutritionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NutritionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionLogPayload>
          }
          aggregate: {
            args: Prisma.NutritionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionLog>
          }
          groupBy: {
            args: Prisma.NutritionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutritionLogCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionLogCountAggregateOutputType> | number
          }
        }
      }
      SupplementLog: {
        payload: Prisma.$SupplementLogPayload<ExtArgs>
        fields: Prisma.SupplementLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplementLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplementLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplementLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplementLogPayload>
          }
          findFirst: {
            args: Prisma.SupplementLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplementLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplementLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplementLogPayload>
          }
          findMany: {
            args: Prisma.SupplementLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplementLogPayload>[]
          }
          create: {
            args: Prisma.SupplementLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplementLogPayload>
          }
          createMany: {
            args: Prisma.SupplementLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplementLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplementLogPayload>[]
          }
          delete: {
            args: Prisma.SupplementLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplementLogPayload>
          }
          update: {
            args: Prisma.SupplementLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplementLogPayload>
          }
          deleteMany: {
            args: Prisma.SupplementLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplementLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplementLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplementLogPayload>
          }
          aggregate: {
            args: Prisma.SupplementLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplementLog>
          }
          groupBy: {
            args: Prisma.SupplementLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplementLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplementLogCountArgs<ExtArgs>
            result: $Utils.Optional<SupplementLogCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Recommendation: {
        payload: Prisma.$RecommendationPayload<ExtArgs>
        fields: Prisma.RecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          findFirst: {
            args: Prisma.RecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          findMany: {
            args: Prisma.RecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
          }
          create: {
            args: Prisma.RecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          createMany: {
            args: Prisma.RecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
          }
          delete: {
            args: Prisma.RecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          update: {
            args: Prisma.RecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          deleteMany: {
            args: Prisma.RecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          aggregate: {
            args: Prisma.RecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecommendation>
          }
          groupBy: {
            args: Prisma.RecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<RecommendationCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Bundle: {
        payload: Prisma.$BundlePayload<ExtArgs>
        fields: Prisma.BundleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BundleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BundleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundlePayload>
          }
          findFirst: {
            args: Prisma.BundleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BundleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundlePayload>
          }
          findMany: {
            args: Prisma.BundleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundlePayload>[]
          }
          create: {
            args: Prisma.BundleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundlePayload>
          }
          createMany: {
            args: Prisma.BundleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BundleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundlePayload>[]
          }
          delete: {
            args: Prisma.BundleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundlePayload>
          }
          update: {
            args: Prisma.BundleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundlePayload>
          }
          deleteMany: {
            args: Prisma.BundleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BundleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BundleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BundlePayload>
          }
          aggregate: {
            args: Prisma.BundleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBundle>
          }
          groupBy: {
            args: Prisma.BundleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BundleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BundleCountArgs<ExtArgs>
            result: $Utils.Optional<BundleCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Delivery: {
        payload: Prisma.$DeliveryPayload<ExtArgs>
        fields: Prisma.DeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findFirst: {
            args: Prisma.DeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findMany: {
            args: Prisma.DeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          create: {
            args: Prisma.DeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          createMany: {
            args: Prisma.DeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          delete: {
            args: Prisma.DeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          update: {
            args: Prisma.DeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          aggregate: {
            args: Prisma.DeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelivery>
          }
          groupBy: {
            args: Prisma.DeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryCountAggregateOutputType> | number
          }
        }
      }
      Affiliate: {
        payload: Prisma.$AffiliatePayload<ExtArgs>
        fields: Prisma.AffiliateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          findFirst: {
            args: Prisma.AffiliateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          findMany: {
            args: Prisma.AffiliateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>[]
          }
          create: {
            args: Prisma.AffiliateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          createMany: {
            args: Prisma.AffiliateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>[]
          }
          delete: {
            args: Prisma.AffiliateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          update: {
            args: Prisma.AffiliateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          deleteMany: {
            args: Prisma.AffiliateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatePayload>
          }
          aggregate: {
            args: Prisma.AffiliateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliate>
          }
          groupBy: {
            args: Prisma.AffiliateGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateCountAggregateOutputType> | number
          }
        }
      }
      CoachMessage: {
        payload: Prisma.$CoachMessagePayload<ExtArgs>
        fields: Prisma.CoachMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachMessagePayload>
          }
          findFirst: {
            args: Prisma.CoachMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachMessagePayload>
          }
          findMany: {
            args: Prisma.CoachMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachMessagePayload>[]
          }
          create: {
            args: Prisma.CoachMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachMessagePayload>
          }
          createMany: {
            args: Prisma.CoachMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachMessagePayload>[]
          }
          delete: {
            args: Prisma.CoachMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachMessagePayload>
          }
          update: {
            args: Prisma.CoachMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachMessagePayload>
          }
          deleteMany: {
            args: Prisma.CoachMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoachMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachMessagePayload>
          }
          aggregate: {
            args: Prisma.CoachMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachMessage>
          }
          groupBy: {
            args: Prisma.CoachMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachMessageCountArgs<ExtArgs>
            result: $Utils.Optional<CoachMessageCountAggregateOutputType> | number
          }
        }
      }
      Commission: {
        payload: Prisma.$CommissionPayload<ExtArgs>
        fields: Prisma.CommissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          findFirst: {
            args: Prisma.CommissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          findMany: {
            args: Prisma.CommissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>[]
          }
          create: {
            args: Prisma.CommissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          createMany: {
            args: Prisma.CommissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>[]
          }
          delete: {
            args: Prisma.CommissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          update: {
            args: Prisma.CommissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          deleteMany: {
            args: Prisma.CommissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          aggregate: {
            args: Prisma.CommissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommission>
          }
          groupBy: {
            args: Prisma.CommissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommissionCountArgs<ExtArgs>
            result: $Utils.Optional<CommissionCountAggregateOutputType> | number
          }
        }
      }
      Analytics: {
        payload: Prisma.$AnalyticsPayload<ExtArgs>
        fields: Prisma.AnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findMany: {
            args: Prisma.AnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          create: {
            args: Prisma.AnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          createMany: {
            args: Prisma.AnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          update: {
            args: Prisma.AnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalytics>
          }
          groupBy: {
            args: Prisma.AnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      WebhookEvent: {
        payload: Prisma.$WebhookEventPayload<ExtArgs>
        fields: Prisma.WebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findFirst: {
            args: Prisma.WebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findMany: {
            args: Prisma.WebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          create: {
            args: Prisma.WebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          createMany: {
            args: Prisma.WebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          delete: {
            args: Prisma.WebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          update: {
            args: Prisma.WebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          aggregate: {
            args: Prisma.WebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEvent>
          }
          groupBy: {
            args: Prisma.WebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventCountAggregateOutputType> | number
          }
        }
      }
      CoachRequest: {
        payload: Prisma.$CoachRequestPayload<ExtArgs>
        fields: Prisma.CoachRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          findFirst: {
            args: Prisma.CoachRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          findMany: {
            args: Prisma.CoachRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>[]
          }
          create: {
            args: Prisma.CoachRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          createMany: {
            args: Prisma.CoachRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>[]
          }
          delete: {
            args: Prisma.CoachRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          update: {
            args: Prisma.CoachRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          deleteMany: {
            args: Prisma.CoachRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoachRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          aggregate: {
            args: Prisma.CoachRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachRequest>
          }
          groupBy: {
            args: Prisma.CoachRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CoachRequestCountAggregateOutputType> | number
          }
        }
      }
      UserIntake: {
        payload: Prisma.$UserIntakePayload<ExtArgs>
        fields: Prisma.UserIntakeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserIntakeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIntakePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserIntakeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIntakePayload>
          }
          findFirst: {
            args: Prisma.UserIntakeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIntakePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserIntakeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIntakePayload>
          }
          findMany: {
            args: Prisma.UserIntakeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIntakePayload>[]
          }
          create: {
            args: Prisma.UserIntakeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIntakePayload>
          }
          createMany: {
            args: Prisma.UserIntakeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserIntakeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIntakePayload>[]
          }
          delete: {
            args: Prisma.UserIntakeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIntakePayload>
          }
          update: {
            args: Prisma.UserIntakeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIntakePayload>
          }
          deleteMany: {
            args: Prisma.UserIntakeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserIntakeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserIntakeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserIntakePayload>
          }
          aggregate: {
            args: Prisma.UserIntakeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserIntake>
          }
          groupBy: {
            args: Prisma.UserIntakeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserIntakeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserIntakeCountArgs<ExtArgs>
            result: $Utils.Optional<UserIntakeCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionQuota: {
        payload: Prisma.$SubscriptionQuotaPayload<ExtArgs>
        fields: Prisma.SubscriptionQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionQuotaPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionQuotaPayload>
          }
          findMany: {
            args: Prisma.SubscriptionQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionQuotaPayload>[]
          }
          create: {
            args: Prisma.SubscriptionQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionQuotaPayload>
          }
          createMany: {
            args: Prisma.SubscriptionQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionQuotaPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionQuotaPayload>
          }
          update: {
            args: Prisma.SubscriptionQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionQuotaPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionQuotaPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionQuota>
          }
          groupBy: {
            args: Prisma.SubscriptionQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionQuotaCountAggregateOutputType> | number
          }
        }
      }
      NutritionPreference: {
        payload: Prisma.$NutritionPreferencePayload<ExtArgs>
        fields: Prisma.NutritionPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutritionPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutritionPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionPreferencePayload>
          }
          findFirst: {
            args: Prisma.NutritionPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutritionPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionPreferencePayload>
          }
          findMany: {
            args: Prisma.NutritionPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionPreferencePayload>[]
          }
          create: {
            args: Prisma.NutritionPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionPreferencePayload>
          }
          createMany: {
            args: Prisma.NutritionPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NutritionPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionPreferencePayload>[]
          }
          delete: {
            args: Prisma.NutritionPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionPreferencePayload>
          }
          update: {
            args: Prisma.NutritionPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NutritionPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutritionPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NutritionPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionPreferencePayload>
          }
          aggregate: {
            args: Prisma.NutritionPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionPreference>
          }
          groupBy: {
            args: Prisma.NutritionPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutritionPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionPreferenceCountAggregateOutputType> | number
          }
        }
      }
      NutritionAccess: {
        payload: Prisma.$NutritionAccessPayload<ExtArgs>
        fields: Prisma.NutritionAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutritionAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutritionAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionAccessPayload>
          }
          findFirst: {
            args: Prisma.NutritionAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutritionAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionAccessPayload>
          }
          findMany: {
            args: Prisma.NutritionAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionAccessPayload>[]
          }
          create: {
            args: Prisma.NutritionAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionAccessPayload>
          }
          createMany: {
            args: Prisma.NutritionAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NutritionAccessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionAccessPayload>[]
          }
          delete: {
            args: Prisma.NutritionAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionAccessPayload>
          }
          update: {
            args: Prisma.NutritionAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionAccessPayload>
          }
          deleteMany: {
            args: Prisma.NutritionAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutritionAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NutritionAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionAccessPayload>
          }
          aggregate: {
            args: Prisma.NutritionAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionAccess>
          }
          groupBy: {
            args: Prisma.NutritionAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutritionAccessCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionAccessCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
    milestones: number
    payments: number
    recommendations: number
    commissions: number
    Session: number
    Order: number
    WorkoutLog: number
    NutritionLog: number
    SupplementLog: number
    Subscription: number
    coachRequests: number
    coachMessages: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    milestones?: boolean | UserCountOutputTypeCountMilestonesArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    recommendations?: boolean | UserCountOutputTypeCountRecommendationsArgs
    commissions?: boolean | UserCountOutputTypeCountCommissionsArgs
    Session?: boolean | UserCountOutputTypeCountSessionArgs
    Order?: boolean | UserCountOutputTypeCountOrderArgs
    WorkoutLog?: boolean | UserCountOutputTypeCountWorkoutLogArgs
    NutritionLog?: boolean | UserCountOutputTypeCountNutritionLogArgs
    SupplementLog?: boolean | UserCountOutputTypeCountSupplementLogArgs
    Subscription?: boolean | UserCountOutputTypeCountSubscriptionArgs
    coachRequests?: boolean | UserCountOutputTypeCountCoachRequestsArgs
    coachMessages?: boolean | UserCountOutputTypeCountCoachMessagesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkoutLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNutritionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupplementLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplementLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoachRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoachMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachMessageWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    commissions: number
    payments: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    commissions?: boolean | OrderCountOutputTypeCountCommissionsArgs
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type CoachCountOutputType
   */

  export type CoachCountOutputType = {
    clients: number
    commissions: number
    recommendations: number
    sessions: number
    messages: number
    certificates: number
    experiences: number
    achievements: number
  }

  export type CoachCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | CoachCountOutputTypeCountClientsArgs
    commissions?: boolean | CoachCountOutputTypeCountCommissionsArgs
    recommendations?: boolean | CoachCountOutputTypeCountRecommendationsArgs
    sessions?: boolean | CoachCountOutputTypeCountSessionsArgs
    messages?: boolean | CoachCountOutputTypeCountMessagesArgs
    certificates?: boolean | CoachCountOutputTypeCountCertificatesArgs
    experiences?: boolean | CoachCountOutputTypeCountExperiencesArgs
    achievements?: boolean | CoachCountOutputTypeCountAchievementsArgs
  }

  // Custom InputTypes
  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCountOutputType
     */
    select?: CoachCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionWhereInput
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendationWhereInput
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachMessageWhereInput
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachCertificateWhereInput
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachExperienceWhereInput
  }

  /**
   * CoachCountOutputType without action
   */
  export type CoachCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachAchievementWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    payments: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SubscriptionCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type BundleCountOutputType
   */

  export type BundleCountOutputType = {
    products: number
  }

  export type BundleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | BundleCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * BundleCountOutputType without action
   */
  export type BundleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BundleCountOutputType
     */
    select?: BundleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BundleCountOutputType without action
   */
  export type BundleCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    bundles: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bundles?: boolean | ProductCountOutputTypeCountBundlesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountBundlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BundleWhereInput
  }


  /**
   * Count Type AffiliateCountOutputType
   */

  export type AffiliateCountOutputType = {
    commissions: number
  }

  export type AffiliateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commissions?: boolean | AffiliateCountOutputTypeCountCommissionsArgs
  }

  // Custom InputTypes
  /**
   * AffiliateCountOutputType without action
   */
  export type AffiliateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateCountOutputType
     */
    select?: AffiliateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AffiliateCountOutputType without action
   */
  export type AffiliateCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    preferredLocale: string | null
    deviceToken: string | null
    role: $Enums.UserRole | null
    coachId: string | null
    coachClientsId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    preferredLocale: string | null
    deviceToken: string | null
    role: $Enums.UserRole | null
    coachId: string | null
    coachClientsId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    phone: number
    preferredLocale: number
    deviceToken: number
    role: number
    coachId: number
    coachClientsId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    preferredLocale?: true
    deviceToken?: true
    role?: true
    coachId?: true
    coachClientsId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    preferredLocale?: true
    deviceToken?: true
    role?: true
    coachId?: true
    coachClientsId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    preferredLocale?: true
    deviceToken?: true
    role?: true
    coachId?: true
    coachClientsId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    name: string | null
    phone: string | null
    preferredLocale: string | null
    deviceToken: string | null
    role: $Enums.UserRole
    coachId: string | null
    coachClientsId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    preferredLocale?: boolean
    deviceToken?: boolean
    role?: boolean
    coachId?: boolean
    coachClientsId?: boolean
    coach?: boolean | User$coachArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    milestones?: boolean | User$milestonesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    recommendations?: boolean | User$recommendationsArgs<ExtArgs>
    commissions?: boolean | User$commissionsArgs<ExtArgs>
    coachClients?: boolean | User$coachClientsArgs<ExtArgs>
    Session?: boolean | User$SessionArgs<ExtArgs>
    Order?: boolean | User$OrderArgs<ExtArgs>
    WorkoutLog?: boolean | User$WorkoutLogArgs<ExtArgs>
    NutritionLog?: boolean | User$NutritionLogArgs<ExtArgs>
    SupplementLog?: boolean | User$SupplementLogArgs<ExtArgs>
    Subscription?: boolean | User$SubscriptionArgs<ExtArgs>
    coachRequests?: boolean | User$coachRequestsArgs<ExtArgs>
    intake?: boolean | User$intakeArgs<ExtArgs>
    subscriptionQuota?: boolean | User$subscriptionQuotaArgs<ExtArgs>
    nutritionPreference?: boolean | User$nutritionPreferenceArgs<ExtArgs>
    nutritionAccess?: boolean | User$nutritionAccessArgs<ExtArgs>
    coachMessages?: boolean | User$coachMessagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    preferredLocale?: boolean
    deviceToken?: boolean
    role?: boolean
    coachId?: boolean
    coachClientsId?: boolean
    coachClients?: boolean | User$coachClientsArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    preferredLocale?: boolean
    deviceToken?: boolean
    role?: boolean
    coachId?: boolean
    coachClientsId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | User$coachArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    milestones?: boolean | User$milestonesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    recommendations?: boolean | User$recommendationsArgs<ExtArgs>
    commissions?: boolean | User$commissionsArgs<ExtArgs>
    coachClients?: boolean | User$coachClientsArgs<ExtArgs>
    Session?: boolean | User$SessionArgs<ExtArgs>
    Order?: boolean | User$OrderArgs<ExtArgs>
    WorkoutLog?: boolean | User$WorkoutLogArgs<ExtArgs>
    NutritionLog?: boolean | User$NutritionLogArgs<ExtArgs>
    SupplementLog?: boolean | User$SupplementLogArgs<ExtArgs>
    Subscription?: boolean | User$SubscriptionArgs<ExtArgs>
    coachRequests?: boolean | User$coachRequestsArgs<ExtArgs>
    intake?: boolean | User$intakeArgs<ExtArgs>
    subscriptionQuota?: boolean | User$subscriptionQuotaArgs<ExtArgs>
    nutritionPreference?: boolean | User$nutritionPreferenceArgs<ExtArgs>
    nutritionAccess?: boolean | User$nutritionAccessArgs<ExtArgs>
    coachMessages?: boolean | User$coachMessagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coachClients?: boolean | User$coachClientsArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      coach: Prisma.$CoachPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      recommendations: Prisma.$RecommendationPayload<ExtArgs>[]
      commissions: Prisma.$CommissionPayload<ExtArgs>[]
      coachClients: Prisma.$CoachPayload<ExtArgs> | null
      Session: Prisma.$SessionPayload<ExtArgs>[]
      Order: Prisma.$OrderPayload<ExtArgs>[]
      WorkoutLog: Prisma.$WorkoutLogPayload<ExtArgs>[]
      NutritionLog: Prisma.$NutritionLogPayload<ExtArgs>[]
      SupplementLog: Prisma.$SupplementLogPayload<ExtArgs>[]
      Subscription: Prisma.$SubscriptionPayload<ExtArgs>[]
      coachRequests: Prisma.$CoachRequestPayload<ExtArgs>[]
      intake: Prisma.$UserIntakePayload<ExtArgs> | null
      subscriptionQuota: Prisma.$SubscriptionQuotaPayload<ExtArgs> | null
      nutritionPreference: Prisma.$NutritionPreferencePayload<ExtArgs> | null
      nutritionAccess: Prisma.$NutritionAccessPayload<ExtArgs> | null
      coachMessages: Prisma.$CoachMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      name: string | null
      phone: string | null
      preferredLocale: string | null
      deviceToken: string | null
      role: $Enums.UserRole
      coachId: string | null
      coachClientsId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends User$coachArgs<ExtArgs> = {}>(args?: Subset<T, User$coachArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    milestones<T extends User$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, User$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    recommendations<T extends User$recommendationsArgs<ExtArgs> = {}>(args?: Subset<T, User$recommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    commissions<T extends User$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findMany"> | Null>
    coachClients<T extends User$coachClientsArgs<ExtArgs> = {}>(args?: Subset<T, User$coachClientsArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Session<T extends User$SessionArgs<ExtArgs> = {}>(args?: Subset<T, User$SessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    Order<T extends User$OrderArgs<ExtArgs> = {}>(args?: Subset<T, User$OrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    WorkoutLog<T extends User$WorkoutLogArgs<ExtArgs> = {}>(args?: Subset<T, User$WorkoutLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "findMany"> | Null>
    NutritionLog<T extends User$NutritionLogArgs<ExtArgs> = {}>(args?: Subset<T, User$NutritionLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "findMany"> | Null>
    SupplementLog<T extends User$SupplementLogArgs<ExtArgs> = {}>(args?: Subset<T, User$SupplementLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "findMany"> | Null>
    Subscription<T extends User$SubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$SubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    coachRequests<T extends User$coachRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$coachRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findMany"> | Null>
    intake<T extends User$intakeArgs<ExtArgs> = {}>(args?: Subset<T, User$intakeArgs<ExtArgs>>): Prisma__UserIntakeClient<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subscriptionQuota<T extends User$subscriptionQuotaArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionQuotaArgs<ExtArgs>>): Prisma__SubscriptionQuotaClient<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    nutritionPreference<T extends User$nutritionPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, User$nutritionPreferenceArgs<ExtArgs>>): Prisma__NutritionPreferenceClient<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    nutritionAccess<T extends User$nutritionAccessArgs<ExtArgs> = {}>(args?: Subset<T, User$nutritionAccessArgs<ExtArgs>>): Prisma__NutritionAccessClient<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    coachMessages<T extends User$coachMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$coachMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly preferredLocale: FieldRef<"User", 'String'>
    readonly deviceToken: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly coachId: FieldRef<"User", 'String'>
    readonly coachClientsId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.coach
   */
  export type User$coachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    where?: CoachWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.milestones
   */
  export type User$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.recommendations
   */
  export type User$recommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    where?: RecommendationWhereInput
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    cursor?: RecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * User.commissions
   */
  export type User$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    where?: CommissionWhereInput
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    cursor?: CommissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * User.coachClients
   */
  export type User$coachClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    where?: CoachWhereInput
  }

  /**
   * User.Session
   */
  export type User$SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.Order
   */
  export type User$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.WorkoutLog
   */
  export type User$WorkoutLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
    where?: WorkoutLogWhereInput
    orderBy?: WorkoutLogOrderByWithRelationInput | WorkoutLogOrderByWithRelationInput[]
    cursor?: WorkoutLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutLogScalarFieldEnum | WorkoutLogScalarFieldEnum[]
  }

  /**
   * User.NutritionLog
   */
  export type User$NutritionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
    where?: NutritionLogWhereInput
    orderBy?: NutritionLogOrderByWithRelationInput | NutritionLogOrderByWithRelationInput[]
    cursor?: NutritionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NutritionLogScalarFieldEnum | NutritionLogScalarFieldEnum[]
  }

  /**
   * User.SupplementLog
   */
  export type User$SupplementLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
    where?: SupplementLogWhereInput
    orderBy?: SupplementLogOrderByWithRelationInput | SupplementLogOrderByWithRelationInput[]
    cursor?: SupplementLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplementLogScalarFieldEnum | SupplementLogScalarFieldEnum[]
  }

  /**
   * User.Subscription
   */
  export type User$SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User.coachRequests
   */
  export type User$coachRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    where?: CoachRequestWhereInput
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    cursor?: CoachRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachRequestScalarFieldEnum | CoachRequestScalarFieldEnum[]
  }

  /**
   * User.intake
   */
  export type User$intakeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
    where?: UserIntakeWhereInput
  }

  /**
   * User.subscriptionQuota
   */
  export type User$subscriptionQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
    where?: SubscriptionQuotaWhereInput
  }

  /**
   * User.nutritionPreference
   */
  export type User$nutritionPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
    where?: NutritionPreferenceWhereInput
  }

  /**
   * User.nutritionAccess
   */
  export type User$nutritionAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
    where?: NutritionAccessWhereInput
  }

  /**
   * User.coachMessages
   */
  export type User$coachMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    where?: CoachMessageWhereInput
    orderBy?: CoachMessageOrderByWithRelationInput | CoachMessageOrderByWithRelationInput[]
    cursor?: CoachMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachMessageScalarFieldEnum | CoachMessageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    durationMin: number | null
    rating: number | null
  }

  export type SessionSumAggregateOutputType = {
    durationMin: number | null
    rating: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    coachId: string | null
    scheduledAt: Date | null
    durationMin: number | null
    status: string | null
    agoraChannel: string | null
    rating: number | null
    ratingNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    coachId: string | null
    scheduledAt: Date | null
    durationMin: number | null
    status: string | null
    agoraChannel: string | null
    rating: number | null
    ratingNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    coachId: number
    scheduledAt: number
    durationMin: number
    status: number
    agoraChannel: number
    rating: number
    ratingNote: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    durationMin?: true
    rating?: true
  }

  export type SessionSumAggregateInputType = {
    durationMin?: true
    rating?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    coachId?: true
    scheduledAt?: true
    durationMin?: true
    status?: true
    agoraChannel?: true
    rating?: true
    ratingNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    coachId?: true
    scheduledAt?: true
    durationMin?: true
    status?: true
    agoraChannel?: true
    rating?: true
    ratingNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    coachId?: true
    scheduledAt?: true
    durationMin?: true
    status?: true
    agoraChannel?: true
    rating?: true
    ratingNote?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    coachId: string | null
    scheduledAt: Date
    durationMin: number
    status: string
    agoraChannel: string | null
    rating: number | null
    ratingNote: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coachId?: boolean
    scheduledAt?: boolean
    durationMin?: boolean
    status?: boolean
    agoraChannel?: boolean
    rating?: boolean
    ratingNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | Session$coachArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coachId?: boolean
    scheduledAt?: boolean
    durationMin?: boolean
    status?: boolean
    agoraChannel?: boolean
    rating?: boolean
    ratingNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | Session$coachArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    coachId?: boolean
    scheduledAt?: boolean
    durationMin?: boolean
    status?: boolean
    agoraChannel?: boolean
    rating?: boolean
    ratingNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | Session$coachArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | Session$coachArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coach: Prisma.$CoachPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      coachId: string | null
      scheduledAt: Date
      durationMin: number
      status: string
      agoraChannel: string | null
      rating: number | null
      ratingNote: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    coach<T extends Session$coachArgs<ExtArgs> = {}>(args?: Subset<T, Session$coachArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly coachId: FieldRef<"Session", 'String'>
    readonly scheduledAt: FieldRef<"Session", 'DateTime'>
    readonly durationMin: FieldRef<"Session", 'Int'>
    readonly status: FieldRef<"Session", 'String'>
    readonly agoraChannel: FieldRef<"Session", 'String'>
    readonly rating: FieldRef<"Session", 'Int'>
    readonly ratingNote: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session.coach
   */
  export type Session$coachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    where?: CoachWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalCents: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalCents: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalCents: number | null
    currency: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalCents: number | null
    currency: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    totalCents: number
    currency: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalCents?: true
  }

  export type OrderSumAggregateInputType = {
    totalCents?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    totalCents?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    totalCents?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    totalCents?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    userId: string
    totalCents: number
    currency: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalCents?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    commissions?: boolean | Order$commissionsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    Delivery?: boolean | Order$DeliveryArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalCents?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    totalCents?: boolean
    currency?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    commissions?: boolean | Order$commissionsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    Delivery?: boolean | Order$DeliveryArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      commissions: Prisma.$CommissionPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      Delivery: Prisma.$DeliveryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalCents: number
      currency: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    commissions<T extends Order$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, Order$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    Delivery<T extends Order$DeliveryArgs<ExtArgs> = {}>(args?: Subset<T, Order$DeliveryArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly totalCents: FieldRef<"Order", 'Int'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.commissions
   */
  export type Order$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    where?: CommissionWhereInput
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    cursor?: CommissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order.Delivery
   */
  export type Order$DeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    qty: number | null
    priceCents: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    qty: number | null
    priceCents: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    sku: string | null
    qty: number | null
    priceCents: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    sku: string | null
    qty: number | null
    priceCents: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    sku: number
    qty: number
    priceCents: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    qty?: true
    priceCents?: true
  }

  export type OrderItemSumAggregateInputType = {
    qty?: true
    priceCents?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    sku?: true
    qty?: true
    priceCents?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    sku?: true
    qty?: true
    priceCents?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    sku?: true
    qty?: true
    priceCents?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    sku: string
    qty: number
    priceCents: number
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    sku?: boolean
    qty?: boolean
    priceCents?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    sku?: boolean
    qty?: boolean
    priceCents?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    sku?: boolean
    qty?: boolean
    priceCents?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      sku: string
      qty: number
      priceCents: number
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly sku: FieldRef<"OrderItem", 'String'>
    readonly qty: FieldRef<"OrderItem", 'Int'>
    readonly priceCents: FieldRef<"OrderItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Coach
   */

  export type AggregateCoach = {
    _count: CoachCountAggregateOutputType | null
    _avg: CoachAvgAggregateOutputType | null
    _sum: CoachSumAggregateOutputType | null
    _min: CoachMinAggregateOutputType | null
    _max: CoachMaxAggregateOutputType | null
  }

  export type CoachAvgAggregateOutputType = {
    experienceYears: number | null
  }

  export type CoachSumAggregateOutputType = {
    experienceYears: number | null
  }

  export type CoachMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    certifications: string | null
    referralCode: string | null
    experienceYears: number | null
    headline: string | null
    verified: boolean | null
  }

  export type CoachMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    certifications: string | null
    referralCode: string | null
    experienceYears: number | null
    headline: string | null
    verified: boolean | null
  }

  export type CoachCountAggregateOutputType = {
    id: number
    userId: number
    bio: number
    certifications: number
    referralCode: number
    specializations: number
    experienceYears: number
    headline: number
    verified: number
    _all: number
  }


  export type CoachAvgAggregateInputType = {
    experienceYears?: true
  }

  export type CoachSumAggregateInputType = {
    experienceYears?: true
  }

  export type CoachMinAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    certifications?: true
    referralCode?: true
    experienceYears?: true
    headline?: true
    verified?: true
  }

  export type CoachMaxAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    certifications?: true
    referralCode?: true
    experienceYears?: true
    headline?: true
    verified?: true
  }

  export type CoachCountAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    certifications?: true
    referralCode?: true
    specializations?: true
    experienceYears?: true
    headline?: true
    verified?: true
    _all?: true
  }

  export type CoachAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coach to aggregate.
     */
    where?: CoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coaches to fetch.
     */
    orderBy?: CoachOrderByWithRelationInput | CoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coaches
    **/
    _count?: true | CoachCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoachAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoachSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachMaxAggregateInputType
  }

  export type GetCoachAggregateType<T extends CoachAggregateArgs> = {
        [P in keyof T & keyof AggregateCoach]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoach[P]>
      : GetScalarType<T[P], AggregateCoach[P]>
  }




  export type CoachGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachWhereInput
    orderBy?: CoachOrderByWithAggregationInput | CoachOrderByWithAggregationInput[]
    by: CoachScalarFieldEnum[] | CoachScalarFieldEnum
    having?: CoachScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachCountAggregateInputType | true
    _avg?: CoachAvgAggregateInputType
    _sum?: CoachSumAggregateInputType
    _min?: CoachMinAggregateInputType
    _max?: CoachMaxAggregateInputType
  }

  export type CoachGroupByOutputType = {
    id: string
    userId: string
    bio: string | null
    certifications: string | null
    referralCode: string | null
    specializations: string[]
    experienceYears: number | null
    headline: string | null
    verified: boolean
    _count: CoachCountAggregateOutputType | null
    _avg: CoachAvgAggregateOutputType | null
    _sum: CoachSumAggregateOutputType | null
    _min: CoachMinAggregateOutputType | null
    _max: CoachMaxAggregateOutputType | null
  }

  type GetCoachGroupByPayload<T extends CoachGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachGroupByOutputType[P]>
            : GetScalarType<T[P], CoachGroupByOutputType[P]>
        }
      >
    >


  export type CoachSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    certifications?: boolean
    referralCode?: boolean
    specializations?: boolean
    experienceYears?: boolean
    headline?: boolean
    verified?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clients?: boolean | Coach$clientsArgs<ExtArgs>
    commissions?: boolean | Coach$commissionsArgs<ExtArgs>
    recommendations?: boolean | Coach$recommendationsArgs<ExtArgs>
    sessions?: boolean | Coach$sessionsArgs<ExtArgs>
    messages?: boolean | Coach$messagesArgs<ExtArgs>
    certificates?: boolean | Coach$certificatesArgs<ExtArgs>
    experiences?: boolean | Coach$experiencesArgs<ExtArgs>
    achievements?: boolean | Coach$achievementsArgs<ExtArgs>
    _count?: boolean | CoachCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coach"]>

  export type CoachSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    certifications?: boolean
    referralCode?: boolean
    specializations?: boolean
    experienceYears?: boolean
    headline?: boolean
    verified?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coach"]>

  export type CoachSelectScalar = {
    id?: boolean
    userId?: boolean
    bio?: boolean
    certifications?: boolean
    referralCode?: boolean
    specializations?: boolean
    experienceYears?: boolean
    headline?: boolean
    verified?: boolean
  }

  export type CoachInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clients?: boolean | Coach$clientsArgs<ExtArgs>
    commissions?: boolean | Coach$commissionsArgs<ExtArgs>
    recommendations?: boolean | Coach$recommendationsArgs<ExtArgs>
    sessions?: boolean | Coach$sessionsArgs<ExtArgs>
    messages?: boolean | Coach$messagesArgs<ExtArgs>
    certificates?: boolean | Coach$certificatesArgs<ExtArgs>
    experiences?: boolean | Coach$experiencesArgs<ExtArgs>
    achievements?: boolean | Coach$achievementsArgs<ExtArgs>
    _count?: boolean | CoachCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CoachIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoachPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coach"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      clients: Prisma.$UserPayload<ExtArgs>[]
      commissions: Prisma.$CommissionPayload<ExtArgs>[]
      recommendations: Prisma.$RecommendationPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      messages: Prisma.$CoachMessagePayload<ExtArgs>[]
      certificates: Prisma.$CoachCertificatePayload<ExtArgs>[]
      experiences: Prisma.$CoachExperiencePayload<ExtArgs>[]
      achievements: Prisma.$CoachAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bio: string | null
      certifications: string | null
      referralCode: string | null
      specializations: string[]
      experienceYears: number | null
      headline: string | null
      verified: boolean
    }, ExtArgs["result"]["coach"]>
    composites: {}
  }

  type CoachGetPayload<S extends boolean | null | undefined | CoachDefaultArgs> = $Result.GetResult<Prisma.$CoachPayload, S>

  type CoachCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoachFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoachCountAggregateInputType | true
    }

  export interface CoachDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coach'], meta: { name: 'Coach' } }
    /**
     * Find zero or one Coach that matches the filter.
     * @param {CoachFindUniqueArgs} args - Arguments to find a Coach
     * @example
     * // Get one Coach
     * const coach = await prisma.coach.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachFindUniqueArgs>(args: SelectSubset<T, CoachFindUniqueArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Coach that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoachFindUniqueOrThrowArgs} args - Arguments to find a Coach
     * @example
     * // Get one Coach
     * const coach = await prisma.coach.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Coach that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachFindFirstArgs} args - Arguments to find a Coach
     * @example
     * // Get one Coach
     * const coach = await prisma.coach.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachFindFirstArgs>(args?: SelectSubset<T, CoachFindFirstArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Coach that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachFindFirstOrThrowArgs} args - Arguments to find a Coach
     * @example
     * // Get one Coach
     * const coach = await prisma.coach.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Coaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coaches
     * const coaches = await prisma.coach.findMany()
     * 
     * // Get first 10 Coaches
     * const coaches = await prisma.coach.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachWithIdOnly = await prisma.coach.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachFindManyArgs>(args?: SelectSubset<T, CoachFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Coach.
     * @param {CoachCreateArgs} args - Arguments to create a Coach.
     * @example
     * // Create one Coach
     * const Coach = await prisma.coach.create({
     *   data: {
     *     // ... data to create a Coach
     *   }
     * })
     * 
     */
    create<T extends CoachCreateArgs>(args: SelectSubset<T, CoachCreateArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Coaches.
     * @param {CoachCreateManyArgs} args - Arguments to create many Coaches.
     * @example
     * // Create many Coaches
     * const coach = await prisma.coach.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachCreateManyArgs>(args?: SelectSubset<T, CoachCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coaches and returns the data saved in the database.
     * @param {CoachCreateManyAndReturnArgs} args - Arguments to create many Coaches.
     * @example
     * // Create many Coaches
     * const coach = await prisma.coach.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coaches and only return the `id`
     * const coachWithIdOnly = await prisma.coach.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Coach.
     * @param {CoachDeleteArgs} args - Arguments to delete one Coach.
     * @example
     * // Delete one Coach
     * const Coach = await prisma.coach.delete({
     *   where: {
     *     // ... filter to delete one Coach
     *   }
     * })
     * 
     */
    delete<T extends CoachDeleteArgs>(args: SelectSubset<T, CoachDeleteArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Coach.
     * @param {CoachUpdateArgs} args - Arguments to update one Coach.
     * @example
     * // Update one Coach
     * const coach = await prisma.coach.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachUpdateArgs>(args: SelectSubset<T, CoachUpdateArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Coaches.
     * @param {CoachDeleteManyArgs} args - Arguments to filter Coaches to delete.
     * @example
     * // Delete a few Coaches
     * const { count } = await prisma.coach.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachDeleteManyArgs>(args?: SelectSubset<T, CoachDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coaches
     * const coach = await prisma.coach.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachUpdateManyArgs>(args: SelectSubset<T, CoachUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coach.
     * @param {CoachUpsertArgs} args - Arguments to update or create a Coach.
     * @example
     * // Update or create a Coach
     * const coach = await prisma.coach.upsert({
     *   create: {
     *     // ... data to create a Coach
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coach we want to update
     *   }
     * })
     */
    upsert<T extends CoachUpsertArgs>(args: SelectSubset<T, CoachUpsertArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Coaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachCountArgs} args - Arguments to filter Coaches to count.
     * @example
     * // Count the number of Coaches
     * const count = await prisma.coach.count({
     *   where: {
     *     // ... the filter for the Coaches we want to count
     *   }
     * })
    **/
    count<T extends CoachCountArgs>(
      args?: Subset<T, CoachCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachAggregateArgs>(args: Subset<T, CoachAggregateArgs>): Prisma.PrismaPromise<GetCoachAggregateType<T>>

    /**
     * Group by Coach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachGroupByArgs['orderBy'] }
        : { orderBy?: CoachGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coach model
   */
  readonly fields: CoachFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coach.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    clients<T extends Coach$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Coach$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    commissions<T extends Coach$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, Coach$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findMany"> | Null>
    recommendations<T extends Coach$recommendationsArgs<ExtArgs> = {}>(args?: Subset<T, Coach$recommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Coach$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Coach$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Coach$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Coach$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends Coach$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Coach$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "findMany"> | Null>
    experiences<T extends Coach$experiencesArgs<ExtArgs> = {}>(args?: Subset<T, Coach$experiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "findMany"> | Null>
    achievements<T extends Coach$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, Coach$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coach model
   */ 
  interface CoachFieldRefs {
    readonly id: FieldRef<"Coach", 'String'>
    readonly userId: FieldRef<"Coach", 'String'>
    readonly bio: FieldRef<"Coach", 'String'>
    readonly certifications: FieldRef<"Coach", 'String'>
    readonly referralCode: FieldRef<"Coach", 'String'>
    readonly specializations: FieldRef<"Coach", 'String[]'>
    readonly experienceYears: FieldRef<"Coach", 'Int'>
    readonly headline: FieldRef<"Coach", 'String'>
    readonly verified: FieldRef<"Coach", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Coach findUnique
   */
  export type CoachFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter, which Coach to fetch.
     */
    where: CoachWhereUniqueInput
  }

  /**
   * Coach findUniqueOrThrow
   */
  export type CoachFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter, which Coach to fetch.
     */
    where: CoachWhereUniqueInput
  }

  /**
   * Coach findFirst
   */
  export type CoachFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter, which Coach to fetch.
     */
    where?: CoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coaches to fetch.
     */
    orderBy?: CoachOrderByWithRelationInput | CoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coaches.
     */
    cursor?: CoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coaches.
     */
    distinct?: CoachScalarFieldEnum | CoachScalarFieldEnum[]
  }

  /**
   * Coach findFirstOrThrow
   */
  export type CoachFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter, which Coach to fetch.
     */
    where?: CoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coaches to fetch.
     */
    orderBy?: CoachOrderByWithRelationInput | CoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coaches.
     */
    cursor?: CoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coaches.
     */
    distinct?: CoachScalarFieldEnum | CoachScalarFieldEnum[]
  }

  /**
   * Coach findMany
   */
  export type CoachFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter, which Coaches to fetch.
     */
    where?: CoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coaches to fetch.
     */
    orderBy?: CoachOrderByWithRelationInput | CoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coaches.
     */
    cursor?: CoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coaches.
     */
    skip?: number
    distinct?: CoachScalarFieldEnum | CoachScalarFieldEnum[]
  }

  /**
   * Coach create
   */
  export type CoachCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * The data needed to create a Coach.
     */
    data: XOR<CoachCreateInput, CoachUncheckedCreateInput>
  }

  /**
   * Coach createMany
   */
  export type CoachCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coaches.
     */
    data: CoachCreateManyInput | CoachCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coach createManyAndReturn
   */
  export type CoachCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Coaches.
     */
    data: CoachCreateManyInput | CoachCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coach update
   */
  export type CoachUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * The data needed to update a Coach.
     */
    data: XOR<CoachUpdateInput, CoachUncheckedUpdateInput>
    /**
     * Choose, which Coach to update.
     */
    where: CoachWhereUniqueInput
  }

  /**
   * Coach updateMany
   */
  export type CoachUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coaches.
     */
    data: XOR<CoachUpdateManyMutationInput, CoachUncheckedUpdateManyInput>
    /**
     * Filter which Coaches to update
     */
    where?: CoachWhereInput
  }

  /**
   * Coach upsert
   */
  export type CoachUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * The filter to search for the Coach to update in case it exists.
     */
    where: CoachWhereUniqueInput
    /**
     * In case the Coach found by the `where` argument doesn't exist, create a new Coach with this data.
     */
    create: XOR<CoachCreateInput, CoachUncheckedCreateInput>
    /**
     * In case the Coach was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachUpdateInput, CoachUncheckedUpdateInput>
  }

  /**
   * Coach delete
   */
  export type CoachDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    /**
     * Filter which Coach to delete.
     */
    where: CoachWhereUniqueInput
  }

  /**
   * Coach deleteMany
   */
  export type CoachDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coaches to delete
     */
    where?: CoachWhereInput
  }

  /**
   * Coach.clients
   */
  export type Coach$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Coach.commissions
   */
  export type Coach$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    where?: CommissionWhereInput
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    cursor?: CommissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * Coach.recommendations
   */
  export type Coach$recommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    where?: RecommendationWhereInput
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    cursor?: RecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Coach.sessions
   */
  export type Coach$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Coach.messages
   */
  export type Coach$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    where?: CoachMessageWhereInput
    orderBy?: CoachMessageOrderByWithRelationInput | CoachMessageOrderByWithRelationInput[]
    cursor?: CoachMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachMessageScalarFieldEnum | CoachMessageScalarFieldEnum[]
  }

  /**
   * Coach.certificates
   */
  export type Coach$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
    where?: CoachCertificateWhereInput
    orderBy?: CoachCertificateOrderByWithRelationInput | CoachCertificateOrderByWithRelationInput[]
    cursor?: CoachCertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachCertificateScalarFieldEnum | CoachCertificateScalarFieldEnum[]
  }

  /**
   * Coach.experiences
   */
  export type Coach$experiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
    where?: CoachExperienceWhereInput
    orderBy?: CoachExperienceOrderByWithRelationInput | CoachExperienceOrderByWithRelationInput[]
    cursor?: CoachExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachExperienceScalarFieldEnum | CoachExperienceScalarFieldEnum[]
  }

  /**
   * Coach.achievements
   */
  export type Coach$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
    where?: CoachAchievementWhereInput
    orderBy?: CoachAchievementOrderByWithRelationInput | CoachAchievementOrderByWithRelationInput[]
    cursor?: CoachAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachAchievementScalarFieldEnum | CoachAchievementScalarFieldEnum[]
  }

  /**
   * Coach without action
   */
  export type CoachDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
  }


  /**
   * Model CoachCertificate
   */

  export type AggregateCoachCertificate = {
    _count: CoachCertificateCountAggregateOutputType | null
    _min: CoachCertificateMinAggregateOutputType | null
    _max: CoachCertificateMaxAggregateOutputType | null
  }

  export type CoachCertificateMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    name: string | null
    issuingOrganization: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    certificateUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachCertificateMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    name: string | null
    issuingOrganization: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    certificateUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachCertificateCountAggregateOutputType = {
    id: number
    coachId: number
    name: number
    issuingOrganization: number
    issuedAt: number
    expiresAt: number
    certificateUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoachCertificateMinAggregateInputType = {
    id?: true
    coachId?: true
    name?: true
    issuingOrganization?: true
    issuedAt?: true
    expiresAt?: true
    certificateUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachCertificateMaxAggregateInputType = {
    id?: true
    coachId?: true
    name?: true
    issuingOrganization?: true
    issuedAt?: true
    expiresAt?: true
    certificateUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachCertificateCountAggregateInputType = {
    id?: true
    coachId?: true
    name?: true
    issuingOrganization?: true
    issuedAt?: true
    expiresAt?: true
    certificateUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoachCertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachCertificate to aggregate.
     */
    where?: CoachCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachCertificates to fetch.
     */
    orderBy?: CoachCertificateOrderByWithRelationInput | CoachCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachCertificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachCertificates
    **/
    _count?: true | CoachCertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachCertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachCertificateMaxAggregateInputType
  }

  export type GetCoachCertificateAggregateType<T extends CoachCertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachCertificate[P]>
      : GetScalarType<T[P], AggregateCoachCertificate[P]>
  }




  export type CoachCertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachCertificateWhereInput
    orderBy?: CoachCertificateOrderByWithAggregationInput | CoachCertificateOrderByWithAggregationInput[]
    by: CoachCertificateScalarFieldEnum[] | CoachCertificateScalarFieldEnum
    having?: CoachCertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachCertificateCountAggregateInputType | true
    _min?: CoachCertificateMinAggregateInputType
    _max?: CoachCertificateMaxAggregateInputType
  }

  export type CoachCertificateGroupByOutputType = {
    id: string
    coachId: string
    name: string
    issuingOrganization: string
    issuedAt: Date
    expiresAt: Date | null
    certificateUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: CoachCertificateCountAggregateOutputType | null
    _min: CoachCertificateMinAggregateOutputType | null
    _max: CoachCertificateMaxAggregateOutputType | null
  }

  type GetCoachCertificateGroupByPayload<T extends CoachCertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachCertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachCertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachCertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CoachCertificateGroupByOutputType[P]>
        }
      >
    >


  export type CoachCertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    name?: boolean
    issuingOrganization?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachCertificate"]>

  export type CoachCertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    name?: boolean
    issuingOrganization?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachCertificate"]>

  export type CoachCertificateSelectScalar = {
    id?: boolean
    coachId?: boolean
    name?: boolean
    issuingOrganization?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    certificateUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoachCertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }
  export type CoachCertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }

  export type $CoachCertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachCertificate"
    objects: {
      coach: Prisma.$CoachPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      name: string
      issuingOrganization: string
      issuedAt: Date
      expiresAt: Date | null
      certificateUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coachCertificate"]>
    composites: {}
  }

  type CoachCertificateGetPayload<S extends boolean | null | undefined | CoachCertificateDefaultArgs> = $Result.GetResult<Prisma.$CoachCertificatePayload, S>

  type CoachCertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoachCertificateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoachCertificateCountAggregateInputType | true
    }

  export interface CoachCertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachCertificate'], meta: { name: 'CoachCertificate' } }
    /**
     * Find zero or one CoachCertificate that matches the filter.
     * @param {CoachCertificateFindUniqueArgs} args - Arguments to find a CoachCertificate
     * @example
     * // Get one CoachCertificate
     * const coachCertificate = await prisma.coachCertificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachCertificateFindUniqueArgs>(args: SelectSubset<T, CoachCertificateFindUniqueArgs<ExtArgs>>): Prisma__CoachCertificateClient<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CoachCertificate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoachCertificateFindUniqueOrThrowArgs} args - Arguments to find a CoachCertificate
     * @example
     * // Get one CoachCertificate
     * const coachCertificate = await prisma.coachCertificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachCertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachCertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachCertificateClient<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CoachCertificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachCertificateFindFirstArgs} args - Arguments to find a CoachCertificate
     * @example
     * // Get one CoachCertificate
     * const coachCertificate = await prisma.coachCertificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachCertificateFindFirstArgs>(args?: SelectSubset<T, CoachCertificateFindFirstArgs<ExtArgs>>): Prisma__CoachCertificateClient<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CoachCertificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachCertificateFindFirstOrThrowArgs} args - Arguments to find a CoachCertificate
     * @example
     * // Get one CoachCertificate
     * const coachCertificate = await prisma.coachCertificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachCertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachCertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachCertificateClient<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CoachCertificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachCertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachCertificates
     * const coachCertificates = await prisma.coachCertificate.findMany()
     * 
     * // Get first 10 CoachCertificates
     * const coachCertificates = await prisma.coachCertificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachCertificateWithIdOnly = await prisma.coachCertificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachCertificateFindManyArgs>(args?: SelectSubset<T, CoachCertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CoachCertificate.
     * @param {CoachCertificateCreateArgs} args - Arguments to create a CoachCertificate.
     * @example
     * // Create one CoachCertificate
     * const CoachCertificate = await prisma.coachCertificate.create({
     *   data: {
     *     // ... data to create a CoachCertificate
     *   }
     * })
     * 
     */
    create<T extends CoachCertificateCreateArgs>(args: SelectSubset<T, CoachCertificateCreateArgs<ExtArgs>>): Prisma__CoachCertificateClient<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CoachCertificates.
     * @param {CoachCertificateCreateManyArgs} args - Arguments to create many CoachCertificates.
     * @example
     * // Create many CoachCertificates
     * const coachCertificate = await prisma.coachCertificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachCertificateCreateManyArgs>(args?: SelectSubset<T, CoachCertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachCertificates and returns the data saved in the database.
     * @param {CoachCertificateCreateManyAndReturnArgs} args - Arguments to create many CoachCertificates.
     * @example
     * // Create many CoachCertificates
     * const coachCertificate = await prisma.coachCertificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachCertificates and only return the `id`
     * const coachCertificateWithIdOnly = await prisma.coachCertificate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachCertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachCertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CoachCertificate.
     * @param {CoachCertificateDeleteArgs} args - Arguments to delete one CoachCertificate.
     * @example
     * // Delete one CoachCertificate
     * const CoachCertificate = await prisma.coachCertificate.delete({
     *   where: {
     *     // ... filter to delete one CoachCertificate
     *   }
     * })
     * 
     */
    delete<T extends CoachCertificateDeleteArgs>(args: SelectSubset<T, CoachCertificateDeleteArgs<ExtArgs>>): Prisma__CoachCertificateClient<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CoachCertificate.
     * @param {CoachCertificateUpdateArgs} args - Arguments to update one CoachCertificate.
     * @example
     * // Update one CoachCertificate
     * const coachCertificate = await prisma.coachCertificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachCertificateUpdateArgs>(args: SelectSubset<T, CoachCertificateUpdateArgs<ExtArgs>>): Prisma__CoachCertificateClient<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CoachCertificates.
     * @param {CoachCertificateDeleteManyArgs} args - Arguments to filter CoachCertificates to delete.
     * @example
     * // Delete a few CoachCertificates
     * const { count } = await prisma.coachCertificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachCertificateDeleteManyArgs>(args?: SelectSubset<T, CoachCertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachCertificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachCertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachCertificates
     * const coachCertificate = await prisma.coachCertificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachCertificateUpdateManyArgs>(args: SelectSubset<T, CoachCertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoachCertificate.
     * @param {CoachCertificateUpsertArgs} args - Arguments to update or create a CoachCertificate.
     * @example
     * // Update or create a CoachCertificate
     * const coachCertificate = await prisma.coachCertificate.upsert({
     *   create: {
     *     // ... data to create a CoachCertificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachCertificate we want to update
     *   }
     * })
     */
    upsert<T extends CoachCertificateUpsertArgs>(args: SelectSubset<T, CoachCertificateUpsertArgs<ExtArgs>>): Prisma__CoachCertificateClient<$Result.GetResult<Prisma.$CoachCertificatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CoachCertificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachCertificateCountArgs} args - Arguments to filter CoachCertificates to count.
     * @example
     * // Count the number of CoachCertificates
     * const count = await prisma.coachCertificate.count({
     *   where: {
     *     // ... the filter for the CoachCertificates we want to count
     *   }
     * })
    **/
    count<T extends CoachCertificateCountArgs>(
      args?: Subset<T, CoachCertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachCertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachCertificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachCertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachCertificateAggregateArgs>(args: Subset<T, CoachCertificateAggregateArgs>): Prisma.PrismaPromise<GetCoachCertificateAggregateType<T>>

    /**
     * Group by CoachCertificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachCertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachCertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachCertificateGroupByArgs['orderBy'] }
        : { orderBy?: CoachCertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachCertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachCertificate model
   */
  readonly fields: CoachCertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachCertificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachCertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachDefaultArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachCertificate model
   */ 
  interface CoachCertificateFieldRefs {
    readonly id: FieldRef<"CoachCertificate", 'String'>
    readonly coachId: FieldRef<"CoachCertificate", 'String'>
    readonly name: FieldRef<"CoachCertificate", 'String'>
    readonly issuingOrganization: FieldRef<"CoachCertificate", 'String'>
    readonly issuedAt: FieldRef<"CoachCertificate", 'DateTime'>
    readonly expiresAt: FieldRef<"CoachCertificate", 'DateTime'>
    readonly certificateUrl: FieldRef<"CoachCertificate", 'String'>
    readonly createdAt: FieldRef<"CoachCertificate", 'DateTime'>
    readonly updatedAt: FieldRef<"CoachCertificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachCertificate findUnique
   */
  export type CoachCertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
    /**
     * Filter, which CoachCertificate to fetch.
     */
    where: CoachCertificateWhereUniqueInput
  }

  /**
   * CoachCertificate findUniqueOrThrow
   */
  export type CoachCertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
    /**
     * Filter, which CoachCertificate to fetch.
     */
    where: CoachCertificateWhereUniqueInput
  }

  /**
   * CoachCertificate findFirst
   */
  export type CoachCertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
    /**
     * Filter, which CoachCertificate to fetch.
     */
    where?: CoachCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachCertificates to fetch.
     */
    orderBy?: CoachCertificateOrderByWithRelationInput | CoachCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachCertificates.
     */
    cursor?: CoachCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachCertificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachCertificates.
     */
    distinct?: CoachCertificateScalarFieldEnum | CoachCertificateScalarFieldEnum[]
  }

  /**
   * CoachCertificate findFirstOrThrow
   */
  export type CoachCertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
    /**
     * Filter, which CoachCertificate to fetch.
     */
    where?: CoachCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachCertificates to fetch.
     */
    orderBy?: CoachCertificateOrderByWithRelationInput | CoachCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachCertificates.
     */
    cursor?: CoachCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachCertificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachCertificates.
     */
    distinct?: CoachCertificateScalarFieldEnum | CoachCertificateScalarFieldEnum[]
  }

  /**
   * CoachCertificate findMany
   */
  export type CoachCertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
    /**
     * Filter, which CoachCertificates to fetch.
     */
    where?: CoachCertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachCertificates to fetch.
     */
    orderBy?: CoachCertificateOrderByWithRelationInput | CoachCertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachCertificates.
     */
    cursor?: CoachCertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachCertificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachCertificates.
     */
    skip?: number
    distinct?: CoachCertificateScalarFieldEnum | CoachCertificateScalarFieldEnum[]
  }

  /**
   * CoachCertificate create
   */
  export type CoachCertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachCertificate.
     */
    data: XOR<CoachCertificateCreateInput, CoachCertificateUncheckedCreateInput>
  }

  /**
   * CoachCertificate createMany
   */
  export type CoachCertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachCertificates.
     */
    data: CoachCertificateCreateManyInput | CoachCertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoachCertificate createManyAndReturn
   */
  export type CoachCertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CoachCertificates.
     */
    data: CoachCertificateCreateManyInput | CoachCertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachCertificate update
   */
  export type CoachCertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachCertificate.
     */
    data: XOR<CoachCertificateUpdateInput, CoachCertificateUncheckedUpdateInput>
    /**
     * Choose, which CoachCertificate to update.
     */
    where: CoachCertificateWhereUniqueInput
  }

  /**
   * CoachCertificate updateMany
   */
  export type CoachCertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachCertificates.
     */
    data: XOR<CoachCertificateUpdateManyMutationInput, CoachCertificateUncheckedUpdateManyInput>
    /**
     * Filter which CoachCertificates to update
     */
    where?: CoachCertificateWhereInput
  }

  /**
   * CoachCertificate upsert
   */
  export type CoachCertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachCertificate to update in case it exists.
     */
    where: CoachCertificateWhereUniqueInput
    /**
     * In case the CoachCertificate found by the `where` argument doesn't exist, create a new CoachCertificate with this data.
     */
    create: XOR<CoachCertificateCreateInput, CoachCertificateUncheckedCreateInput>
    /**
     * In case the CoachCertificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachCertificateUpdateInput, CoachCertificateUncheckedUpdateInput>
  }

  /**
   * CoachCertificate delete
   */
  export type CoachCertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
    /**
     * Filter which CoachCertificate to delete.
     */
    where: CoachCertificateWhereUniqueInput
  }

  /**
   * CoachCertificate deleteMany
   */
  export type CoachCertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachCertificates to delete
     */
    where?: CoachCertificateWhereInput
  }

  /**
   * CoachCertificate without action
   */
  export type CoachCertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachCertificate
     */
    select?: CoachCertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachCertificateInclude<ExtArgs> | null
  }


  /**
   * Model CoachExperience
   */

  export type AggregateCoachExperience = {
    _count: CoachExperienceCountAggregateOutputType | null
    _min: CoachExperienceMinAggregateOutputType | null
    _max: CoachExperienceMaxAggregateOutputType | null
  }

  export type CoachExperienceMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    title: string | null
    organization: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachExperienceMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    title: string | null
    organization: string | null
    startDate: Date | null
    endDate: Date | null
    isCurrent: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachExperienceCountAggregateOutputType = {
    id: number
    coachId: number
    title: number
    organization: number
    startDate: number
    endDate: number
    isCurrent: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoachExperienceMinAggregateInputType = {
    id?: true
    coachId?: true
    title?: true
    organization?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachExperienceMaxAggregateInputType = {
    id?: true
    coachId?: true
    title?: true
    organization?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachExperienceCountAggregateInputType = {
    id?: true
    coachId?: true
    title?: true
    organization?: true
    startDate?: true
    endDate?: true
    isCurrent?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoachExperienceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachExperience to aggregate.
     */
    where?: CoachExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachExperiences to fetch.
     */
    orderBy?: CoachExperienceOrderByWithRelationInput | CoachExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachExperiences
    **/
    _count?: true | CoachExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachExperienceMaxAggregateInputType
  }

  export type GetCoachExperienceAggregateType<T extends CoachExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachExperience[P]>
      : GetScalarType<T[P], AggregateCoachExperience[P]>
  }




  export type CoachExperienceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachExperienceWhereInput
    orderBy?: CoachExperienceOrderByWithAggregationInput | CoachExperienceOrderByWithAggregationInput[]
    by: CoachExperienceScalarFieldEnum[] | CoachExperienceScalarFieldEnum
    having?: CoachExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachExperienceCountAggregateInputType | true
    _min?: CoachExperienceMinAggregateInputType
    _max?: CoachExperienceMaxAggregateInputType
  }

  export type CoachExperienceGroupByOutputType = {
    id: string
    coachId: string
    title: string
    organization: string
    startDate: Date
    endDate: Date | null
    isCurrent: boolean
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CoachExperienceCountAggregateOutputType | null
    _min: CoachExperienceMinAggregateOutputType | null
    _max: CoachExperienceMaxAggregateOutputType | null
  }

  type GetCoachExperienceGroupByPayload<T extends CoachExperienceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], CoachExperienceGroupByOutputType[P]>
        }
      >
    >


  export type CoachExperienceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    title?: boolean
    organization?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachExperience"]>

  export type CoachExperienceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    title?: boolean
    organization?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachExperience"]>

  export type CoachExperienceSelectScalar = {
    id?: boolean
    coachId?: boolean
    title?: boolean
    organization?: boolean
    startDate?: boolean
    endDate?: boolean
    isCurrent?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoachExperienceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }
  export type CoachExperienceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }

  export type $CoachExperiencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachExperience"
    objects: {
      coach: Prisma.$CoachPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      title: string
      organization: string
      startDate: Date
      endDate: Date | null
      isCurrent: boolean
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coachExperience"]>
    composites: {}
  }

  type CoachExperienceGetPayload<S extends boolean | null | undefined | CoachExperienceDefaultArgs> = $Result.GetResult<Prisma.$CoachExperiencePayload, S>

  type CoachExperienceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoachExperienceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoachExperienceCountAggregateInputType | true
    }

  export interface CoachExperienceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachExperience'], meta: { name: 'CoachExperience' } }
    /**
     * Find zero or one CoachExperience that matches the filter.
     * @param {CoachExperienceFindUniqueArgs} args - Arguments to find a CoachExperience
     * @example
     * // Get one CoachExperience
     * const coachExperience = await prisma.coachExperience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachExperienceFindUniqueArgs>(args: SelectSubset<T, CoachExperienceFindUniqueArgs<ExtArgs>>): Prisma__CoachExperienceClient<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CoachExperience that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoachExperienceFindUniqueOrThrowArgs} args - Arguments to find a CoachExperience
     * @example
     * // Get one CoachExperience
     * const coachExperience = await prisma.coachExperience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachExperienceFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachExperienceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachExperienceClient<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CoachExperience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachExperienceFindFirstArgs} args - Arguments to find a CoachExperience
     * @example
     * // Get one CoachExperience
     * const coachExperience = await prisma.coachExperience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachExperienceFindFirstArgs>(args?: SelectSubset<T, CoachExperienceFindFirstArgs<ExtArgs>>): Prisma__CoachExperienceClient<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CoachExperience that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachExperienceFindFirstOrThrowArgs} args - Arguments to find a CoachExperience
     * @example
     * // Get one CoachExperience
     * const coachExperience = await prisma.coachExperience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachExperienceFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachExperienceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachExperienceClient<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CoachExperiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachExperienceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachExperiences
     * const coachExperiences = await prisma.coachExperience.findMany()
     * 
     * // Get first 10 CoachExperiences
     * const coachExperiences = await prisma.coachExperience.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachExperienceWithIdOnly = await prisma.coachExperience.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachExperienceFindManyArgs>(args?: SelectSubset<T, CoachExperienceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CoachExperience.
     * @param {CoachExperienceCreateArgs} args - Arguments to create a CoachExperience.
     * @example
     * // Create one CoachExperience
     * const CoachExperience = await prisma.coachExperience.create({
     *   data: {
     *     // ... data to create a CoachExperience
     *   }
     * })
     * 
     */
    create<T extends CoachExperienceCreateArgs>(args: SelectSubset<T, CoachExperienceCreateArgs<ExtArgs>>): Prisma__CoachExperienceClient<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CoachExperiences.
     * @param {CoachExperienceCreateManyArgs} args - Arguments to create many CoachExperiences.
     * @example
     * // Create many CoachExperiences
     * const coachExperience = await prisma.coachExperience.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachExperienceCreateManyArgs>(args?: SelectSubset<T, CoachExperienceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachExperiences and returns the data saved in the database.
     * @param {CoachExperienceCreateManyAndReturnArgs} args - Arguments to create many CoachExperiences.
     * @example
     * // Create many CoachExperiences
     * const coachExperience = await prisma.coachExperience.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachExperiences and only return the `id`
     * const coachExperienceWithIdOnly = await prisma.coachExperience.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachExperienceCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachExperienceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CoachExperience.
     * @param {CoachExperienceDeleteArgs} args - Arguments to delete one CoachExperience.
     * @example
     * // Delete one CoachExperience
     * const CoachExperience = await prisma.coachExperience.delete({
     *   where: {
     *     // ... filter to delete one CoachExperience
     *   }
     * })
     * 
     */
    delete<T extends CoachExperienceDeleteArgs>(args: SelectSubset<T, CoachExperienceDeleteArgs<ExtArgs>>): Prisma__CoachExperienceClient<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CoachExperience.
     * @param {CoachExperienceUpdateArgs} args - Arguments to update one CoachExperience.
     * @example
     * // Update one CoachExperience
     * const coachExperience = await prisma.coachExperience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachExperienceUpdateArgs>(args: SelectSubset<T, CoachExperienceUpdateArgs<ExtArgs>>): Prisma__CoachExperienceClient<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CoachExperiences.
     * @param {CoachExperienceDeleteManyArgs} args - Arguments to filter CoachExperiences to delete.
     * @example
     * // Delete a few CoachExperiences
     * const { count } = await prisma.coachExperience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachExperienceDeleteManyArgs>(args?: SelectSubset<T, CoachExperienceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachExperiences
     * const coachExperience = await prisma.coachExperience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachExperienceUpdateManyArgs>(args: SelectSubset<T, CoachExperienceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoachExperience.
     * @param {CoachExperienceUpsertArgs} args - Arguments to update or create a CoachExperience.
     * @example
     * // Update or create a CoachExperience
     * const coachExperience = await prisma.coachExperience.upsert({
     *   create: {
     *     // ... data to create a CoachExperience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachExperience we want to update
     *   }
     * })
     */
    upsert<T extends CoachExperienceUpsertArgs>(args: SelectSubset<T, CoachExperienceUpsertArgs<ExtArgs>>): Prisma__CoachExperienceClient<$Result.GetResult<Prisma.$CoachExperiencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CoachExperiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachExperienceCountArgs} args - Arguments to filter CoachExperiences to count.
     * @example
     * // Count the number of CoachExperiences
     * const count = await prisma.coachExperience.count({
     *   where: {
     *     // ... the filter for the CoachExperiences we want to count
     *   }
     * })
    **/
    count<T extends CoachExperienceCountArgs>(
      args?: Subset<T, CoachExperienceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachExperienceAggregateArgs>(args: Subset<T, CoachExperienceAggregateArgs>): Prisma.PrismaPromise<GetCoachExperienceAggregateType<T>>

    /**
     * Group by CoachExperience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachExperienceGroupByArgs['orderBy'] }
        : { orderBy?: CoachExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachExperienceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachExperience model
   */
  readonly fields: CoachExperienceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachExperience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachExperienceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachDefaultArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachExperience model
   */ 
  interface CoachExperienceFieldRefs {
    readonly id: FieldRef<"CoachExperience", 'String'>
    readonly coachId: FieldRef<"CoachExperience", 'String'>
    readonly title: FieldRef<"CoachExperience", 'String'>
    readonly organization: FieldRef<"CoachExperience", 'String'>
    readonly startDate: FieldRef<"CoachExperience", 'DateTime'>
    readonly endDate: FieldRef<"CoachExperience", 'DateTime'>
    readonly isCurrent: FieldRef<"CoachExperience", 'Boolean'>
    readonly description: FieldRef<"CoachExperience", 'String'>
    readonly createdAt: FieldRef<"CoachExperience", 'DateTime'>
    readonly updatedAt: FieldRef<"CoachExperience", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachExperience findUnique
   */
  export type CoachExperienceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
    /**
     * Filter, which CoachExperience to fetch.
     */
    where: CoachExperienceWhereUniqueInput
  }

  /**
   * CoachExperience findUniqueOrThrow
   */
  export type CoachExperienceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
    /**
     * Filter, which CoachExperience to fetch.
     */
    where: CoachExperienceWhereUniqueInput
  }

  /**
   * CoachExperience findFirst
   */
  export type CoachExperienceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
    /**
     * Filter, which CoachExperience to fetch.
     */
    where?: CoachExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachExperiences to fetch.
     */
    orderBy?: CoachExperienceOrderByWithRelationInput | CoachExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachExperiences.
     */
    cursor?: CoachExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachExperiences.
     */
    distinct?: CoachExperienceScalarFieldEnum | CoachExperienceScalarFieldEnum[]
  }

  /**
   * CoachExperience findFirstOrThrow
   */
  export type CoachExperienceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
    /**
     * Filter, which CoachExperience to fetch.
     */
    where?: CoachExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachExperiences to fetch.
     */
    orderBy?: CoachExperienceOrderByWithRelationInput | CoachExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachExperiences.
     */
    cursor?: CoachExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachExperiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachExperiences.
     */
    distinct?: CoachExperienceScalarFieldEnum | CoachExperienceScalarFieldEnum[]
  }

  /**
   * CoachExperience findMany
   */
  export type CoachExperienceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
    /**
     * Filter, which CoachExperiences to fetch.
     */
    where?: CoachExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachExperiences to fetch.
     */
    orderBy?: CoachExperienceOrderByWithRelationInput | CoachExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachExperiences.
     */
    cursor?: CoachExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachExperiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachExperiences.
     */
    skip?: number
    distinct?: CoachExperienceScalarFieldEnum | CoachExperienceScalarFieldEnum[]
  }

  /**
   * CoachExperience create
   */
  export type CoachExperienceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachExperience.
     */
    data: XOR<CoachExperienceCreateInput, CoachExperienceUncheckedCreateInput>
  }

  /**
   * CoachExperience createMany
   */
  export type CoachExperienceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachExperiences.
     */
    data: CoachExperienceCreateManyInput | CoachExperienceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoachExperience createManyAndReturn
   */
  export type CoachExperienceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CoachExperiences.
     */
    data: CoachExperienceCreateManyInput | CoachExperienceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachExperience update
   */
  export type CoachExperienceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachExperience.
     */
    data: XOR<CoachExperienceUpdateInput, CoachExperienceUncheckedUpdateInput>
    /**
     * Choose, which CoachExperience to update.
     */
    where: CoachExperienceWhereUniqueInput
  }

  /**
   * CoachExperience updateMany
   */
  export type CoachExperienceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachExperiences.
     */
    data: XOR<CoachExperienceUpdateManyMutationInput, CoachExperienceUncheckedUpdateManyInput>
    /**
     * Filter which CoachExperiences to update
     */
    where?: CoachExperienceWhereInput
  }

  /**
   * CoachExperience upsert
   */
  export type CoachExperienceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachExperience to update in case it exists.
     */
    where: CoachExperienceWhereUniqueInput
    /**
     * In case the CoachExperience found by the `where` argument doesn't exist, create a new CoachExperience with this data.
     */
    create: XOR<CoachExperienceCreateInput, CoachExperienceUncheckedCreateInput>
    /**
     * In case the CoachExperience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachExperienceUpdateInput, CoachExperienceUncheckedUpdateInput>
  }

  /**
   * CoachExperience delete
   */
  export type CoachExperienceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
    /**
     * Filter which CoachExperience to delete.
     */
    where: CoachExperienceWhereUniqueInput
  }

  /**
   * CoachExperience deleteMany
   */
  export type CoachExperienceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachExperiences to delete
     */
    where?: CoachExperienceWhereInput
  }

  /**
   * CoachExperience without action
   */
  export type CoachExperienceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachExperience
     */
    select?: CoachExperienceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachExperienceInclude<ExtArgs> | null
  }


  /**
   * Model CoachAchievement
   */

  export type AggregateCoachAchievement = {
    _count: CoachAchievementCountAggregateOutputType | null
    _min: CoachAchievementMinAggregateOutputType | null
    _max: CoachAchievementMaxAggregateOutputType | null
  }

  export type CoachAchievementMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    title: string | null
    description: string | null
    achievedAt: Date | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachAchievementMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    title: string | null
    description: string | null
    achievedAt: Date | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachAchievementCountAggregateOutputType = {
    id: number
    coachId: number
    title: number
    description: number
    achievedAt: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoachAchievementMinAggregateInputType = {
    id?: true
    coachId?: true
    title?: true
    description?: true
    achievedAt?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachAchievementMaxAggregateInputType = {
    id?: true
    coachId?: true
    title?: true
    description?: true
    achievedAt?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachAchievementCountAggregateInputType = {
    id?: true
    coachId?: true
    title?: true
    description?: true
    achievedAt?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoachAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachAchievement to aggregate.
     */
    where?: CoachAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachAchievements to fetch.
     */
    orderBy?: CoachAchievementOrderByWithRelationInput | CoachAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachAchievements
    **/
    _count?: true | CoachAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachAchievementMaxAggregateInputType
  }

  export type GetCoachAchievementAggregateType<T extends CoachAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachAchievement[P]>
      : GetScalarType<T[P], AggregateCoachAchievement[P]>
  }




  export type CoachAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachAchievementWhereInput
    orderBy?: CoachAchievementOrderByWithAggregationInput | CoachAchievementOrderByWithAggregationInput[]
    by: CoachAchievementScalarFieldEnum[] | CoachAchievementScalarFieldEnum
    having?: CoachAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachAchievementCountAggregateInputType | true
    _min?: CoachAchievementMinAggregateInputType
    _max?: CoachAchievementMaxAggregateInputType
  }

  export type CoachAchievementGroupByOutputType = {
    id: string
    coachId: string
    title: string
    description: string | null
    achievedAt: Date
    type: string
    createdAt: Date
    updatedAt: Date
    _count: CoachAchievementCountAggregateOutputType | null
    _min: CoachAchievementMinAggregateOutputType | null
    _max: CoachAchievementMaxAggregateOutputType | null
  }

  type GetCoachAchievementGroupByPayload<T extends CoachAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], CoachAchievementGroupByOutputType[P]>
        }
      >
    >


  export type CoachAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    title?: boolean
    description?: boolean
    achievedAt?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachAchievement"]>

  export type CoachAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    title?: boolean
    description?: boolean
    achievedAt?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachAchievement"]>

  export type CoachAchievementSelectScalar = {
    id?: boolean
    coachId?: boolean
    title?: boolean
    description?: boolean
    achievedAt?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoachAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }
  export type CoachAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachDefaultArgs<ExtArgs>
  }

  export type $CoachAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachAchievement"
    objects: {
      coach: Prisma.$CoachPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      title: string
      description: string | null
      achievedAt: Date
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coachAchievement"]>
    composites: {}
  }

  type CoachAchievementGetPayload<S extends boolean | null | undefined | CoachAchievementDefaultArgs> = $Result.GetResult<Prisma.$CoachAchievementPayload, S>

  type CoachAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoachAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoachAchievementCountAggregateInputType | true
    }

  export interface CoachAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachAchievement'], meta: { name: 'CoachAchievement' } }
    /**
     * Find zero or one CoachAchievement that matches the filter.
     * @param {CoachAchievementFindUniqueArgs} args - Arguments to find a CoachAchievement
     * @example
     * // Get one CoachAchievement
     * const coachAchievement = await prisma.coachAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachAchievementFindUniqueArgs>(args: SelectSubset<T, CoachAchievementFindUniqueArgs<ExtArgs>>): Prisma__CoachAchievementClient<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CoachAchievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoachAchievementFindUniqueOrThrowArgs} args - Arguments to find a CoachAchievement
     * @example
     * // Get one CoachAchievement
     * const coachAchievement = await prisma.coachAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachAchievementClient<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CoachAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAchievementFindFirstArgs} args - Arguments to find a CoachAchievement
     * @example
     * // Get one CoachAchievement
     * const coachAchievement = await prisma.coachAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachAchievementFindFirstArgs>(args?: SelectSubset<T, CoachAchievementFindFirstArgs<ExtArgs>>): Prisma__CoachAchievementClient<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CoachAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAchievementFindFirstOrThrowArgs} args - Arguments to find a CoachAchievement
     * @example
     * // Get one CoachAchievement
     * const coachAchievement = await prisma.coachAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachAchievementClient<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CoachAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachAchievements
     * const coachAchievements = await prisma.coachAchievement.findMany()
     * 
     * // Get first 10 CoachAchievements
     * const coachAchievements = await prisma.coachAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachAchievementWithIdOnly = await prisma.coachAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachAchievementFindManyArgs>(args?: SelectSubset<T, CoachAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CoachAchievement.
     * @param {CoachAchievementCreateArgs} args - Arguments to create a CoachAchievement.
     * @example
     * // Create one CoachAchievement
     * const CoachAchievement = await prisma.coachAchievement.create({
     *   data: {
     *     // ... data to create a CoachAchievement
     *   }
     * })
     * 
     */
    create<T extends CoachAchievementCreateArgs>(args: SelectSubset<T, CoachAchievementCreateArgs<ExtArgs>>): Prisma__CoachAchievementClient<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CoachAchievements.
     * @param {CoachAchievementCreateManyArgs} args - Arguments to create many CoachAchievements.
     * @example
     * // Create many CoachAchievements
     * const coachAchievement = await prisma.coachAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachAchievementCreateManyArgs>(args?: SelectSubset<T, CoachAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachAchievements and returns the data saved in the database.
     * @param {CoachAchievementCreateManyAndReturnArgs} args - Arguments to create many CoachAchievements.
     * @example
     * // Create many CoachAchievements
     * const coachAchievement = await prisma.coachAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachAchievements and only return the `id`
     * const coachAchievementWithIdOnly = await prisma.coachAchievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CoachAchievement.
     * @param {CoachAchievementDeleteArgs} args - Arguments to delete one CoachAchievement.
     * @example
     * // Delete one CoachAchievement
     * const CoachAchievement = await prisma.coachAchievement.delete({
     *   where: {
     *     // ... filter to delete one CoachAchievement
     *   }
     * })
     * 
     */
    delete<T extends CoachAchievementDeleteArgs>(args: SelectSubset<T, CoachAchievementDeleteArgs<ExtArgs>>): Prisma__CoachAchievementClient<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CoachAchievement.
     * @param {CoachAchievementUpdateArgs} args - Arguments to update one CoachAchievement.
     * @example
     * // Update one CoachAchievement
     * const coachAchievement = await prisma.coachAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachAchievementUpdateArgs>(args: SelectSubset<T, CoachAchievementUpdateArgs<ExtArgs>>): Prisma__CoachAchievementClient<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CoachAchievements.
     * @param {CoachAchievementDeleteManyArgs} args - Arguments to filter CoachAchievements to delete.
     * @example
     * // Delete a few CoachAchievements
     * const { count } = await prisma.coachAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachAchievementDeleteManyArgs>(args?: SelectSubset<T, CoachAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachAchievements
     * const coachAchievement = await prisma.coachAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachAchievementUpdateManyArgs>(args: SelectSubset<T, CoachAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoachAchievement.
     * @param {CoachAchievementUpsertArgs} args - Arguments to update or create a CoachAchievement.
     * @example
     * // Update or create a CoachAchievement
     * const coachAchievement = await prisma.coachAchievement.upsert({
     *   create: {
     *     // ... data to create a CoachAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachAchievement we want to update
     *   }
     * })
     */
    upsert<T extends CoachAchievementUpsertArgs>(args: SelectSubset<T, CoachAchievementUpsertArgs<ExtArgs>>): Prisma__CoachAchievementClient<$Result.GetResult<Prisma.$CoachAchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CoachAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAchievementCountArgs} args - Arguments to filter CoachAchievements to count.
     * @example
     * // Count the number of CoachAchievements
     * const count = await prisma.coachAchievement.count({
     *   where: {
     *     // ... the filter for the CoachAchievements we want to count
     *   }
     * })
    **/
    count<T extends CoachAchievementCountArgs>(
      args?: Subset<T, CoachAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachAchievementAggregateArgs>(args: Subset<T, CoachAchievementAggregateArgs>): Prisma.PrismaPromise<GetCoachAchievementAggregateType<T>>

    /**
     * Group by CoachAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachAchievementGroupByArgs['orderBy'] }
        : { orderBy?: CoachAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachAchievement model
   */
  readonly fields: CoachAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachDefaultArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachAchievement model
   */ 
  interface CoachAchievementFieldRefs {
    readonly id: FieldRef<"CoachAchievement", 'String'>
    readonly coachId: FieldRef<"CoachAchievement", 'String'>
    readonly title: FieldRef<"CoachAchievement", 'String'>
    readonly description: FieldRef<"CoachAchievement", 'String'>
    readonly achievedAt: FieldRef<"CoachAchievement", 'DateTime'>
    readonly type: FieldRef<"CoachAchievement", 'String'>
    readonly createdAt: FieldRef<"CoachAchievement", 'DateTime'>
    readonly updatedAt: FieldRef<"CoachAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachAchievement findUnique
   */
  export type CoachAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
    /**
     * Filter, which CoachAchievement to fetch.
     */
    where: CoachAchievementWhereUniqueInput
  }

  /**
   * CoachAchievement findUniqueOrThrow
   */
  export type CoachAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
    /**
     * Filter, which CoachAchievement to fetch.
     */
    where: CoachAchievementWhereUniqueInput
  }

  /**
   * CoachAchievement findFirst
   */
  export type CoachAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
    /**
     * Filter, which CoachAchievement to fetch.
     */
    where?: CoachAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachAchievements to fetch.
     */
    orderBy?: CoachAchievementOrderByWithRelationInput | CoachAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachAchievements.
     */
    cursor?: CoachAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachAchievements.
     */
    distinct?: CoachAchievementScalarFieldEnum | CoachAchievementScalarFieldEnum[]
  }

  /**
   * CoachAchievement findFirstOrThrow
   */
  export type CoachAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
    /**
     * Filter, which CoachAchievement to fetch.
     */
    where?: CoachAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachAchievements to fetch.
     */
    orderBy?: CoachAchievementOrderByWithRelationInput | CoachAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachAchievements.
     */
    cursor?: CoachAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachAchievements.
     */
    distinct?: CoachAchievementScalarFieldEnum | CoachAchievementScalarFieldEnum[]
  }

  /**
   * CoachAchievement findMany
   */
  export type CoachAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
    /**
     * Filter, which CoachAchievements to fetch.
     */
    where?: CoachAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachAchievements to fetch.
     */
    orderBy?: CoachAchievementOrderByWithRelationInput | CoachAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachAchievements.
     */
    cursor?: CoachAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachAchievements.
     */
    skip?: number
    distinct?: CoachAchievementScalarFieldEnum | CoachAchievementScalarFieldEnum[]
  }

  /**
   * CoachAchievement create
   */
  export type CoachAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachAchievement.
     */
    data: XOR<CoachAchievementCreateInput, CoachAchievementUncheckedCreateInput>
  }

  /**
   * CoachAchievement createMany
   */
  export type CoachAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachAchievements.
     */
    data: CoachAchievementCreateManyInput | CoachAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoachAchievement createManyAndReturn
   */
  export type CoachAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CoachAchievements.
     */
    data: CoachAchievementCreateManyInput | CoachAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachAchievement update
   */
  export type CoachAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachAchievement.
     */
    data: XOR<CoachAchievementUpdateInput, CoachAchievementUncheckedUpdateInput>
    /**
     * Choose, which CoachAchievement to update.
     */
    where: CoachAchievementWhereUniqueInput
  }

  /**
   * CoachAchievement updateMany
   */
  export type CoachAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachAchievements.
     */
    data: XOR<CoachAchievementUpdateManyMutationInput, CoachAchievementUncheckedUpdateManyInput>
    /**
     * Filter which CoachAchievements to update
     */
    where?: CoachAchievementWhereInput
  }

  /**
   * CoachAchievement upsert
   */
  export type CoachAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachAchievement to update in case it exists.
     */
    where: CoachAchievementWhereUniqueInput
    /**
     * In case the CoachAchievement found by the `where` argument doesn't exist, create a new CoachAchievement with this data.
     */
    create: XOR<CoachAchievementCreateInput, CoachAchievementUncheckedCreateInput>
    /**
     * In case the CoachAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachAchievementUpdateInput, CoachAchievementUncheckedUpdateInput>
  }

  /**
   * CoachAchievement delete
   */
  export type CoachAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
    /**
     * Filter which CoachAchievement to delete.
     */
    where: CoachAchievementWhereUniqueInput
  }

  /**
   * CoachAchievement deleteMany
   */
  export type CoachAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachAchievements to delete
     */
    where?: CoachAchievementWhereInput
  }

  /**
   * CoachAchievement without action
   */
  export type CoachAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachAchievement
     */
    select?: CoachAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachAchievementInclude<ExtArgs> | null
  }


  /**
   * Model WorkoutLog
   */

  export type AggregateWorkoutLog = {
    _count: WorkoutLogCountAggregateOutputType | null
    _avg: WorkoutLogAvgAggregateOutputType | null
    _sum: WorkoutLogSumAggregateOutputType | null
    _min: WorkoutLogMinAggregateOutputType | null
    _max: WorkoutLogMaxAggregateOutputType | null
  }

  export type WorkoutLogAvgAggregateOutputType = {
    duration: number | null
  }

  export type WorkoutLogSumAggregateOutputType = {
    duration: number | null
  }

  export type WorkoutLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    activity: string | null
    duration: number | null
    notes: string | null
  }

  export type WorkoutLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    activity: string | null
    duration: number | null
    notes: string | null
  }

  export type WorkoutLogCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    activity: number
    duration: number
    notes: number
    _all: number
  }


  export type WorkoutLogAvgAggregateInputType = {
    duration?: true
  }

  export type WorkoutLogSumAggregateInputType = {
    duration?: true
  }

  export type WorkoutLogMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    activity?: true
    duration?: true
    notes?: true
  }

  export type WorkoutLogMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    activity?: true
    duration?: true
    notes?: true
  }

  export type WorkoutLogCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    activity?: true
    duration?: true
    notes?: true
    _all?: true
  }

  export type WorkoutLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutLog to aggregate.
     */
    where?: WorkoutLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutLogs to fetch.
     */
    orderBy?: WorkoutLogOrderByWithRelationInput | WorkoutLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutLogs
    **/
    _count?: true | WorkoutLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutLogMaxAggregateInputType
  }

  export type GetWorkoutLogAggregateType<T extends WorkoutLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutLog[P]>
      : GetScalarType<T[P], AggregateWorkoutLog[P]>
  }




  export type WorkoutLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutLogWhereInput
    orderBy?: WorkoutLogOrderByWithAggregationInput | WorkoutLogOrderByWithAggregationInput[]
    by: WorkoutLogScalarFieldEnum[] | WorkoutLogScalarFieldEnum
    having?: WorkoutLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutLogCountAggregateInputType | true
    _avg?: WorkoutLogAvgAggregateInputType
    _sum?: WorkoutLogSumAggregateInputType
    _min?: WorkoutLogMinAggregateInputType
    _max?: WorkoutLogMaxAggregateInputType
  }

  export type WorkoutLogGroupByOutputType = {
    id: string
    userId: string
    date: Date
    activity: string
    duration: number
    notes: string | null
    _count: WorkoutLogCountAggregateOutputType | null
    _avg: WorkoutLogAvgAggregateOutputType | null
    _sum: WorkoutLogSumAggregateOutputType | null
    _min: WorkoutLogMinAggregateOutputType | null
    _max: WorkoutLogMaxAggregateOutputType | null
  }

  type GetWorkoutLogGroupByPayload<T extends WorkoutLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutLogGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutLogGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    activity?: boolean
    duration?: boolean
    notes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutLog"]>

  export type WorkoutLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    activity?: boolean
    duration?: boolean
    notes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workoutLog"]>

  export type WorkoutLogSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    activity?: boolean
    duration?: boolean
    notes?: boolean
  }

  export type WorkoutLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkoutLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkoutLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkoutLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      activity: string
      duration: number
      notes: string | null
    }, ExtArgs["result"]["workoutLog"]>
    composites: {}
  }

  type WorkoutLogGetPayload<S extends boolean | null | undefined | WorkoutLogDefaultArgs> = $Result.GetResult<Prisma.$WorkoutLogPayload, S>

  type WorkoutLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkoutLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkoutLogCountAggregateInputType | true
    }

  export interface WorkoutLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkoutLog'], meta: { name: 'WorkoutLog' } }
    /**
     * Find zero or one WorkoutLog that matches the filter.
     * @param {WorkoutLogFindUniqueArgs} args - Arguments to find a WorkoutLog
     * @example
     * // Get one WorkoutLog
     * const workoutLog = await prisma.workoutLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutLogFindUniqueArgs>(args: SelectSubset<T, WorkoutLogFindUniqueArgs<ExtArgs>>): Prisma__WorkoutLogClient<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkoutLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkoutLogFindUniqueOrThrowArgs} args - Arguments to find a WorkoutLog
     * @example
     * // Get one WorkoutLog
     * const workoutLog = await prisma.workoutLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutLogClient<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkoutLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogFindFirstArgs} args - Arguments to find a WorkoutLog
     * @example
     * // Get one WorkoutLog
     * const workoutLog = await prisma.workoutLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutLogFindFirstArgs>(args?: SelectSubset<T, WorkoutLogFindFirstArgs<ExtArgs>>): Prisma__WorkoutLogClient<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkoutLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogFindFirstOrThrowArgs} args - Arguments to find a WorkoutLog
     * @example
     * // Get one WorkoutLog
     * const workoutLog = await prisma.workoutLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutLogClient<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkoutLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutLogs
     * const workoutLogs = await prisma.workoutLog.findMany()
     * 
     * // Get first 10 WorkoutLogs
     * const workoutLogs = await prisma.workoutLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutLogWithIdOnly = await prisma.workoutLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutLogFindManyArgs>(args?: SelectSubset<T, WorkoutLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkoutLog.
     * @param {WorkoutLogCreateArgs} args - Arguments to create a WorkoutLog.
     * @example
     * // Create one WorkoutLog
     * const WorkoutLog = await prisma.workoutLog.create({
     *   data: {
     *     // ... data to create a WorkoutLog
     *   }
     * })
     * 
     */
    create<T extends WorkoutLogCreateArgs>(args: SelectSubset<T, WorkoutLogCreateArgs<ExtArgs>>): Prisma__WorkoutLogClient<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkoutLogs.
     * @param {WorkoutLogCreateManyArgs} args - Arguments to create many WorkoutLogs.
     * @example
     * // Create many WorkoutLogs
     * const workoutLog = await prisma.workoutLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutLogCreateManyArgs>(args?: SelectSubset<T, WorkoutLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkoutLogs and returns the data saved in the database.
     * @param {WorkoutLogCreateManyAndReturnArgs} args - Arguments to create many WorkoutLogs.
     * @example
     * // Create many WorkoutLogs
     * const workoutLog = await prisma.workoutLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkoutLogs and only return the `id`
     * const workoutLogWithIdOnly = await prisma.workoutLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkoutLog.
     * @param {WorkoutLogDeleteArgs} args - Arguments to delete one WorkoutLog.
     * @example
     * // Delete one WorkoutLog
     * const WorkoutLog = await prisma.workoutLog.delete({
     *   where: {
     *     // ... filter to delete one WorkoutLog
     *   }
     * })
     * 
     */
    delete<T extends WorkoutLogDeleteArgs>(args: SelectSubset<T, WorkoutLogDeleteArgs<ExtArgs>>): Prisma__WorkoutLogClient<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkoutLog.
     * @param {WorkoutLogUpdateArgs} args - Arguments to update one WorkoutLog.
     * @example
     * // Update one WorkoutLog
     * const workoutLog = await prisma.workoutLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutLogUpdateArgs>(args: SelectSubset<T, WorkoutLogUpdateArgs<ExtArgs>>): Prisma__WorkoutLogClient<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkoutLogs.
     * @param {WorkoutLogDeleteManyArgs} args - Arguments to filter WorkoutLogs to delete.
     * @example
     * // Delete a few WorkoutLogs
     * const { count } = await prisma.workoutLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutLogDeleteManyArgs>(args?: SelectSubset<T, WorkoutLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutLogs
     * const workoutLog = await prisma.workoutLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutLogUpdateManyArgs>(args: SelectSubset<T, WorkoutLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutLog.
     * @param {WorkoutLogUpsertArgs} args - Arguments to update or create a WorkoutLog.
     * @example
     * // Update or create a WorkoutLog
     * const workoutLog = await prisma.workoutLog.upsert({
     *   create: {
     *     // ... data to create a WorkoutLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutLog we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutLogUpsertArgs>(args: SelectSubset<T, WorkoutLogUpsertArgs<ExtArgs>>): Prisma__WorkoutLogClient<$Result.GetResult<Prisma.$WorkoutLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkoutLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogCountArgs} args - Arguments to filter WorkoutLogs to count.
     * @example
     * // Count the number of WorkoutLogs
     * const count = await prisma.workoutLog.count({
     *   where: {
     *     // ... the filter for the WorkoutLogs we want to count
     *   }
     * })
    **/
    count<T extends WorkoutLogCountArgs>(
      args?: Subset<T, WorkoutLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutLogAggregateArgs>(args: Subset<T, WorkoutLogAggregateArgs>): Prisma.PrismaPromise<GetWorkoutLogAggregateType<T>>

    /**
     * Group by WorkoutLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutLogGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkoutLog model
   */
  readonly fields: WorkoutLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkoutLog model
   */ 
  interface WorkoutLogFieldRefs {
    readonly id: FieldRef<"WorkoutLog", 'String'>
    readonly userId: FieldRef<"WorkoutLog", 'String'>
    readonly date: FieldRef<"WorkoutLog", 'DateTime'>
    readonly activity: FieldRef<"WorkoutLog", 'String'>
    readonly duration: FieldRef<"WorkoutLog", 'Int'>
    readonly notes: FieldRef<"WorkoutLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkoutLog findUnique
   */
  export type WorkoutLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutLog to fetch.
     */
    where: WorkoutLogWhereUniqueInput
  }

  /**
   * WorkoutLog findUniqueOrThrow
   */
  export type WorkoutLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutLog to fetch.
     */
    where: WorkoutLogWhereUniqueInput
  }

  /**
   * WorkoutLog findFirst
   */
  export type WorkoutLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutLog to fetch.
     */
    where?: WorkoutLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutLogs to fetch.
     */
    orderBy?: WorkoutLogOrderByWithRelationInput | WorkoutLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutLogs.
     */
    cursor?: WorkoutLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutLogs.
     */
    distinct?: WorkoutLogScalarFieldEnum | WorkoutLogScalarFieldEnum[]
  }

  /**
   * WorkoutLog findFirstOrThrow
   */
  export type WorkoutLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutLog to fetch.
     */
    where?: WorkoutLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutLogs to fetch.
     */
    orderBy?: WorkoutLogOrderByWithRelationInput | WorkoutLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutLogs.
     */
    cursor?: WorkoutLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutLogs.
     */
    distinct?: WorkoutLogScalarFieldEnum | WorkoutLogScalarFieldEnum[]
  }

  /**
   * WorkoutLog findMany
   */
  export type WorkoutLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkoutLogs to fetch.
     */
    where?: WorkoutLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutLogs to fetch.
     */
    orderBy?: WorkoutLogOrderByWithRelationInput | WorkoutLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutLogs.
     */
    cursor?: WorkoutLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutLogs.
     */
    skip?: number
    distinct?: WorkoutLogScalarFieldEnum | WorkoutLogScalarFieldEnum[]
  }

  /**
   * WorkoutLog create
   */
  export type WorkoutLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkoutLog.
     */
    data: XOR<WorkoutLogCreateInput, WorkoutLogUncheckedCreateInput>
  }

  /**
   * WorkoutLog createMany
   */
  export type WorkoutLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkoutLogs.
     */
    data: WorkoutLogCreateManyInput | WorkoutLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkoutLog createManyAndReturn
   */
  export type WorkoutLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkoutLogs.
     */
    data: WorkoutLogCreateManyInput | WorkoutLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkoutLog update
   */
  export type WorkoutLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkoutLog.
     */
    data: XOR<WorkoutLogUpdateInput, WorkoutLogUncheckedUpdateInput>
    /**
     * Choose, which WorkoutLog to update.
     */
    where: WorkoutLogWhereUniqueInput
  }

  /**
   * WorkoutLog updateMany
   */
  export type WorkoutLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkoutLogs.
     */
    data: XOR<WorkoutLogUpdateManyMutationInput, WorkoutLogUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutLogs to update
     */
    where?: WorkoutLogWhereInput
  }

  /**
   * WorkoutLog upsert
   */
  export type WorkoutLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkoutLog to update in case it exists.
     */
    where: WorkoutLogWhereUniqueInput
    /**
     * In case the WorkoutLog found by the `where` argument doesn't exist, create a new WorkoutLog with this data.
     */
    create: XOR<WorkoutLogCreateInput, WorkoutLogUncheckedCreateInput>
    /**
     * In case the WorkoutLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutLogUpdateInput, WorkoutLogUncheckedUpdateInput>
  }

  /**
   * WorkoutLog delete
   */
  export type WorkoutLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
    /**
     * Filter which WorkoutLog to delete.
     */
    where: WorkoutLogWhereUniqueInput
  }

  /**
   * WorkoutLog deleteMany
   */
  export type WorkoutLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkoutLogs to delete
     */
    where?: WorkoutLogWhereInput
  }

  /**
   * WorkoutLog without action
   */
  export type WorkoutLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutLogInclude<ExtArgs> | null
  }


  /**
   * Model NutritionLog
   */

  export type AggregateNutritionLog = {
    _count: NutritionLogCountAggregateOutputType | null
    _avg: NutritionLogAvgAggregateOutputType | null
    _sum: NutritionLogSumAggregateOutputType | null
    _min: NutritionLogMinAggregateOutputType | null
    _max: NutritionLogMaxAggregateOutputType | null
  }

  export type NutritionLogAvgAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
  }

  export type NutritionLogSumAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
  }

  export type NutritionLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    meal: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    mealType: string | null
    notes: string | null
  }

  export type NutritionLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    meal: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    mealType: string | null
    notes: string | null
  }

  export type NutritionLogCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    meal: number
    calories: number
    protein: number
    carbs: number
    fats: number
    mealType: number
    notes: number
    _all: number
  }


  export type NutritionLogAvgAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
  }

  export type NutritionLogSumAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
  }

  export type NutritionLogMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    meal?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    mealType?: true
    notes?: true
  }

  export type NutritionLogMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    meal?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    mealType?: true
    notes?: true
  }

  export type NutritionLogCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    meal?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    mealType?: true
    notes?: true
    _all?: true
  }

  export type NutritionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionLog to aggregate.
     */
    where?: NutritionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionLogs to fetch.
     */
    orderBy?: NutritionLogOrderByWithRelationInput | NutritionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutritionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutritionLogs
    **/
    _count?: true | NutritionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NutritionLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NutritionLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionLogMaxAggregateInputType
  }

  export type GetNutritionLogAggregateType<T extends NutritionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionLog[P]>
      : GetScalarType<T[P], AggregateNutritionLog[P]>
  }




  export type NutritionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionLogWhereInput
    orderBy?: NutritionLogOrderByWithAggregationInput | NutritionLogOrderByWithAggregationInput[]
    by: NutritionLogScalarFieldEnum[] | NutritionLogScalarFieldEnum
    having?: NutritionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionLogCountAggregateInputType | true
    _avg?: NutritionLogAvgAggregateInputType
    _sum?: NutritionLogSumAggregateInputType
    _min?: NutritionLogMinAggregateInputType
    _max?: NutritionLogMaxAggregateInputType
  }

  export type NutritionLogGroupByOutputType = {
    id: string
    userId: string
    date: Date
    meal: string
    calories: number
    protein: number | null
    carbs: number | null
    fats: number | null
    mealType: string | null
    notes: string | null
    _count: NutritionLogCountAggregateOutputType | null
    _avg: NutritionLogAvgAggregateOutputType | null
    _sum: NutritionLogSumAggregateOutputType | null
    _min: NutritionLogMinAggregateOutputType | null
    _max: NutritionLogMaxAggregateOutputType | null
  }

  type GetNutritionLogGroupByPayload<T extends NutritionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionLogGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionLogGroupByOutputType[P]>
        }
      >
    >


  export type NutritionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    meal?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    mealType?: boolean
    notes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionLog"]>

  export type NutritionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    meal?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    mealType?: boolean
    notes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionLog"]>

  export type NutritionLogSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    meal?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    mealType?: boolean
    notes?: boolean
  }

  export type NutritionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NutritionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NutritionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NutritionLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      meal: string
      calories: number
      protein: number | null
      carbs: number | null
      fats: number | null
      mealType: string | null
      notes: string | null
    }, ExtArgs["result"]["nutritionLog"]>
    composites: {}
  }

  type NutritionLogGetPayload<S extends boolean | null | undefined | NutritionLogDefaultArgs> = $Result.GetResult<Prisma.$NutritionLogPayload, S>

  type NutritionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NutritionLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NutritionLogCountAggregateInputType | true
    }

  export interface NutritionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NutritionLog'], meta: { name: 'NutritionLog' } }
    /**
     * Find zero or one NutritionLog that matches the filter.
     * @param {NutritionLogFindUniqueArgs} args - Arguments to find a NutritionLog
     * @example
     * // Get one NutritionLog
     * const nutritionLog = await prisma.nutritionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutritionLogFindUniqueArgs>(args: SelectSubset<T, NutritionLogFindUniqueArgs<ExtArgs>>): Prisma__NutritionLogClient<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NutritionLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NutritionLogFindUniqueOrThrowArgs} args - Arguments to find a NutritionLog
     * @example
     * // Get one NutritionLog
     * const nutritionLog = await prisma.nutritionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutritionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NutritionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutritionLogClient<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NutritionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionLogFindFirstArgs} args - Arguments to find a NutritionLog
     * @example
     * // Get one NutritionLog
     * const nutritionLog = await prisma.nutritionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutritionLogFindFirstArgs>(args?: SelectSubset<T, NutritionLogFindFirstArgs<ExtArgs>>): Prisma__NutritionLogClient<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NutritionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionLogFindFirstOrThrowArgs} args - Arguments to find a NutritionLog
     * @example
     * // Get one NutritionLog
     * const nutritionLog = await prisma.nutritionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutritionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NutritionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutritionLogClient<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NutritionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionLogs
     * const nutritionLogs = await prisma.nutritionLog.findMany()
     * 
     * // Get first 10 NutritionLogs
     * const nutritionLogs = await prisma.nutritionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionLogWithIdOnly = await prisma.nutritionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NutritionLogFindManyArgs>(args?: SelectSubset<T, NutritionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NutritionLog.
     * @param {NutritionLogCreateArgs} args - Arguments to create a NutritionLog.
     * @example
     * // Create one NutritionLog
     * const NutritionLog = await prisma.nutritionLog.create({
     *   data: {
     *     // ... data to create a NutritionLog
     *   }
     * })
     * 
     */
    create<T extends NutritionLogCreateArgs>(args: SelectSubset<T, NutritionLogCreateArgs<ExtArgs>>): Prisma__NutritionLogClient<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NutritionLogs.
     * @param {NutritionLogCreateManyArgs} args - Arguments to create many NutritionLogs.
     * @example
     * // Create many NutritionLogs
     * const nutritionLog = await prisma.nutritionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutritionLogCreateManyArgs>(args?: SelectSubset<T, NutritionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutritionLogs and returns the data saved in the database.
     * @param {NutritionLogCreateManyAndReturnArgs} args - Arguments to create many NutritionLogs.
     * @example
     * // Create many NutritionLogs
     * const nutritionLog = await prisma.nutritionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutritionLogs and only return the `id`
     * const nutritionLogWithIdOnly = await prisma.nutritionLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NutritionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NutritionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NutritionLog.
     * @param {NutritionLogDeleteArgs} args - Arguments to delete one NutritionLog.
     * @example
     * // Delete one NutritionLog
     * const NutritionLog = await prisma.nutritionLog.delete({
     *   where: {
     *     // ... filter to delete one NutritionLog
     *   }
     * })
     * 
     */
    delete<T extends NutritionLogDeleteArgs>(args: SelectSubset<T, NutritionLogDeleteArgs<ExtArgs>>): Prisma__NutritionLogClient<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NutritionLog.
     * @param {NutritionLogUpdateArgs} args - Arguments to update one NutritionLog.
     * @example
     * // Update one NutritionLog
     * const nutritionLog = await prisma.nutritionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutritionLogUpdateArgs>(args: SelectSubset<T, NutritionLogUpdateArgs<ExtArgs>>): Prisma__NutritionLogClient<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NutritionLogs.
     * @param {NutritionLogDeleteManyArgs} args - Arguments to filter NutritionLogs to delete.
     * @example
     * // Delete a few NutritionLogs
     * const { count } = await prisma.nutritionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutritionLogDeleteManyArgs>(args?: SelectSubset<T, NutritionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionLogs
     * const nutritionLog = await prisma.nutritionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutritionLogUpdateManyArgs>(args: SelectSubset<T, NutritionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NutritionLog.
     * @param {NutritionLogUpsertArgs} args - Arguments to update or create a NutritionLog.
     * @example
     * // Update or create a NutritionLog
     * const nutritionLog = await prisma.nutritionLog.upsert({
     *   create: {
     *     // ... data to create a NutritionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionLog we want to update
     *   }
     * })
     */
    upsert<T extends NutritionLogUpsertArgs>(args: SelectSubset<T, NutritionLogUpsertArgs<ExtArgs>>): Prisma__NutritionLogClient<$Result.GetResult<Prisma.$NutritionLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NutritionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionLogCountArgs} args - Arguments to filter NutritionLogs to count.
     * @example
     * // Count the number of NutritionLogs
     * const count = await prisma.nutritionLog.count({
     *   where: {
     *     // ... the filter for the NutritionLogs we want to count
     *   }
     * })
    **/
    count<T extends NutritionLogCountArgs>(
      args?: Subset<T, NutritionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionLogAggregateArgs>(args: Subset<T, NutritionLogAggregateArgs>): Prisma.PrismaPromise<GetNutritionLogAggregateType<T>>

    /**
     * Group by NutritionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutritionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutritionLogGroupByArgs['orderBy'] }
        : { orderBy?: NutritionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutritionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NutritionLog model
   */
  readonly fields: NutritionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutritionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutritionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NutritionLog model
   */ 
  interface NutritionLogFieldRefs {
    readonly id: FieldRef<"NutritionLog", 'String'>
    readonly userId: FieldRef<"NutritionLog", 'String'>
    readonly date: FieldRef<"NutritionLog", 'DateTime'>
    readonly meal: FieldRef<"NutritionLog", 'String'>
    readonly calories: FieldRef<"NutritionLog", 'Int'>
    readonly protein: FieldRef<"NutritionLog", 'Float'>
    readonly carbs: FieldRef<"NutritionLog", 'Float'>
    readonly fats: FieldRef<"NutritionLog", 'Float'>
    readonly mealType: FieldRef<"NutritionLog", 'String'>
    readonly notes: FieldRef<"NutritionLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NutritionLog findUnique
   */
  export type NutritionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
    /**
     * Filter, which NutritionLog to fetch.
     */
    where: NutritionLogWhereUniqueInput
  }

  /**
   * NutritionLog findUniqueOrThrow
   */
  export type NutritionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
    /**
     * Filter, which NutritionLog to fetch.
     */
    where: NutritionLogWhereUniqueInput
  }

  /**
   * NutritionLog findFirst
   */
  export type NutritionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
    /**
     * Filter, which NutritionLog to fetch.
     */
    where?: NutritionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionLogs to fetch.
     */
    orderBy?: NutritionLogOrderByWithRelationInput | NutritionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionLogs.
     */
    cursor?: NutritionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionLogs.
     */
    distinct?: NutritionLogScalarFieldEnum | NutritionLogScalarFieldEnum[]
  }

  /**
   * NutritionLog findFirstOrThrow
   */
  export type NutritionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
    /**
     * Filter, which NutritionLog to fetch.
     */
    where?: NutritionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionLogs to fetch.
     */
    orderBy?: NutritionLogOrderByWithRelationInput | NutritionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionLogs.
     */
    cursor?: NutritionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionLogs.
     */
    distinct?: NutritionLogScalarFieldEnum | NutritionLogScalarFieldEnum[]
  }

  /**
   * NutritionLog findMany
   */
  export type NutritionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
    /**
     * Filter, which NutritionLogs to fetch.
     */
    where?: NutritionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionLogs to fetch.
     */
    orderBy?: NutritionLogOrderByWithRelationInput | NutritionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutritionLogs.
     */
    cursor?: NutritionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionLogs.
     */
    skip?: number
    distinct?: NutritionLogScalarFieldEnum | NutritionLogScalarFieldEnum[]
  }

  /**
   * NutritionLog create
   */
  export type NutritionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a NutritionLog.
     */
    data: XOR<NutritionLogCreateInput, NutritionLogUncheckedCreateInput>
  }

  /**
   * NutritionLog createMany
   */
  export type NutritionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NutritionLogs.
     */
    data: NutritionLogCreateManyInput | NutritionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NutritionLog createManyAndReturn
   */
  export type NutritionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NutritionLogs.
     */
    data: NutritionLogCreateManyInput | NutritionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionLog update
   */
  export type NutritionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a NutritionLog.
     */
    data: XOR<NutritionLogUpdateInput, NutritionLogUncheckedUpdateInput>
    /**
     * Choose, which NutritionLog to update.
     */
    where: NutritionLogWhereUniqueInput
  }

  /**
   * NutritionLog updateMany
   */
  export type NutritionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NutritionLogs.
     */
    data: XOR<NutritionLogUpdateManyMutationInput, NutritionLogUncheckedUpdateManyInput>
    /**
     * Filter which NutritionLogs to update
     */
    where?: NutritionLogWhereInput
  }

  /**
   * NutritionLog upsert
   */
  export type NutritionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the NutritionLog to update in case it exists.
     */
    where: NutritionLogWhereUniqueInput
    /**
     * In case the NutritionLog found by the `where` argument doesn't exist, create a new NutritionLog with this data.
     */
    create: XOR<NutritionLogCreateInput, NutritionLogUncheckedCreateInput>
    /**
     * In case the NutritionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutritionLogUpdateInput, NutritionLogUncheckedUpdateInput>
  }

  /**
   * NutritionLog delete
   */
  export type NutritionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
    /**
     * Filter which NutritionLog to delete.
     */
    where: NutritionLogWhereUniqueInput
  }

  /**
   * NutritionLog deleteMany
   */
  export type NutritionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionLogs to delete
     */
    where?: NutritionLogWhereInput
  }

  /**
   * NutritionLog without action
   */
  export type NutritionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionLog
     */
    select?: NutritionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionLogInclude<ExtArgs> | null
  }


  /**
   * Model SupplementLog
   */

  export type AggregateSupplementLog = {
    _count: SupplementLogCountAggregateOutputType | null
    _min: SupplementLogMinAggregateOutputType | null
    _max: SupplementLogMaxAggregateOutputType | null
  }

  export type SupplementLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    supplementName: string | null
    dose: string | null
    notes: string | null
  }

  export type SupplementLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    supplementName: string | null
    dose: string | null
    notes: string | null
  }

  export type SupplementLogCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    supplementName: number
    dose: number
    notes: number
    _all: number
  }


  export type SupplementLogMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    supplementName?: true
    dose?: true
    notes?: true
  }

  export type SupplementLogMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    supplementName?: true
    dose?: true
    notes?: true
  }

  export type SupplementLogCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    supplementName?: true
    dose?: true
    notes?: true
    _all?: true
  }

  export type SupplementLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplementLog to aggregate.
     */
    where?: SupplementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplementLogs to fetch.
     */
    orderBy?: SupplementLogOrderByWithRelationInput | SupplementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplementLogs
    **/
    _count?: true | SupplementLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplementLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplementLogMaxAggregateInputType
  }

  export type GetSupplementLogAggregateType<T extends SupplementLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplementLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplementLog[P]>
      : GetScalarType<T[P], AggregateSupplementLog[P]>
  }




  export type SupplementLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplementLogWhereInput
    orderBy?: SupplementLogOrderByWithAggregationInput | SupplementLogOrderByWithAggregationInput[]
    by: SupplementLogScalarFieldEnum[] | SupplementLogScalarFieldEnum
    having?: SupplementLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplementLogCountAggregateInputType | true
    _min?: SupplementLogMinAggregateInputType
    _max?: SupplementLogMaxAggregateInputType
  }

  export type SupplementLogGroupByOutputType = {
    id: string
    userId: string
    date: Date
    supplementName: string
    dose: string
    notes: string | null
    _count: SupplementLogCountAggregateOutputType | null
    _min: SupplementLogMinAggregateOutputType | null
    _max: SupplementLogMaxAggregateOutputType | null
  }

  type GetSupplementLogGroupByPayload<T extends SupplementLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplementLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplementLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplementLogGroupByOutputType[P]>
            : GetScalarType<T[P], SupplementLogGroupByOutputType[P]>
        }
      >
    >


  export type SupplementLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    supplementName?: boolean
    dose?: boolean
    notes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplementLog"]>

  export type SupplementLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    supplementName?: boolean
    dose?: boolean
    notes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplementLog"]>

  export type SupplementLogSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    supplementName?: boolean
    dose?: boolean
    notes?: boolean
  }

  export type SupplementLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupplementLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupplementLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplementLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      supplementName: string
      dose: string
      notes: string | null
    }, ExtArgs["result"]["supplementLog"]>
    composites: {}
  }

  type SupplementLogGetPayload<S extends boolean | null | undefined | SupplementLogDefaultArgs> = $Result.GetResult<Prisma.$SupplementLogPayload, S>

  type SupplementLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplementLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplementLogCountAggregateInputType | true
    }

  export interface SupplementLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplementLog'], meta: { name: 'SupplementLog' } }
    /**
     * Find zero or one SupplementLog that matches the filter.
     * @param {SupplementLogFindUniqueArgs} args - Arguments to find a SupplementLog
     * @example
     * // Get one SupplementLog
     * const supplementLog = await prisma.supplementLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplementLogFindUniqueArgs>(args: SelectSubset<T, SupplementLogFindUniqueArgs<ExtArgs>>): Prisma__SupplementLogClient<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupplementLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplementLogFindUniqueOrThrowArgs} args - Arguments to find a SupplementLog
     * @example
     * // Get one SupplementLog
     * const supplementLog = await prisma.supplementLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplementLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplementLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplementLogClient<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupplementLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplementLogFindFirstArgs} args - Arguments to find a SupplementLog
     * @example
     * // Get one SupplementLog
     * const supplementLog = await prisma.supplementLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplementLogFindFirstArgs>(args?: SelectSubset<T, SupplementLogFindFirstArgs<ExtArgs>>): Prisma__SupplementLogClient<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupplementLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplementLogFindFirstOrThrowArgs} args - Arguments to find a SupplementLog
     * @example
     * // Get one SupplementLog
     * const supplementLog = await prisma.supplementLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplementLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplementLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplementLogClient<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupplementLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplementLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplementLogs
     * const supplementLogs = await prisma.supplementLog.findMany()
     * 
     * // Get first 10 SupplementLogs
     * const supplementLogs = await prisma.supplementLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplementLogWithIdOnly = await prisma.supplementLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplementLogFindManyArgs>(args?: SelectSubset<T, SupplementLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupplementLog.
     * @param {SupplementLogCreateArgs} args - Arguments to create a SupplementLog.
     * @example
     * // Create one SupplementLog
     * const SupplementLog = await prisma.supplementLog.create({
     *   data: {
     *     // ... data to create a SupplementLog
     *   }
     * })
     * 
     */
    create<T extends SupplementLogCreateArgs>(args: SelectSubset<T, SupplementLogCreateArgs<ExtArgs>>): Prisma__SupplementLogClient<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupplementLogs.
     * @param {SupplementLogCreateManyArgs} args - Arguments to create many SupplementLogs.
     * @example
     * // Create many SupplementLogs
     * const supplementLog = await prisma.supplementLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplementLogCreateManyArgs>(args?: SelectSubset<T, SupplementLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplementLogs and returns the data saved in the database.
     * @param {SupplementLogCreateManyAndReturnArgs} args - Arguments to create many SupplementLogs.
     * @example
     * // Create many SupplementLogs
     * const supplementLog = await prisma.supplementLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplementLogs and only return the `id`
     * const supplementLogWithIdOnly = await prisma.supplementLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplementLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplementLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SupplementLog.
     * @param {SupplementLogDeleteArgs} args - Arguments to delete one SupplementLog.
     * @example
     * // Delete one SupplementLog
     * const SupplementLog = await prisma.supplementLog.delete({
     *   where: {
     *     // ... filter to delete one SupplementLog
     *   }
     * })
     * 
     */
    delete<T extends SupplementLogDeleteArgs>(args: SelectSubset<T, SupplementLogDeleteArgs<ExtArgs>>): Prisma__SupplementLogClient<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupplementLog.
     * @param {SupplementLogUpdateArgs} args - Arguments to update one SupplementLog.
     * @example
     * // Update one SupplementLog
     * const supplementLog = await prisma.supplementLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplementLogUpdateArgs>(args: SelectSubset<T, SupplementLogUpdateArgs<ExtArgs>>): Prisma__SupplementLogClient<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupplementLogs.
     * @param {SupplementLogDeleteManyArgs} args - Arguments to filter SupplementLogs to delete.
     * @example
     * // Delete a few SupplementLogs
     * const { count } = await prisma.supplementLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplementLogDeleteManyArgs>(args?: SelectSubset<T, SupplementLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplementLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplementLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplementLogs
     * const supplementLog = await prisma.supplementLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplementLogUpdateManyArgs>(args: SelectSubset<T, SupplementLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupplementLog.
     * @param {SupplementLogUpsertArgs} args - Arguments to update or create a SupplementLog.
     * @example
     * // Update or create a SupplementLog
     * const supplementLog = await prisma.supplementLog.upsert({
     *   create: {
     *     // ... data to create a SupplementLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplementLog we want to update
     *   }
     * })
     */
    upsert<T extends SupplementLogUpsertArgs>(args: SelectSubset<T, SupplementLogUpsertArgs<ExtArgs>>): Prisma__SupplementLogClient<$Result.GetResult<Prisma.$SupplementLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupplementLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplementLogCountArgs} args - Arguments to filter SupplementLogs to count.
     * @example
     * // Count the number of SupplementLogs
     * const count = await prisma.supplementLog.count({
     *   where: {
     *     // ... the filter for the SupplementLogs we want to count
     *   }
     * })
    **/
    count<T extends SupplementLogCountArgs>(
      args?: Subset<T, SupplementLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplementLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplementLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplementLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplementLogAggregateArgs>(args: Subset<T, SupplementLogAggregateArgs>): Prisma.PrismaPromise<GetSupplementLogAggregateType<T>>

    /**
     * Group by SupplementLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplementLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplementLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplementLogGroupByArgs['orderBy'] }
        : { orderBy?: SupplementLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplementLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplementLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplementLog model
   */
  readonly fields: SupplementLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplementLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplementLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplementLog model
   */ 
  interface SupplementLogFieldRefs {
    readonly id: FieldRef<"SupplementLog", 'String'>
    readonly userId: FieldRef<"SupplementLog", 'String'>
    readonly date: FieldRef<"SupplementLog", 'DateTime'>
    readonly supplementName: FieldRef<"SupplementLog", 'String'>
    readonly dose: FieldRef<"SupplementLog", 'String'>
    readonly notes: FieldRef<"SupplementLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SupplementLog findUnique
   */
  export type SupplementLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
    /**
     * Filter, which SupplementLog to fetch.
     */
    where: SupplementLogWhereUniqueInput
  }

  /**
   * SupplementLog findUniqueOrThrow
   */
  export type SupplementLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
    /**
     * Filter, which SupplementLog to fetch.
     */
    where: SupplementLogWhereUniqueInput
  }

  /**
   * SupplementLog findFirst
   */
  export type SupplementLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
    /**
     * Filter, which SupplementLog to fetch.
     */
    where?: SupplementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplementLogs to fetch.
     */
    orderBy?: SupplementLogOrderByWithRelationInput | SupplementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplementLogs.
     */
    cursor?: SupplementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplementLogs.
     */
    distinct?: SupplementLogScalarFieldEnum | SupplementLogScalarFieldEnum[]
  }

  /**
   * SupplementLog findFirstOrThrow
   */
  export type SupplementLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
    /**
     * Filter, which SupplementLog to fetch.
     */
    where?: SupplementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplementLogs to fetch.
     */
    orderBy?: SupplementLogOrderByWithRelationInput | SupplementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplementLogs.
     */
    cursor?: SupplementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplementLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplementLogs.
     */
    distinct?: SupplementLogScalarFieldEnum | SupplementLogScalarFieldEnum[]
  }

  /**
   * SupplementLog findMany
   */
  export type SupplementLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
    /**
     * Filter, which SupplementLogs to fetch.
     */
    where?: SupplementLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplementLogs to fetch.
     */
    orderBy?: SupplementLogOrderByWithRelationInput | SupplementLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplementLogs.
     */
    cursor?: SupplementLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplementLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplementLogs.
     */
    skip?: number
    distinct?: SupplementLogScalarFieldEnum | SupplementLogScalarFieldEnum[]
  }

  /**
   * SupplementLog create
   */
  export type SupplementLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplementLog.
     */
    data: XOR<SupplementLogCreateInput, SupplementLogUncheckedCreateInput>
  }

  /**
   * SupplementLog createMany
   */
  export type SupplementLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplementLogs.
     */
    data: SupplementLogCreateManyInput | SupplementLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplementLog createManyAndReturn
   */
  export type SupplementLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SupplementLogs.
     */
    data: SupplementLogCreateManyInput | SupplementLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplementLog update
   */
  export type SupplementLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplementLog.
     */
    data: XOR<SupplementLogUpdateInput, SupplementLogUncheckedUpdateInput>
    /**
     * Choose, which SupplementLog to update.
     */
    where: SupplementLogWhereUniqueInput
  }

  /**
   * SupplementLog updateMany
   */
  export type SupplementLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplementLogs.
     */
    data: XOR<SupplementLogUpdateManyMutationInput, SupplementLogUncheckedUpdateManyInput>
    /**
     * Filter which SupplementLogs to update
     */
    where?: SupplementLogWhereInput
  }

  /**
   * SupplementLog upsert
   */
  export type SupplementLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplementLog to update in case it exists.
     */
    where: SupplementLogWhereUniqueInput
    /**
     * In case the SupplementLog found by the `where` argument doesn't exist, create a new SupplementLog with this data.
     */
    create: XOR<SupplementLogCreateInput, SupplementLogUncheckedCreateInput>
    /**
     * In case the SupplementLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplementLogUpdateInput, SupplementLogUncheckedUpdateInput>
  }

  /**
   * SupplementLog delete
   */
  export type SupplementLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
    /**
     * Filter which SupplementLog to delete.
     */
    where: SupplementLogWhereUniqueInput
  }

  /**
   * SupplementLog deleteMany
   */
  export type SupplementLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplementLogs to delete
     */
    where?: SupplementLogWhereInput
  }

  /**
   * SupplementLog without action
   */
  export type SupplementLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplementLog
     */
    select?: SupplementLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplementLogInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeSubscriptionId: string | null
    status: string | null
    planCode: string | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeSubscriptionId: string | null
    status: string | null
    planCode: string | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    stripeSubscriptionId: number
    status: number
    planCode: number
    currentPeriodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    stripeSubscriptionId?: true
    status?: true
    planCode?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    stripeSubscriptionId?: true
    status?: true
    planCode?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    stripeSubscriptionId?: true
    status?: true
    planCode?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    stripeSubscriptionId: string | null
    status: string
    planCode: string | null
    currentPeriodEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    planCode?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    planCode?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    planCode?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      stripeSubscriptionId: string | null
      status: string
      planCode: string | null
      currentPeriodEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Subscription$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly planCode: FieldRef<"Subscription", 'String'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.payments
   */
  export type Subscription$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Recommendation
   */

  export type AggregateRecommendation = {
    _count: RecommendationCountAggregateOutputType | null
    _min: RecommendationMinAggregateOutputType | null
    _max: RecommendationMaxAggregateOutputType | null
  }

  export type RecommendationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    coachId: string | null
    type: string | null
    content: string | null
    createdAt: Date | null
  }

  export type RecommendationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    coachId: string | null
    type: string | null
    content: string | null
    createdAt: Date | null
  }

  export type RecommendationCountAggregateOutputType = {
    id: number
    userId: number
    coachId: number
    type: number
    content: number
    createdAt: number
    _all: number
  }


  export type RecommendationMinAggregateInputType = {
    id?: true
    userId?: true
    coachId?: true
    type?: true
    content?: true
    createdAt?: true
  }

  export type RecommendationMaxAggregateInputType = {
    id?: true
    userId?: true
    coachId?: true
    type?: true
    content?: true
    createdAt?: true
  }

  export type RecommendationCountAggregateInputType = {
    id?: true
    userId?: true
    coachId?: true
    type?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type RecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recommendation to aggregate.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recommendations
    **/
    _count?: true | RecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecommendationMaxAggregateInputType
  }

  export type GetRecommendationAggregateType<T extends RecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecommendation[P]>
      : GetScalarType<T[P], AggregateRecommendation[P]>
  }




  export type RecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendationWhereInput
    orderBy?: RecommendationOrderByWithAggregationInput | RecommendationOrderByWithAggregationInput[]
    by: RecommendationScalarFieldEnum[] | RecommendationScalarFieldEnum
    having?: RecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecommendationCountAggregateInputType | true
    _min?: RecommendationMinAggregateInputType
    _max?: RecommendationMaxAggregateInputType
  }

  export type RecommendationGroupByOutputType = {
    id: string
    userId: string
    coachId: string | null
    type: string
    content: string
    createdAt: Date
    _count: RecommendationCountAggregateOutputType | null
    _min: RecommendationMinAggregateOutputType | null
    _max: RecommendationMaxAggregateOutputType | null
  }

  type GetRecommendationGroupByPayload<T extends RecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], RecommendationGroupByOutputType[P]>
        }
      >
    >


  export type RecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coachId?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | Recommendation$coachArgs<ExtArgs>
  }, ExtArgs["result"]["recommendation"]>

  export type RecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coachId?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | Recommendation$coachArgs<ExtArgs>
  }, ExtArgs["result"]["recommendation"]>

  export type RecommendationSelectScalar = {
    id?: boolean
    userId?: boolean
    coachId?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type RecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | Recommendation$coachArgs<ExtArgs>
  }
  export type RecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | Recommendation$coachArgs<ExtArgs>
  }

  export type $RecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recommendation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coach: Prisma.$CoachPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      coachId: string | null
      type: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["recommendation"]>
    composites: {}
  }

  type RecommendationGetPayload<S extends boolean | null | undefined | RecommendationDefaultArgs> = $Result.GetResult<Prisma.$RecommendationPayload, S>

  type RecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecommendationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecommendationCountAggregateInputType | true
    }

  export interface RecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recommendation'], meta: { name: 'Recommendation' } }
    /**
     * Find zero or one Recommendation that matches the filter.
     * @param {RecommendationFindUniqueArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecommendationFindUniqueArgs>(args: SelectSubset<T, RecommendationFindUniqueArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recommendation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecommendationFindUniqueOrThrowArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, RecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindFirstArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecommendationFindFirstArgs>(args?: SelectSubset<T, RecommendationFindFirstArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindFirstOrThrowArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, RecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recommendations
     * const recommendations = await prisma.recommendation.findMany()
     * 
     * // Get first 10 Recommendations
     * const recommendations = await prisma.recommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recommendationWithIdOnly = await prisma.recommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecommendationFindManyArgs>(args?: SelectSubset<T, RecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recommendation.
     * @param {RecommendationCreateArgs} args - Arguments to create a Recommendation.
     * @example
     * // Create one Recommendation
     * const Recommendation = await prisma.recommendation.create({
     *   data: {
     *     // ... data to create a Recommendation
     *   }
     * })
     * 
     */
    create<T extends RecommendationCreateArgs>(args: SelectSubset<T, RecommendationCreateArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recommendations.
     * @param {RecommendationCreateManyArgs} args - Arguments to create many Recommendations.
     * @example
     * // Create many Recommendations
     * const recommendation = await prisma.recommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecommendationCreateManyArgs>(args?: SelectSubset<T, RecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recommendations and returns the data saved in the database.
     * @param {RecommendationCreateManyAndReturnArgs} args - Arguments to create many Recommendations.
     * @example
     * // Create many Recommendations
     * const recommendation = await prisma.recommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recommendations and only return the `id`
     * const recommendationWithIdOnly = await prisma.recommendation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, RecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Recommendation.
     * @param {RecommendationDeleteArgs} args - Arguments to delete one Recommendation.
     * @example
     * // Delete one Recommendation
     * const Recommendation = await prisma.recommendation.delete({
     *   where: {
     *     // ... filter to delete one Recommendation
     *   }
     * })
     * 
     */
    delete<T extends RecommendationDeleteArgs>(args: SelectSubset<T, RecommendationDeleteArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recommendation.
     * @param {RecommendationUpdateArgs} args - Arguments to update one Recommendation.
     * @example
     * // Update one Recommendation
     * const recommendation = await prisma.recommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecommendationUpdateArgs>(args: SelectSubset<T, RecommendationUpdateArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recommendations.
     * @param {RecommendationDeleteManyArgs} args - Arguments to filter Recommendations to delete.
     * @example
     * // Delete a few Recommendations
     * const { count } = await prisma.recommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecommendationDeleteManyArgs>(args?: SelectSubset<T, RecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recommendations
     * const recommendation = await prisma.recommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecommendationUpdateManyArgs>(args: SelectSubset<T, RecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recommendation.
     * @param {RecommendationUpsertArgs} args - Arguments to update or create a Recommendation.
     * @example
     * // Update or create a Recommendation
     * const recommendation = await prisma.recommendation.upsert({
     *   create: {
     *     // ... data to create a Recommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recommendation we want to update
     *   }
     * })
     */
    upsert<T extends RecommendationUpsertArgs>(args: SelectSubset<T, RecommendationUpsertArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationCountArgs} args - Arguments to filter Recommendations to count.
     * @example
     * // Count the number of Recommendations
     * const count = await prisma.recommendation.count({
     *   where: {
     *     // ... the filter for the Recommendations we want to count
     *   }
     * })
    **/
    count<T extends RecommendationCountArgs>(
      args?: Subset<T, RecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecommendationAggregateArgs>(args: Subset<T, RecommendationAggregateArgs>): Prisma.PrismaPromise<GetRecommendationAggregateType<T>>

    /**
     * Group by Recommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecommendationGroupByArgs['orderBy'] }
        : { orderBy?: RecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recommendation model
   */
  readonly fields: RecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    coach<T extends Recommendation$coachArgs<ExtArgs> = {}>(args?: Subset<T, Recommendation$coachArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recommendation model
   */ 
  interface RecommendationFieldRefs {
    readonly id: FieldRef<"Recommendation", 'String'>
    readonly userId: FieldRef<"Recommendation", 'String'>
    readonly coachId: FieldRef<"Recommendation", 'String'>
    readonly type: FieldRef<"Recommendation", 'String'>
    readonly content: FieldRef<"Recommendation", 'String'>
    readonly createdAt: FieldRef<"Recommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recommendation findUnique
   */
  export type RecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation findUniqueOrThrow
   */
  export type RecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation findFirst
   */
  export type RecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recommendations.
     */
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation findFirstOrThrow
   */
  export type RecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recommendations.
     */
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation findMany
   */
  export type RecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter, which Recommendations to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation create
   */
  export type RecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a Recommendation.
     */
    data: XOR<RecommendationCreateInput, RecommendationUncheckedCreateInput>
  }

  /**
   * Recommendation createMany
   */
  export type RecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recommendations.
     */
    data: RecommendationCreateManyInput | RecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recommendation createManyAndReturn
   */
  export type RecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Recommendations.
     */
    data: RecommendationCreateManyInput | RecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recommendation update
   */
  export type RecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a Recommendation.
     */
    data: XOR<RecommendationUpdateInput, RecommendationUncheckedUpdateInput>
    /**
     * Choose, which Recommendation to update.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation updateMany
   */
  export type RecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recommendations.
     */
    data: XOR<RecommendationUpdateManyMutationInput, RecommendationUncheckedUpdateManyInput>
    /**
     * Filter which Recommendations to update
     */
    where?: RecommendationWhereInput
  }

  /**
   * Recommendation upsert
   */
  export type RecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the Recommendation to update in case it exists.
     */
    where: RecommendationWhereUniqueInput
    /**
     * In case the Recommendation found by the `where` argument doesn't exist, create a new Recommendation with this data.
     */
    create: XOR<RecommendationCreateInput, RecommendationUncheckedCreateInput>
    /**
     * In case the Recommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecommendationUpdateInput, RecommendationUncheckedUpdateInput>
  }

  /**
   * Recommendation delete
   */
  export type RecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
    /**
     * Filter which Recommendation to delete.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation deleteMany
   */
  export type RecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recommendations to delete
     */
    where?: RecommendationWhereInput
  }

  /**
   * Recommendation.coach
   */
  export type Recommendation$coachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coach
     */
    select?: CoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachInclude<ExtArgs> | null
    where?: CoachWhereInput
  }

  /**
   * Recommendation without action
   */
  export type RecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendationInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Bundle
   */

  export type AggregateBundle = {
    _count: BundleCountAggregateOutputType | null
    _avg: BundleAvgAggregateOutputType | null
    _sum: BundleSumAggregateOutputType | null
    _min: BundleMinAggregateOutputType | null
    _max: BundleMaxAggregateOutputType | null
  }

  export type BundleAvgAggregateOutputType = {
    price: number | null
  }

  export type BundleSumAggregateOutputType = {
    price: number | null
  }

  export type BundleMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
  }

  export type BundleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
  }

  export type BundleCountAggregateOutputType = {
    id: number
    name: number
    price: number
    _all: number
  }


  export type BundleAvgAggregateInputType = {
    price?: true
  }

  export type BundleSumAggregateInputType = {
    price?: true
  }

  export type BundleMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
  }

  export type BundleMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
  }

  export type BundleCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    _all?: true
  }

  export type BundleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bundle to aggregate.
     */
    where?: BundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bundles to fetch.
     */
    orderBy?: BundleOrderByWithRelationInput | BundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bundles
    **/
    _count?: true | BundleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BundleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BundleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BundleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BundleMaxAggregateInputType
  }

  export type GetBundleAggregateType<T extends BundleAggregateArgs> = {
        [P in keyof T & keyof AggregateBundle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBundle[P]>
      : GetScalarType<T[P], AggregateBundle[P]>
  }




  export type BundleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BundleWhereInput
    orderBy?: BundleOrderByWithAggregationInput | BundleOrderByWithAggregationInput[]
    by: BundleScalarFieldEnum[] | BundleScalarFieldEnum
    having?: BundleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BundleCountAggregateInputType | true
    _avg?: BundleAvgAggregateInputType
    _sum?: BundleSumAggregateInputType
    _min?: BundleMinAggregateInputType
    _max?: BundleMaxAggregateInputType
  }

  export type BundleGroupByOutputType = {
    id: string
    name: string
    price: number
    _count: BundleCountAggregateOutputType | null
    _avg: BundleAvgAggregateOutputType | null
    _sum: BundleSumAggregateOutputType | null
    _min: BundleMinAggregateOutputType | null
    _max: BundleMaxAggregateOutputType | null
  }

  type GetBundleGroupByPayload<T extends BundleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BundleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BundleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BundleGroupByOutputType[P]>
            : GetScalarType<T[P], BundleGroupByOutputType[P]>
        }
      >
    >


  export type BundleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    products?: boolean | Bundle$productsArgs<ExtArgs>
    _count?: boolean | BundleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bundle"]>

  export type BundleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
  }, ExtArgs["result"]["bundle"]>

  export type BundleSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
  }

  export type BundleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Bundle$productsArgs<ExtArgs>
    _count?: boolean | BundleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BundleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BundlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bundle"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
    }, ExtArgs["result"]["bundle"]>
    composites: {}
  }

  type BundleGetPayload<S extends boolean | null | undefined | BundleDefaultArgs> = $Result.GetResult<Prisma.$BundlePayload, S>

  type BundleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BundleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BundleCountAggregateInputType | true
    }

  export interface BundleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bundle'], meta: { name: 'Bundle' } }
    /**
     * Find zero or one Bundle that matches the filter.
     * @param {BundleFindUniqueArgs} args - Arguments to find a Bundle
     * @example
     * // Get one Bundle
     * const bundle = await prisma.bundle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BundleFindUniqueArgs>(args: SelectSubset<T, BundleFindUniqueArgs<ExtArgs>>): Prisma__BundleClient<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bundle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BundleFindUniqueOrThrowArgs} args - Arguments to find a Bundle
     * @example
     * // Get one Bundle
     * const bundle = await prisma.bundle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BundleFindUniqueOrThrowArgs>(args: SelectSubset<T, BundleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BundleClient<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bundle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleFindFirstArgs} args - Arguments to find a Bundle
     * @example
     * // Get one Bundle
     * const bundle = await prisma.bundle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BundleFindFirstArgs>(args?: SelectSubset<T, BundleFindFirstArgs<ExtArgs>>): Prisma__BundleClient<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bundle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleFindFirstOrThrowArgs} args - Arguments to find a Bundle
     * @example
     * // Get one Bundle
     * const bundle = await prisma.bundle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BundleFindFirstOrThrowArgs>(args?: SelectSubset<T, BundleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BundleClient<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bundles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bundles
     * const bundles = await prisma.bundle.findMany()
     * 
     * // Get first 10 Bundles
     * const bundles = await prisma.bundle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bundleWithIdOnly = await prisma.bundle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BundleFindManyArgs>(args?: SelectSubset<T, BundleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bundle.
     * @param {BundleCreateArgs} args - Arguments to create a Bundle.
     * @example
     * // Create one Bundle
     * const Bundle = await prisma.bundle.create({
     *   data: {
     *     // ... data to create a Bundle
     *   }
     * })
     * 
     */
    create<T extends BundleCreateArgs>(args: SelectSubset<T, BundleCreateArgs<ExtArgs>>): Prisma__BundleClient<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bundles.
     * @param {BundleCreateManyArgs} args - Arguments to create many Bundles.
     * @example
     * // Create many Bundles
     * const bundle = await prisma.bundle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BundleCreateManyArgs>(args?: SelectSubset<T, BundleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bundles and returns the data saved in the database.
     * @param {BundleCreateManyAndReturnArgs} args - Arguments to create many Bundles.
     * @example
     * // Create many Bundles
     * const bundle = await prisma.bundle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bundles and only return the `id`
     * const bundleWithIdOnly = await prisma.bundle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BundleCreateManyAndReturnArgs>(args?: SelectSubset<T, BundleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bundle.
     * @param {BundleDeleteArgs} args - Arguments to delete one Bundle.
     * @example
     * // Delete one Bundle
     * const Bundle = await prisma.bundle.delete({
     *   where: {
     *     // ... filter to delete one Bundle
     *   }
     * })
     * 
     */
    delete<T extends BundleDeleteArgs>(args: SelectSubset<T, BundleDeleteArgs<ExtArgs>>): Prisma__BundleClient<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bundle.
     * @param {BundleUpdateArgs} args - Arguments to update one Bundle.
     * @example
     * // Update one Bundle
     * const bundle = await prisma.bundle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BundleUpdateArgs>(args: SelectSubset<T, BundleUpdateArgs<ExtArgs>>): Prisma__BundleClient<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bundles.
     * @param {BundleDeleteManyArgs} args - Arguments to filter Bundles to delete.
     * @example
     * // Delete a few Bundles
     * const { count } = await prisma.bundle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BundleDeleteManyArgs>(args?: SelectSubset<T, BundleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bundles
     * const bundle = await prisma.bundle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BundleUpdateManyArgs>(args: SelectSubset<T, BundleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bundle.
     * @param {BundleUpsertArgs} args - Arguments to update or create a Bundle.
     * @example
     * // Update or create a Bundle
     * const bundle = await prisma.bundle.upsert({
     *   create: {
     *     // ... data to create a Bundle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bundle we want to update
     *   }
     * })
     */
    upsert<T extends BundleUpsertArgs>(args: SelectSubset<T, BundleUpsertArgs<ExtArgs>>): Prisma__BundleClient<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bundles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleCountArgs} args - Arguments to filter Bundles to count.
     * @example
     * // Count the number of Bundles
     * const count = await prisma.bundle.count({
     *   where: {
     *     // ... the filter for the Bundles we want to count
     *   }
     * })
    **/
    count<T extends BundleCountArgs>(
      args?: Subset<T, BundleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BundleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BundleAggregateArgs>(args: Subset<T, BundleAggregateArgs>): Prisma.PrismaPromise<GetBundleAggregateType<T>>

    /**
     * Group by Bundle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BundleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BundleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BundleGroupByArgs['orderBy'] }
        : { orderBy?: BundleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BundleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBundleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bundle model
   */
  readonly fields: BundleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bundle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BundleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Bundle$productsArgs<ExtArgs> = {}>(args?: Subset<T, Bundle$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bundle model
   */ 
  interface BundleFieldRefs {
    readonly id: FieldRef<"Bundle", 'String'>
    readonly name: FieldRef<"Bundle", 'String'>
    readonly price: FieldRef<"Bundle", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Bundle findUnique
   */
  export type BundleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
    /**
     * Filter, which Bundle to fetch.
     */
    where: BundleWhereUniqueInput
  }

  /**
   * Bundle findUniqueOrThrow
   */
  export type BundleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
    /**
     * Filter, which Bundle to fetch.
     */
    where: BundleWhereUniqueInput
  }

  /**
   * Bundle findFirst
   */
  export type BundleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
    /**
     * Filter, which Bundle to fetch.
     */
    where?: BundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bundles to fetch.
     */
    orderBy?: BundleOrderByWithRelationInput | BundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bundles.
     */
    cursor?: BundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bundles.
     */
    distinct?: BundleScalarFieldEnum | BundleScalarFieldEnum[]
  }

  /**
   * Bundle findFirstOrThrow
   */
  export type BundleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
    /**
     * Filter, which Bundle to fetch.
     */
    where?: BundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bundles to fetch.
     */
    orderBy?: BundleOrderByWithRelationInput | BundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bundles.
     */
    cursor?: BundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bundles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bundles.
     */
    distinct?: BundleScalarFieldEnum | BundleScalarFieldEnum[]
  }

  /**
   * Bundle findMany
   */
  export type BundleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
    /**
     * Filter, which Bundles to fetch.
     */
    where?: BundleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bundles to fetch.
     */
    orderBy?: BundleOrderByWithRelationInput | BundleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bundles.
     */
    cursor?: BundleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bundles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bundles.
     */
    skip?: number
    distinct?: BundleScalarFieldEnum | BundleScalarFieldEnum[]
  }

  /**
   * Bundle create
   */
  export type BundleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
    /**
     * The data needed to create a Bundle.
     */
    data: XOR<BundleCreateInput, BundleUncheckedCreateInput>
  }

  /**
   * Bundle createMany
   */
  export type BundleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bundles.
     */
    data: BundleCreateManyInput | BundleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bundle createManyAndReturn
   */
  export type BundleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bundles.
     */
    data: BundleCreateManyInput | BundleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bundle update
   */
  export type BundleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
    /**
     * The data needed to update a Bundle.
     */
    data: XOR<BundleUpdateInput, BundleUncheckedUpdateInput>
    /**
     * Choose, which Bundle to update.
     */
    where: BundleWhereUniqueInput
  }

  /**
   * Bundle updateMany
   */
  export type BundleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bundles.
     */
    data: XOR<BundleUpdateManyMutationInput, BundleUncheckedUpdateManyInput>
    /**
     * Filter which Bundles to update
     */
    where?: BundleWhereInput
  }

  /**
   * Bundle upsert
   */
  export type BundleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
    /**
     * The filter to search for the Bundle to update in case it exists.
     */
    where: BundleWhereUniqueInput
    /**
     * In case the Bundle found by the `where` argument doesn't exist, create a new Bundle with this data.
     */
    create: XOR<BundleCreateInput, BundleUncheckedCreateInput>
    /**
     * In case the Bundle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BundleUpdateInput, BundleUncheckedUpdateInput>
  }

  /**
   * Bundle delete
   */
  export type BundleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
    /**
     * Filter which Bundle to delete.
     */
    where: BundleWhereUniqueInput
  }

  /**
   * Bundle deleteMany
   */
  export type BundleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bundles to delete
     */
    where?: BundleWhereInput
  }

  /**
   * Bundle.products
   */
  export type Bundle$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Bundle without action
   */
  export type BundleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    priceCents: number | null
    inventory: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    priceCents: number | null
    inventory: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    price: number | null
    priceCents: number | null
    currency: string | null
    inventory: number | null
    categoryId: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    price: number | null
    priceCents: number | null
    currency: string | null
    inventory: number | null
    categoryId: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    description: number
    price: number
    priceCents: number
    currency: number
    inventory: number
    categoryId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    priceCents?: true
    inventory?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    priceCents?: true
    inventory?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    price?: true
    priceCents?: true
    currency?: true
    inventory?: true
    categoryId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    price?: true
    priceCents?: true
    currency?: true
    inventory?: true
    categoryId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    price?: true
    priceCents?: true
    currency?: true
    inventory?: true
    categoryId?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sku: string
    name: string
    description: string | null
    price: number | null
    priceCents: number
    currency: string
    inventory: number
    categoryId: string
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    priceCents?: boolean
    currency?: boolean
    inventory?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    bundles?: boolean | Product$bundlesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    priceCents?: boolean
    currency?: boolean
    inventory?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    priceCents?: boolean
    currency?: boolean
    inventory?: boolean
    categoryId?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    bundles?: boolean | Product$bundlesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      bundles: Prisma.$BundlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      name: string
      description: string | null
      price: number | null
      priceCents: number
      currency: string
      inventory: number
      categoryId: string
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bundles<T extends Product$bundlesArgs<ExtArgs> = {}>(args?: Subset<T, Product$bundlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BundlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly priceCents: FieldRef<"Product", 'Int'>
    readonly currency: FieldRef<"Product", 'String'>
    readonly inventory: FieldRef<"Product", 'Int'>
    readonly categoryId: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.bundles
   */
  export type Product$bundlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bundle
     */
    select?: BundleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BundleInclude<ExtArgs> | null
    where?: BundleWhereInput
    orderBy?: BundleOrderByWithRelationInput | BundleOrderByWithRelationInput[]
    cursor?: BundleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BundleScalarFieldEnum | BundleScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Delivery
   */

  export type AggregateDelivery = {
    _count: DeliveryCountAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  export type DeliveryMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    status: string | null
    trackingUrl: string | null
    address: string | null
    courier: string | null
    estimatedDate: Date | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type DeliveryMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    status: string | null
    trackingUrl: string | null
    address: string | null
    courier: string | null
    estimatedDate: Date | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type DeliveryCountAggregateOutputType = {
    id: number
    orderId: number
    status: number
    trackingUrl: number
    address: number
    courier: number
    estimatedDate: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type DeliveryMinAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    trackingUrl?: true
    address?: true
    courier?: true
    estimatedDate?: true
    updatedAt?: true
    createdAt?: true
  }

  export type DeliveryMaxAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    trackingUrl?: true
    address?: true
    courier?: true
    estimatedDate?: true
    updatedAt?: true
    createdAt?: true
  }

  export type DeliveryCountAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    trackingUrl?: true
    address?: true
    courier?: true
    estimatedDate?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type DeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delivery to aggregate.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliveries
    **/
    _count?: true | DeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMaxAggregateInputType
  }

  export type GetDeliveryAggregateType<T extends DeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery[P]>
      : GetScalarType<T[P], AggregateDelivery[P]>
  }




  export type DeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithAggregationInput | DeliveryOrderByWithAggregationInput[]
    by: DeliveryScalarFieldEnum[] | DeliveryScalarFieldEnum
    having?: DeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryCountAggregateInputType | true
    _min?: DeliveryMinAggregateInputType
    _max?: DeliveryMaxAggregateInputType
  }

  export type DeliveryGroupByOutputType = {
    id: string
    orderId: string
    status: string
    trackingUrl: string | null
    address: string
    courier: string | null
    estimatedDate: Date | null
    updatedAt: Date
    createdAt: Date
    _count: DeliveryCountAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  type GetDeliveryGroupByPayload<T extends DeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    status?: boolean
    trackingUrl?: boolean
    address?: boolean
    courier?: boolean
    estimatedDate?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    status?: boolean
    trackingUrl?: boolean
    address?: boolean
    courier?: boolean
    estimatedDate?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectScalar = {
    id?: boolean
    orderId?: boolean
    status?: boolean
    trackingUrl?: boolean
    address?: boolean
    courier?: boolean
    estimatedDate?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type DeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type DeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $DeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Delivery"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      status: string
      trackingUrl: string | null
      address: string
      courier: string | null
      estimatedDate: Date | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["delivery"]>
    composites: {}
  }

  type DeliveryGetPayload<S extends boolean | null | undefined | DeliveryDefaultArgs> = $Result.GetResult<Prisma.$DeliveryPayload, S>

  type DeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeliveryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeliveryCountAggregateInputType | true
    }

  export interface DeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delivery'], meta: { name: 'Delivery' } }
    /**
     * Find zero or one Delivery that matches the filter.
     * @param {DeliveryFindUniqueArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryFindUniqueArgs>(args: SelectSubset<T, DeliveryFindUniqueArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Delivery that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeliveryFindUniqueOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Delivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryFindFirstArgs>(args?: SelectSubset<T, DeliveryFindFirstArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Delivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Deliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveries
     * const deliveries = await prisma.delivery.findMany()
     * 
     * // Get first 10 Deliveries
     * const deliveries = await prisma.delivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryWithIdOnly = await prisma.delivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryFindManyArgs>(args?: SelectSubset<T, DeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Delivery.
     * @param {DeliveryCreateArgs} args - Arguments to create a Delivery.
     * @example
     * // Create one Delivery
     * const Delivery = await prisma.delivery.create({
     *   data: {
     *     // ... data to create a Delivery
     *   }
     * })
     * 
     */
    create<T extends DeliveryCreateArgs>(args: SelectSubset<T, DeliveryCreateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Deliveries.
     * @param {DeliveryCreateManyArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryCreateManyArgs>(args?: SelectSubset<T, DeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deliveries and returns the data saved in the database.
     * @param {DeliveryCreateManyAndReturnArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deliveries and only return the `id`
     * const deliveryWithIdOnly = await prisma.delivery.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Delivery.
     * @param {DeliveryDeleteArgs} args - Arguments to delete one Delivery.
     * @example
     * // Delete one Delivery
     * const Delivery = await prisma.delivery.delete({
     *   where: {
     *     // ... filter to delete one Delivery
     *   }
     * })
     * 
     */
    delete<T extends DeliveryDeleteArgs>(args: SelectSubset<T, DeliveryDeleteArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Delivery.
     * @param {DeliveryUpdateArgs} args - Arguments to update one Delivery.
     * @example
     * // Update one Delivery
     * const delivery = await prisma.delivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryUpdateArgs>(args: SelectSubset<T, DeliveryUpdateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Deliveries.
     * @param {DeliveryDeleteManyArgs} args - Arguments to filter Deliveries to delete.
     * @example
     * // Delete a few Deliveries
     * const { count } = await prisma.delivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryDeleteManyArgs>(args?: SelectSubset<T, DeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryUpdateManyArgs>(args: SelectSubset<T, DeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Delivery.
     * @param {DeliveryUpsertArgs} args - Arguments to update or create a Delivery.
     * @example
     * // Update or create a Delivery
     * const delivery = await prisma.delivery.upsert({
     *   create: {
     *     // ... data to create a Delivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryUpsertArgs>(args: SelectSubset<T, DeliveryUpsertArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryCountArgs} args - Arguments to filter Deliveries to count.
     * @example
     * // Count the number of Deliveries
     * const count = await prisma.delivery.count({
     *   where: {
     *     // ... the filter for the Deliveries we want to count
     *   }
     * })
    **/
    count<T extends DeliveryCountArgs>(
      args?: Subset<T, DeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAggregateArgs>(args: Subset<T, DeliveryAggregateArgs>): Prisma.PrismaPromise<GetDeliveryAggregateType<T>>

    /**
     * Group by Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delivery model
   */
  readonly fields: DeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Delivery model
   */ 
  interface DeliveryFieldRefs {
    readonly id: FieldRef<"Delivery", 'String'>
    readonly orderId: FieldRef<"Delivery", 'String'>
    readonly status: FieldRef<"Delivery", 'String'>
    readonly trackingUrl: FieldRef<"Delivery", 'String'>
    readonly address: FieldRef<"Delivery", 'String'>
    readonly courier: FieldRef<"Delivery", 'String'>
    readonly estimatedDate: FieldRef<"Delivery", 'DateTime'>
    readonly updatedAt: FieldRef<"Delivery", 'DateTime'>
    readonly createdAt: FieldRef<"Delivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Delivery findUnique
   */
  export type DeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findUniqueOrThrow
   */
  export type DeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findFirst
   */
  export type DeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findFirstOrThrow
   */
  export type DeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findMany
   */
  export type DeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Deliveries to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery create
   */
  export type DeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a Delivery.
     */
    data: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
  }

  /**
   * Delivery createMany
   */
  export type DeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Delivery createManyAndReturn
   */
  export type DeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delivery update
   */
  export type DeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a Delivery.
     */
    data: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
    /**
     * Choose, which Delivery to update.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery updateMany
   */
  export type DeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
  }

  /**
   * Delivery upsert
   */
  export type DeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the Delivery to update in case it exists.
     */
    where: DeliveryWhereUniqueInput
    /**
     * In case the Delivery found by the `where` argument doesn't exist, create a new Delivery with this data.
     */
    create: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
    /**
     * In case the Delivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
  }

  /**
   * Delivery delete
   */
  export type DeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter which Delivery to delete.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery deleteMany
   */
  export type DeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deliveries to delete
     */
    where?: DeliveryWhereInput
  }

  /**
   * Delivery without action
   */
  export type DeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
  }


  /**
   * Model Affiliate
   */

  export type AggregateAffiliate = {
    _count: AffiliateCountAggregateOutputType | null
    _min: AffiliateMinAggregateOutputType | null
    _max: AffiliateMaxAggregateOutputType | null
  }

  export type AffiliateMinAggregateOutputType = {
    id: string | null
    name: string | null
    referralCode: string | null
    brandUrl: string | null
  }

  export type AffiliateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    referralCode: string | null
    brandUrl: string | null
  }

  export type AffiliateCountAggregateOutputType = {
    id: number
    name: number
    referralCode: number
    brandUrl: number
    _all: number
  }


  export type AffiliateMinAggregateInputType = {
    id?: true
    name?: true
    referralCode?: true
    brandUrl?: true
  }

  export type AffiliateMaxAggregateInputType = {
    id?: true
    name?: true
    referralCode?: true
    brandUrl?: true
  }

  export type AffiliateCountAggregateInputType = {
    id?: true
    name?: true
    referralCode?: true
    brandUrl?: true
    _all?: true
  }

  export type AffiliateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliate to aggregate.
     */
    where?: AffiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliateOrderByWithRelationInput | AffiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Affiliates
    **/
    _count?: true | AffiliateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateMaxAggregateInputType
  }

  export type GetAffiliateAggregateType<T extends AffiliateAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliate[P]>
      : GetScalarType<T[P], AggregateAffiliate[P]>
  }




  export type AffiliateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateWhereInput
    orderBy?: AffiliateOrderByWithAggregationInput | AffiliateOrderByWithAggregationInput[]
    by: AffiliateScalarFieldEnum[] | AffiliateScalarFieldEnum
    having?: AffiliateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateCountAggregateInputType | true
    _min?: AffiliateMinAggregateInputType
    _max?: AffiliateMaxAggregateInputType
  }

  export type AffiliateGroupByOutputType = {
    id: string
    name: string
    referralCode: string
    brandUrl: string | null
    _count: AffiliateCountAggregateOutputType | null
    _min: AffiliateMinAggregateOutputType | null
    _max: AffiliateMaxAggregateOutputType | null
  }

  type GetAffiliateGroupByPayload<T extends AffiliateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    referralCode?: boolean
    brandUrl?: boolean
    commissions?: boolean | Affiliate$commissionsArgs<ExtArgs>
    _count?: boolean | AffiliateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliate"]>

  export type AffiliateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    referralCode?: boolean
    brandUrl?: boolean
  }, ExtArgs["result"]["affiliate"]>

  export type AffiliateSelectScalar = {
    id?: boolean
    name?: boolean
    referralCode?: boolean
    brandUrl?: boolean
  }

  export type AffiliateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commissions?: boolean | Affiliate$commissionsArgs<ExtArgs>
    _count?: boolean | AffiliateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AffiliateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AffiliatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Affiliate"
    objects: {
      commissions: Prisma.$CommissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      referralCode: string
      brandUrl: string | null
    }, ExtArgs["result"]["affiliate"]>
    composites: {}
  }

  type AffiliateGetPayload<S extends boolean | null | undefined | AffiliateDefaultArgs> = $Result.GetResult<Prisma.$AffiliatePayload, S>

  type AffiliateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateCountAggregateInputType | true
    }

  export interface AffiliateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Affiliate'], meta: { name: 'Affiliate' } }
    /**
     * Find zero or one Affiliate that matches the filter.
     * @param {AffiliateFindUniqueArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateFindUniqueArgs>(args: SelectSubset<T, AffiliateFindUniqueArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Affiliate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateFindUniqueOrThrowArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Affiliate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateFindFirstArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateFindFirstArgs>(args?: SelectSubset<T, AffiliateFindFirstArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Affiliate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateFindFirstOrThrowArgs} args - Arguments to find a Affiliate
     * @example
     * // Get one Affiliate
     * const affiliate = await prisma.affiliate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Affiliates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Affiliates
     * const affiliates = await prisma.affiliate.findMany()
     * 
     * // Get first 10 Affiliates
     * const affiliates = await prisma.affiliate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateWithIdOnly = await prisma.affiliate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateFindManyArgs>(args?: SelectSubset<T, AffiliateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Affiliate.
     * @param {AffiliateCreateArgs} args - Arguments to create a Affiliate.
     * @example
     * // Create one Affiliate
     * const Affiliate = await prisma.affiliate.create({
     *   data: {
     *     // ... data to create a Affiliate
     *   }
     * })
     * 
     */
    create<T extends AffiliateCreateArgs>(args: SelectSubset<T, AffiliateCreateArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Affiliates.
     * @param {AffiliateCreateManyArgs} args - Arguments to create many Affiliates.
     * @example
     * // Create many Affiliates
     * const affiliate = await prisma.affiliate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateCreateManyArgs>(args?: SelectSubset<T, AffiliateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Affiliates and returns the data saved in the database.
     * @param {AffiliateCreateManyAndReturnArgs} args - Arguments to create many Affiliates.
     * @example
     * // Create many Affiliates
     * const affiliate = await prisma.affiliate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Affiliates and only return the `id`
     * const affiliateWithIdOnly = await prisma.affiliate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Affiliate.
     * @param {AffiliateDeleteArgs} args - Arguments to delete one Affiliate.
     * @example
     * // Delete one Affiliate
     * const Affiliate = await prisma.affiliate.delete({
     *   where: {
     *     // ... filter to delete one Affiliate
     *   }
     * })
     * 
     */
    delete<T extends AffiliateDeleteArgs>(args: SelectSubset<T, AffiliateDeleteArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Affiliate.
     * @param {AffiliateUpdateArgs} args - Arguments to update one Affiliate.
     * @example
     * // Update one Affiliate
     * const affiliate = await prisma.affiliate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateUpdateArgs>(args: SelectSubset<T, AffiliateUpdateArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Affiliates.
     * @param {AffiliateDeleteManyArgs} args - Arguments to filter Affiliates to delete.
     * @example
     * // Delete a few Affiliates
     * const { count } = await prisma.affiliate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateDeleteManyArgs>(args?: SelectSubset<T, AffiliateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Affiliates
     * const affiliate = await prisma.affiliate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateUpdateManyArgs>(args: SelectSubset<T, AffiliateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Affiliate.
     * @param {AffiliateUpsertArgs} args - Arguments to update or create a Affiliate.
     * @example
     * // Update or create a Affiliate
     * const affiliate = await prisma.affiliate.upsert({
     *   create: {
     *     // ... data to create a Affiliate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Affiliate we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateUpsertArgs>(args: SelectSubset<T, AffiliateUpsertArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateCountArgs} args - Arguments to filter Affiliates to count.
     * @example
     * // Count the number of Affiliates
     * const count = await prisma.affiliate.count({
     *   where: {
     *     // ... the filter for the Affiliates we want to count
     *   }
     * })
    **/
    count<T extends AffiliateCountArgs>(
      args?: Subset<T, AffiliateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Affiliate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateAggregateArgs>(args: Subset<T, AffiliateAggregateArgs>): Prisma.PrismaPromise<GetAffiliateAggregateType<T>>

    /**
     * Group by Affiliate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Affiliate model
   */
  readonly fields: AffiliateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Affiliate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commissions<T extends Affiliate$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliate$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Affiliate model
   */ 
  interface AffiliateFieldRefs {
    readonly id: FieldRef<"Affiliate", 'String'>
    readonly name: FieldRef<"Affiliate", 'String'>
    readonly referralCode: FieldRef<"Affiliate", 'String'>
    readonly brandUrl: FieldRef<"Affiliate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Affiliate findUnique
   */
  export type AffiliateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate to fetch.
     */
    where: AffiliateWhereUniqueInput
  }

  /**
   * Affiliate findUniqueOrThrow
   */
  export type AffiliateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate to fetch.
     */
    where: AffiliateWhereUniqueInput
  }

  /**
   * Affiliate findFirst
   */
  export type AffiliateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate to fetch.
     */
    where?: AffiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliateOrderByWithRelationInput | AffiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliates.
     */
    cursor?: AffiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliates.
     */
    distinct?: AffiliateScalarFieldEnum | AffiliateScalarFieldEnum[]
  }

  /**
   * Affiliate findFirstOrThrow
   */
  export type AffiliateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter, which Affiliate to fetch.
     */
    where?: AffiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliateOrderByWithRelationInput | AffiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliates.
     */
    cursor?: AffiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliates.
     */
    distinct?: AffiliateScalarFieldEnum | AffiliateScalarFieldEnum[]
  }

  /**
   * Affiliate findMany
   */
  export type AffiliateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where?: AffiliateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliateOrderByWithRelationInput | AffiliateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Affiliates.
     */
    cursor?: AffiliateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    distinct?: AffiliateScalarFieldEnum | AffiliateScalarFieldEnum[]
  }

  /**
   * Affiliate create
   */
  export type AffiliateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * The data needed to create a Affiliate.
     */
    data: XOR<AffiliateCreateInput, AffiliateUncheckedCreateInput>
  }

  /**
   * Affiliate createMany
   */
  export type AffiliateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Affiliates.
     */
    data: AffiliateCreateManyInput | AffiliateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Affiliate createManyAndReturn
   */
  export type AffiliateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Affiliates.
     */
    data: AffiliateCreateManyInput | AffiliateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Affiliate update
   */
  export type AffiliateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * The data needed to update a Affiliate.
     */
    data: XOR<AffiliateUpdateInput, AffiliateUncheckedUpdateInput>
    /**
     * Choose, which Affiliate to update.
     */
    where: AffiliateWhereUniqueInput
  }

  /**
   * Affiliate updateMany
   */
  export type AffiliateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Affiliates.
     */
    data: XOR<AffiliateUpdateManyMutationInput, AffiliateUncheckedUpdateManyInput>
    /**
     * Filter which Affiliates to update
     */
    where?: AffiliateWhereInput
  }

  /**
   * Affiliate upsert
   */
  export type AffiliateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * The filter to search for the Affiliate to update in case it exists.
     */
    where: AffiliateWhereUniqueInput
    /**
     * In case the Affiliate found by the `where` argument doesn't exist, create a new Affiliate with this data.
     */
    create: XOR<AffiliateCreateInput, AffiliateUncheckedCreateInput>
    /**
     * In case the Affiliate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateUpdateInput, AffiliateUncheckedUpdateInput>
  }

  /**
   * Affiliate delete
   */
  export type AffiliateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    /**
     * Filter which Affiliate to delete.
     */
    where: AffiliateWhereUniqueInput
  }

  /**
   * Affiliate deleteMany
   */
  export type AffiliateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliates to delete
     */
    where?: AffiliateWhereInput
  }

  /**
   * Affiliate.commissions
   */
  export type Affiliate$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    where?: CommissionWhereInput
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    cursor?: CommissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * Affiliate without action
   */
  export type AffiliateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
  }


  /**
   * Model CoachMessage
   */

  export type AggregateCoachMessage = {
    _count: CoachMessageCountAggregateOutputType | null
    _avg: CoachMessageAvgAggregateOutputType | null
    _sum: CoachMessageSumAggregateOutputType | null
    _min: CoachMessageMinAggregateOutputType | null
    _max: CoachMessageMaxAggregateOutputType | null
  }

  export type CoachMessageAvgAggregateOutputType = {
    attachmentSize: number | null
  }

  export type CoachMessageSumAggregateOutputType = {
    attachmentSize: number | null
  }

  export type CoachMessageMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    userId: string | null
    sender: string | null
    body: string | null
    attachmentUrl: string | null
    attachmentName: string | null
    attachmentType: string | null
    attachmentSize: number | null
    createdAt: Date | null
  }

  export type CoachMessageMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    userId: string | null
    sender: string | null
    body: string | null
    attachmentUrl: string | null
    attachmentName: string | null
    attachmentType: string | null
    attachmentSize: number | null
    createdAt: Date | null
  }

  export type CoachMessageCountAggregateOutputType = {
    id: number
    coachId: number
    userId: number
    sender: number
    body: number
    attachmentUrl: number
    attachmentName: number
    attachmentType: number
    attachmentSize: number
    createdAt: number
    _all: number
  }


  export type CoachMessageAvgAggregateInputType = {
    attachmentSize?: true
  }

  export type CoachMessageSumAggregateInputType = {
    attachmentSize?: true
  }

  export type CoachMessageMinAggregateInputType = {
    id?: true
    coachId?: true
    userId?: true
    sender?: true
    body?: true
    attachmentUrl?: true
    attachmentName?: true
    attachmentType?: true
    attachmentSize?: true
    createdAt?: true
  }

  export type CoachMessageMaxAggregateInputType = {
    id?: true
    coachId?: true
    userId?: true
    sender?: true
    body?: true
    attachmentUrl?: true
    attachmentName?: true
    attachmentType?: true
    attachmentSize?: true
    createdAt?: true
  }

  export type CoachMessageCountAggregateInputType = {
    id?: true
    coachId?: true
    userId?: true
    sender?: true
    body?: true
    attachmentUrl?: true
    attachmentName?: true
    attachmentType?: true
    attachmentSize?: true
    createdAt?: true
    _all?: true
  }

  export type CoachMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachMessage to aggregate.
     */
    where?: CoachMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachMessages to fetch.
     */
    orderBy?: CoachMessageOrderByWithRelationInput | CoachMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachMessages
    **/
    _count?: true | CoachMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoachMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoachMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachMessageMaxAggregateInputType
  }

  export type GetCoachMessageAggregateType<T extends CoachMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachMessage[P]>
      : GetScalarType<T[P], AggregateCoachMessage[P]>
  }




  export type CoachMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachMessageWhereInput
    orderBy?: CoachMessageOrderByWithAggregationInput | CoachMessageOrderByWithAggregationInput[]
    by: CoachMessageScalarFieldEnum[] | CoachMessageScalarFieldEnum
    having?: CoachMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachMessageCountAggregateInputType | true
    _avg?: CoachMessageAvgAggregateInputType
    _sum?: CoachMessageSumAggregateInputType
    _min?: CoachMessageMinAggregateInputType
    _max?: CoachMessageMaxAggregateInputType
  }

  export type CoachMessageGroupByOutputType = {
    id: string
    coachId: string
    userId: string
    sender: string
    body: string | null
    attachmentUrl: string | null
    attachmentName: string | null
    attachmentType: string | null
    attachmentSize: number | null
    createdAt: Date
    _count: CoachMessageCountAggregateOutputType | null
    _avg: CoachMessageAvgAggregateOutputType | null
    _sum: CoachMessageSumAggregateOutputType | null
    _min: CoachMessageMinAggregateOutputType | null
    _max: CoachMessageMaxAggregateOutputType | null
  }

  type GetCoachMessageGroupByPayload<T extends CoachMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachMessageGroupByOutputType[P]>
            : GetScalarType<T[P], CoachMessageGroupByOutputType[P]>
        }
      >
    >


  export type CoachMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    userId?: boolean
    sender?: boolean
    body?: boolean
    attachmentUrl?: boolean
    attachmentName?: boolean
    attachmentType?: boolean
    attachmentSize?: boolean
    createdAt?: boolean
    coach?: boolean | CoachDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachMessage"]>

  export type CoachMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    userId?: boolean
    sender?: boolean
    body?: boolean
    attachmentUrl?: boolean
    attachmentName?: boolean
    attachmentType?: boolean
    attachmentSize?: boolean
    createdAt?: boolean
    coach?: boolean | CoachDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachMessage"]>

  export type CoachMessageSelectScalar = {
    id?: boolean
    coachId?: boolean
    userId?: boolean
    sender?: boolean
    body?: boolean
    attachmentUrl?: boolean
    attachmentName?: boolean
    attachmentType?: boolean
    attachmentSize?: boolean
    createdAt?: boolean
  }

  export type CoachMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CoachMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoachMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachMessage"
    objects: {
      coach: Prisma.$CoachPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      userId: string
      sender: string
      body: string | null
      attachmentUrl: string | null
      attachmentName: string | null
      attachmentType: string | null
      attachmentSize: number | null
      createdAt: Date
    }, ExtArgs["result"]["coachMessage"]>
    composites: {}
  }

  type CoachMessageGetPayload<S extends boolean | null | undefined | CoachMessageDefaultArgs> = $Result.GetResult<Prisma.$CoachMessagePayload, S>

  type CoachMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoachMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoachMessageCountAggregateInputType | true
    }

  export interface CoachMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachMessage'], meta: { name: 'CoachMessage' } }
    /**
     * Find zero or one CoachMessage that matches the filter.
     * @param {CoachMessageFindUniqueArgs} args - Arguments to find a CoachMessage
     * @example
     * // Get one CoachMessage
     * const coachMessage = await prisma.coachMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachMessageFindUniqueArgs>(args: SelectSubset<T, CoachMessageFindUniqueArgs<ExtArgs>>): Prisma__CoachMessageClient<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CoachMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoachMessageFindUniqueOrThrowArgs} args - Arguments to find a CoachMessage
     * @example
     * // Get one CoachMessage
     * const coachMessage = await prisma.coachMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachMessageClient<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CoachMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachMessageFindFirstArgs} args - Arguments to find a CoachMessage
     * @example
     * // Get one CoachMessage
     * const coachMessage = await prisma.coachMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachMessageFindFirstArgs>(args?: SelectSubset<T, CoachMessageFindFirstArgs<ExtArgs>>): Prisma__CoachMessageClient<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CoachMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachMessageFindFirstOrThrowArgs} args - Arguments to find a CoachMessage
     * @example
     * // Get one CoachMessage
     * const coachMessage = await prisma.coachMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachMessageClient<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CoachMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachMessages
     * const coachMessages = await prisma.coachMessage.findMany()
     * 
     * // Get first 10 CoachMessages
     * const coachMessages = await prisma.coachMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachMessageWithIdOnly = await prisma.coachMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachMessageFindManyArgs>(args?: SelectSubset<T, CoachMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CoachMessage.
     * @param {CoachMessageCreateArgs} args - Arguments to create a CoachMessage.
     * @example
     * // Create one CoachMessage
     * const CoachMessage = await prisma.coachMessage.create({
     *   data: {
     *     // ... data to create a CoachMessage
     *   }
     * })
     * 
     */
    create<T extends CoachMessageCreateArgs>(args: SelectSubset<T, CoachMessageCreateArgs<ExtArgs>>): Prisma__CoachMessageClient<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CoachMessages.
     * @param {CoachMessageCreateManyArgs} args - Arguments to create many CoachMessages.
     * @example
     * // Create many CoachMessages
     * const coachMessage = await prisma.coachMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachMessageCreateManyArgs>(args?: SelectSubset<T, CoachMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachMessages and returns the data saved in the database.
     * @param {CoachMessageCreateManyAndReturnArgs} args - Arguments to create many CoachMessages.
     * @example
     * // Create many CoachMessages
     * const coachMessage = await prisma.coachMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachMessages and only return the `id`
     * const coachMessageWithIdOnly = await prisma.coachMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CoachMessage.
     * @param {CoachMessageDeleteArgs} args - Arguments to delete one CoachMessage.
     * @example
     * // Delete one CoachMessage
     * const CoachMessage = await prisma.coachMessage.delete({
     *   where: {
     *     // ... filter to delete one CoachMessage
     *   }
     * })
     * 
     */
    delete<T extends CoachMessageDeleteArgs>(args: SelectSubset<T, CoachMessageDeleteArgs<ExtArgs>>): Prisma__CoachMessageClient<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CoachMessage.
     * @param {CoachMessageUpdateArgs} args - Arguments to update one CoachMessage.
     * @example
     * // Update one CoachMessage
     * const coachMessage = await prisma.coachMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachMessageUpdateArgs>(args: SelectSubset<T, CoachMessageUpdateArgs<ExtArgs>>): Prisma__CoachMessageClient<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CoachMessages.
     * @param {CoachMessageDeleteManyArgs} args - Arguments to filter CoachMessages to delete.
     * @example
     * // Delete a few CoachMessages
     * const { count } = await prisma.coachMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachMessageDeleteManyArgs>(args?: SelectSubset<T, CoachMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachMessages
     * const coachMessage = await prisma.coachMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachMessageUpdateManyArgs>(args: SelectSubset<T, CoachMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoachMessage.
     * @param {CoachMessageUpsertArgs} args - Arguments to update or create a CoachMessage.
     * @example
     * // Update or create a CoachMessage
     * const coachMessage = await prisma.coachMessage.upsert({
     *   create: {
     *     // ... data to create a CoachMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachMessage we want to update
     *   }
     * })
     */
    upsert<T extends CoachMessageUpsertArgs>(args: SelectSubset<T, CoachMessageUpsertArgs<ExtArgs>>): Prisma__CoachMessageClient<$Result.GetResult<Prisma.$CoachMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CoachMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachMessageCountArgs} args - Arguments to filter CoachMessages to count.
     * @example
     * // Count the number of CoachMessages
     * const count = await prisma.coachMessage.count({
     *   where: {
     *     // ... the filter for the CoachMessages we want to count
     *   }
     * })
    **/
    count<T extends CoachMessageCountArgs>(
      args?: Subset<T, CoachMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachMessageAggregateArgs>(args: Subset<T, CoachMessageAggregateArgs>): Prisma.PrismaPromise<GetCoachMessageAggregateType<T>>

    /**
     * Group by CoachMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachMessageGroupByArgs['orderBy'] }
        : { orderBy?: CoachMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachMessage model
   */
  readonly fields: CoachMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachDefaultArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachMessage model
   */ 
  interface CoachMessageFieldRefs {
    readonly id: FieldRef<"CoachMessage", 'String'>
    readonly coachId: FieldRef<"CoachMessage", 'String'>
    readonly userId: FieldRef<"CoachMessage", 'String'>
    readonly sender: FieldRef<"CoachMessage", 'String'>
    readonly body: FieldRef<"CoachMessage", 'String'>
    readonly attachmentUrl: FieldRef<"CoachMessage", 'String'>
    readonly attachmentName: FieldRef<"CoachMessage", 'String'>
    readonly attachmentType: FieldRef<"CoachMessage", 'String'>
    readonly attachmentSize: FieldRef<"CoachMessage", 'Int'>
    readonly createdAt: FieldRef<"CoachMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachMessage findUnique
   */
  export type CoachMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    /**
     * Filter, which CoachMessage to fetch.
     */
    where: CoachMessageWhereUniqueInput
  }

  /**
   * CoachMessage findUniqueOrThrow
   */
  export type CoachMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    /**
     * Filter, which CoachMessage to fetch.
     */
    where: CoachMessageWhereUniqueInput
  }

  /**
   * CoachMessage findFirst
   */
  export type CoachMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    /**
     * Filter, which CoachMessage to fetch.
     */
    where?: CoachMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachMessages to fetch.
     */
    orderBy?: CoachMessageOrderByWithRelationInput | CoachMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachMessages.
     */
    cursor?: CoachMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachMessages.
     */
    distinct?: CoachMessageScalarFieldEnum | CoachMessageScalarFieldEnum[]
  }

  /**
   * CoachMessage findFirstOrThrow
   */
  export type CoachMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    /**
     * Filter, which CoachMessage to fetch.
     */
    where?: CoachMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachMessages to fetch.
     */
    orderBy?: CoachMessageOrderByWithRelationInput | CoachMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachMessages.
     */
    cursor?: CoachMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachMessages.
     */
    distinct?: CoachMessageScalarFieldEnum | CoachMessageScalarFieldEnum[]
  }

  /**
   * CoachMessage findMany
   */
  export type CoachMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    /**
     * Filter, which CoachMessages to fetch.
     */
    where?: CoachMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachMessages to fetch.
     */
    orderBy?: CoachMessageOrderByWithRelationInput | CoachMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachMessages.
     */
    cursor?: CoachMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachMessages.
     */
    skip?: number
    distinct?: CoachMessageScalarFieldEnum | CoachMessageScalarFieldEnum[]
  }

  /**
   * CoachMessage create
   */
  export type CoachMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachMessage.
     */
    data: XOR<CoachMessageCreateInput, CoachMessageUncheckedCreateInput>
  }

  /**
   * CoachMessage createMany
   */
  export type CoachMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachMessages.
     */
    data: CoachMessageCreateManyInput | CoachMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoachMessage createManyAndReturn
   */
  export type CoachMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CoachMessages.
     */
    data: CoachMessageCreateManyInput | CoachMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachMessage update
   */
  export type CoachMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachMessage.
     */
    data: XOR<CoachMessageUpdateInput, CoachMessageUncheckedUpdateInput>
    /**
     * Choose, which CoachMessage to update.
     */
    where: CoachMessageWhereUniqueInput
  }

  /**
   * CoachMessage updateMany
   */
  export type CoachMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachMessages.
     */
    data: XOR<CoachMessageUpdateManyMutationInput, CoachMessageUncheckedUpdateManyInput>
    /**
     * Filter which CoachMessages to update
     */
    where?: CoachMessageWhereInput
  }

  /**
   * CoachMessage upsert
   */
  export type CoachMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachMessage to update in case it exists.
     */
    where: CoachMessageWhereUniqueInput
    /**
     * In case the CoachMessage found by the `where` argument doesn't exist, create a new CoachMessage with this data.
     */
    create: XOR<CoachMessageCreateInput, CoachMessageUncheckedCreateInput>
    /**
     * In case the CoachMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachMessageUpdateInput, CoachMessageUncheckedUpdateInput>
  }

  /**
   * CoachMessage delete
   */
  export type CoachMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
    /**
     * Filter which CoachMessage to delete.
     */
    where: CoachMessageWhereUniqueInput
  }

  /**
   * CoachMessage deleteMany
   */
  export type CoachMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachMessages to delete
     */
    where?: CoachMessageWhereInput
  }

  /**
   * CoachMessage without action
   */
  export type CoachMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachMessage
     */
    select?: CoachMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachMessageInclude<ExtArgs> | null
  }


  /**
   * Model Commission
   */

  export type AggregateCommission = {
    _count: CommissionCountAggregateOutputType | null
    _avg: CommissionAvgAggregateOutputType | null
    _sum: CommissionSumAggregateOutputType | null
    _min: CommissionMinAggregateOutputType | null
    _max: CommissionMaxAggregateOutputType | null
  }

  export type CommissionAvgAggregateOutputType = {
    amount: number | null
  }

  export type CommissionSumAggregateOutputType = {
    amount: number | null
  }

  export type CommissionMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    orderId: string | null
    affiliateId: string | null
    amount: number | null
    createdAt: Date | null
    userId: string | null
  }

  export type CommissionMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    orderId: string | null
    affiliateId: string | null
    amount: number | null
    createdAt: Date | null
    userId: string | null
  }

  export type CommissionCountAggregateOutputType = {
    id: number
    coachId: number
    orderId: number
    affiliateId: number
    amount: number
    createdAt: number
    userId: number
    _all: number
  }


  export type CommissionAvgAggregateInputType = {
    amount?: true
  }

  export type CommissionSumAggregateInputType = {
    amount?: true
  }

  export type CommissionMinAggregateInputType = {
    id?: true
    coachId?: true
    orderId?: true
    affiliateId?: true
    amount?: true
    createdAt?: true
    userId?: true
  }

  export type CommissionMaxAggregateInputType = {
    id?: true
    coachId?: true
    orderId?: true
    affiliateId?: true
    amount?: true
    createdAt?: true
    userId?: true
  }

  export type CommissionCountAggregateInputType = {
    id?: true
    coachId?: true
    orderId?: true
    affiliateId?: true
    amount?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type CommissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commission to aggregate.
     */
    where?: CommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commissions
    **/
    _count?: true | CommissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommissionMaxAggregateInputType
  }

  export type GetCommissionAggregateType<T extends CommissionAggregateArgs> = {
        [P in keyof T & keyof AggregateCommission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommission[P]>
      : GetScalarType<T[P], AggregateCommission[P]>
  }




  export type CommissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionWhereInput
    orderBy?: CommissionOrderByWithAggregationInput | CommissionOrderByWithAggregationInput[]
    by: CommissionScalarFieldEnum[] | CommissionScalarFieldEnum
    having?: CommissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommissionCountAggregateInputType | true
    _avg?: CommissionAvgAggregateInputType
    _sum?: CommissionSumAggregateInputType
    _min?: CommissionMinAggregateInputType
    _max?: CommissionMaxAggregateInputType
  }

  export type CommissionGroupByOutputType = {
    id: string
    coachId: string
    orderId: string
    affiliateId: string | null
    amount: number
    createdAt: Date
    userId: string | null
    _count: CommissionCountAggregateOutputType | null
    _avg: CommissionAvgAggregateOutputType | null
    _sum: CommissionSumAggregateOutputType | null
    _min: CommissionMinAggregateOutputType | null
    _max: CommissionMaxAggregateOutputType | null
  }

  type GetCommissionGroupByPayload<T extends CommissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommissionGroupByOutputType[P]>
            : GetScalarType<T[P], CommissionGroupByOutputType[P]>
        }
      >
    >


  export type CommissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    orderId?: boolean
    affiliateId?: boolean
    amount?: boolean
    createdAt?: boolean
    userId?: boolean
    coach?: boolean | CoachDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    affiliate?: boolean | Commission$affiliateArgs<ExtArgs>
    User?: boolean | Commission$UserArgs<ExtArgs>
  }, ExtArgs["result"]["commission"]>

  export type CommissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    orderId?: boolean
    affiliateId?: boolean
    amount?: boolean
    createdAt?: boolean
    userId?: boolean
    coach?: boolean | CoachDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    affiliate?: boolean | Commission$affiliateArgs<ExtArgs>
    User?: boolean | Commission$UserArgs<ExtArgs>
  }, ExtArgs["result"]["commission"]>

  export type CommissionSelectScalar = {
    id?: boolean
    coachId?: boolean
    orderId?: boolean
    affiliateId?: boolean
    amount?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type CommissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    affiliate?: boolean | Commission$affiliateArgs<ExtArgs>
    User?: boolean | Commission$UserArgs<ExtArgs>
  }
  export type CommissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    affiliate?: boolean | Commission$affiliateArgs<ExtArgs>
    User?: boolean | Commission$UserArgs<ExtArgs>
  }

  export type $CommissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commission"
    objects: {
      coach: Prisma.$CoachPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      affiliate: Prisma.$AffiliatePayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      orderId: string
      affiliateId: string | null
      amount: number
      createdAt: Date
      userId: string | null
    }, ExtArgs["result"]["commission"]>
    composites: {}
  }

  type CommissionGetPayload<S extends boolean | null | undefined | CommissionDefaultArgs> = $Result.GetResult<Prisma.$CommissionPayload, S>

  type CommissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommissionCountAggregateInputType | true
    }

  export interface CommissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commission'], meta: { name: 'Commission' } }
    /**
     * Find zero or one Commission that matches the filter.
     * @param {CommissionFindUniqueArgs} args - Arguments to find a Commission
     * @example
     * // Get one Commission
     * const commission = await prisma.commission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommissionFindUniqueArgs>(args: SelectSubset<T, CommissionFindUniqueArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Commission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommissionFindUniqueOrThrowArgs} args - Arguments to find a Commission
     * @example
     * // Get one Commission
     * const commission = await prisma.commission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommissionFindUniqueOrThrowArgs>(args: SelectSubset<T, CommissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Commission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionFindFirstArgs} args - Arguments to find a Commission
     * @example
     * // Get one Commission
     * const commission = await prisma.commission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommissionFindFirstArgs>(args?: SelectSubset<T, CommissionFindFirstArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Commission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionFindFirstOrThrowArgs} args - Arguments to find a Commission
     * @example
     * // Get one Commission
     * const commission = await prisma.commission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommissionFindFirstOrThrowArgs>(args?: SelectSubset<T, CommissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Commissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commissions
     * const commissions = await prisma.commission.findMany()
     * 
     * // Get first 10 Commissions
     * const commissions = await prisma.commission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commissionWithIdOnly = await prisma.commission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommissionFindManyArgs>(args?: SelectSubset<T, CommissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Commission.
     * @param {CommissionCreateArgs} args - Arguments to create a Commission.
     * @example
     * // Create one Commission
     * const Commission = await prisma.commission.create({
     *   data: {
     *     // ... data to create a Commission
     *   }
     * })
     * 
     */
    create<T extends CommissionCreateArgs>(args: SelectSubset<T, CommissionCreateArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Commissions.
     * @param {CommissionCreateManyArgs} args - Arguments to create many Commissions.
     * @example
     * // Create many Commissions
     * const commission = await prisma.commission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommissionCreateManyArgs>(args?: SelectSubset<T, CommissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commissions and returns the data saved in the database.
     * @param {CommissionCreateManyAndReturnArgs} args - Arguments to create many Commissions.
     * @example
     * // Create many Commissions
     * const commission = await prisma.commission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commissions and only return the `id`
     * const commissionWithIdOnly = await prisma.commission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommissionCreateManyAndReturnArgs>(args?: SelectSubset<T, CommissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Commission.
     * @param {CommissionDeleteArgs} args - Arguments to delete one Commission.
     * @example
     * // Delete one Commission
     * const Commission = await prisma.commission.delete({
     *   where: {
     *     // ... filter to delete one Commission
     *   }
     * })
     * 
     */
    delete<T extends CommissionDeleteArgs>(args: SelectSubset<T, CommissionDeleteArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Commission.
     * @param {CommissionUpdateArgs} args - Arguments to update one Commission.
     * @example
     * // Update one Commission
     * const commission = await prisma.commission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommissionUpdateArgs>(args: SelectSubset<T, CommissionUpdateArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Commissions.
     * @param {CommissionDeleteManyArgs} args - Arguments to filter Commissions to delete.
     * @example
     * // Delete a few Commissions
     * const { count } = await prisma.commission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommissionDeleteManyArgs>(args?: SelectSubset<T, CommissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commissions
     * const commission = await prisma.commission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommissionUpdateManyArgs>(args: SelectSubset<T, CommissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commission.
     * @param {CommissionUpsertArgs} args - Arguments to update or create a Commission.
     * @example
     * // Update or create a Commission
     * const commission = await prisma.commission.upsert({
     *   create: {
     *     // ... data to create a Commission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commission we want to update
     *   }
     * })
     */
    upsert<T extends CommissionUpsertArgs>(args: SelectSubset<T, CommissionUpsertArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Commissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionCountArgs} args - Arguments to filter Commissions to count.
     * @example
     * // Count the number of Commissions
     * const count = await prisma.commission.count({
     *   where: {
     *     // ... the filter for the Commissions we want to count
     *   }
     * })
    **/
    count<T extends CommissionCountArgs>(
      args?: Subset<T, CommissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommissionAggregateArgs>(args: Subset<T, CommissionAggregateArgs>): Prisma.PrismaPromise<GetCommissionAggregateType<T>>

    /**
     * Group by Commission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommissionGroupByArgs['orderBy'] }
        : { orderBy?: CommissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commission model
   */
  readonly fields: CommissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachDefaultArgs<ExtArgs>>): Prisma__CoachClient<$Result.GetResult<Prisma.$CoachPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    affiliate<T extends Commission$affiliateArgs<ExtArgs> = {}>(args?: Subset<T, Commission$affiliateArgs<ExtArgs>>): Prisma__AffiliateClient<$Result.GetResult<Prisma.$AffiliatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    User<T extends Commission$UserArgs<ExtArgs> = {}>(args?: Subset<T, Commission$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Commission model
   */ 
  interface CommissionFieldRefs {
    readonly id: FieldRef<"Commission", 'String'>
    readonly coachId: FieldRef<"Commission", 'String'>
    readonly orderId: FieldRef<"Commission", 'String'>
    readonly affiliateId: FieldRef<"Commission", 'String'>
    readonly amount: FieldRef<"Commission", 'Float'>
    readonly createdAt: FieldRef<"Commission", 'DateTime'>
    readonly userId: FieldRef<"Commission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Commission findUnique
   */
  export type CommissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter, which Commission to fetch.
     */
    where: CommissionWhereUniqueInput
  }

  /**
   * Commission findUniqueOrThrow
   */
  export type CommissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter, which Commission to fetch.
     */
    where: CommissionWhereUniqueInput
  }

  /**
   * Commission findFirst
   */
  export type CommissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter, which Commission to fetch.
     */
    where?: CommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commissions.
     */
    cursor?: CommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commissions.
     */
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * Commission findFirstOrThrow
   */
  export type CommissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter, which Commission to fetch.
     */
    where?: CommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commissions.
     */
    cursor?: CommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commissions.
     */
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * Commission findMany
   */
  export type CommissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter, which Commissions to fetch.
     */
    where?: CommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commissions.
     */
    cursor?: CommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * Commission create
   */
  export type CommissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Commission.
     */
    data: XOR<CommissionCreateInput, CommissionUncheckedCreateInput>
  }

  /**
   * Commission createMany
   */
  export type CommissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commissions.
     */
    data: CommissionCreateManyInput | CommissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commission createManyAndReturn
   */
  export type CommissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Commissions.
     */
    data: CommissionCreateManyInput | CommissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Commission update
   */
  export type CommissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Commission.
     */
    data: XOR<CommissionUpdateInput, CommissionUncheckedUpdateInput>
    /**
     * Choose, which Commission to update.
     */
    where: CommissionWhereUniqueInput
  }

  /**
   * Commission updateMany
   */
  export type CommissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commissions.
     */
    data: XOR<CommissionUpdateManyMutationInput, CommissionUncheckedUpdateManyInput>
    /**
     * Filter which Commissions to update
     */
    where?: CommissionWhereInput
  }

  /**
   * Commission upsert
   */
  export type CommissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Commission to update in case it exists.
     */
    where: CommissionWhereUniqueInput
    /**
     * In case the Commission found by the `where` argument doesn't exist, create a new Commission with this data.
     */
    create: XOR<CommissionCreateInput, CommissionUncheckedCreateInput>
    /**
     * In case the Commission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommissionUpdateInput, CommissionUncheckedUpdateInput>
  }

  /**
   * Commission delete
   */
  export type CommissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter which Commission to delete.
     */
    where: CommissionWhereUniqueInput
  }

  /**
   * Commission deleteMany
   */
  export type CommissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commissions to delete
     */
    where?: CommissionWhereInput
  }

  /**
   * Commission.affiliate
   */
  export type Commission$affiliateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliate
     */
    select?: AffiliateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateInclude<ExtArgs> | null
    where?: AffiliateWhereInput
  }

  /**
   * Commission.User
   */
  export type Commission$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Commission without action
   */
  export type CommissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
  }


  /**
   * Model Analytics
   */

  export type AggregateAnalytics = {
    _count: AnalyticsCountAggregateOutputType | null
    _avg: AnalyticsAvgAggregateOutputType | null
    _sum: AnalyticsSumAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  export type AnalyticsAvgAggregateOutputType = {
    revenue: number | null
    engagement: number | null
    supplementSales: number | null
  }

  export type AnalyticsSumAggregateOutputType = {
    revenue: number | null
    engagement: number | null
    supplementSales: number | null
  }

  export type AnalyticsMinAggregateOutputType = {
    id: string | null
    date: Date | null
    revenue: number | null
    engagement: number | null
    supplementSales: number | null
  }

  export type AnalyticsMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    revenue: number | null
    engagement: number | null
    supplementSales: number | null
  }

  export type AnalyticsCountAggregateOutputType = {
    id: number
    date: number
    revenue: number
    engagement: number
    supplementSales: number
    _all: number
  }


  export type AnalyticsAvgAggregateInputType = {
    revenue?: true
    engagement?: true
    supplementSales?: true
  }

  export type AnalyticsSumAggregateInputType = {
    revenue?: true
    engagement?: true
    supplementSales?: true
  }

  export type AnalyticsMinAggregateInputType = {
    id?: true
    date?: true
    revenue?: true
    engagement?: true
    supplementSales?: true
  }

  export type AnalyticsMaxAggregateInputType = {
    id?: true
    date?: true
    revenue?: true
    engagement?: true
    supplementSales?: true
  }

  export type AnalyticsCountAggregateInputType = {
    id?: true
    date?: true
    revenue?: true
    engagement?: true
    supplementSales?: true
    _all?: true
  }

  export type AnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to aggregate.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Analytics
    **/
    _count?: true | AnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsMaxAggregateInputType
  }

  export type GetAnalyticsAggregateType<T extends AnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalytics[P]>
      : GetScalarType<T[P], AggregateAnalytics[P]>
  }




  export type AnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsWhereInput
    orderBy?: AnalyticsOrderByWithAggregationInput | AnalyticsOrderByWithAggregationInput[]
    by: AnalyticsScalarFieldEnum[] | AnalyticsScalarFieldEnum
    having?: AnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsCountAggregateInputType | true
    _avg?: AnalyticsAvgAggregateInputType
    _sum?: AnalyticsSumAggregateInputType
    _min?: AnalyticsMinAggregateInputType
    _max?: AnalyticsMaxAggregateInputType
  }

  export type AnalyticsGroupByOutputType = {
    id: string
    date: Date
    revenue: number
    engagement: number
    supplementSales: number
    _count: AnalyticsCountAggregateOutputType | null
    _avg: AnalyticsAvgAggregateOutputType | null
    _sum: AnalyticsSumAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  type GetAnalyticsGroupByPayload<T extends AnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    revenue?: boolean
    engagement?: boolean
    supplementSales?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    revenue?: boolean
    engagement?: boolean
    supplementSales?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectScalar = {
    id?: boolean
    date?: boolean
    revenue?: boolean
    engagement?: boolean
    supplementSales?: boolean
  }


  export type $AnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Analytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      revenue: number
      engagement: number
      supplementSales: number
    }, ExtArgs["result"]["analytics"]>
    composites: {}
  }

  type AnalyticsGetPayload<S extends boolean | null | undefined | AnalyticsDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsPayload, S>

  type AnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalyticsCountAggregateInputType | true
    }

  export interface AnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Analytics'], meta: { name: 'Analytics' } }
    /**
     * Find zero or one Analytics that matches the filter.
     * @param {AnalyticsFindUniqueArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsFindUniqueArgs>(args: SelectSubset<T, AnalyticsFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Analytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnalyticsFindUniqueOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsFindFirstArgs>(args?: SelectSubset<T, AnalyticsFindFirstArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analytics
     * const analytics = await prisma.analytics.findMany()
     * 
     * // Get first 10 Analytics
     * const analytics = await prisma.analytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsWithIdOnly = await prisma.analytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsFindManyArgs>(args?: SelectSubset<T, AnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Analytics.
     * @param {AnalyticsCreateArgs} args - Arguments to create a Analytics.
     * @example
     * // Create one Analytics
     * const Analytics = await prisma.analytics.create({
     *   data: {
     *     // ... data to create a Analytics
     *   }
     * })
     * 
     */
    create<T extends AnalyticsCreateArgs>(args: SelectSubset<T, AnalyticsCreateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Analytics.
     * @param {AnalyticsCreateManyArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsCreateManyArgs>(args?: SelectSubset<T, AnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analytics and returns the data saved in the database.
     * @param {AnalyticsCreateManyAndReturnArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Analytics.
     * @param {AnalyticsDeleteArgs} args - Arguments to delete one Analytics.
     * @example
     * // Delete one Analytics
     * const Analytics = await prisma.analytics.delete({
     *   where: {
     *     // ... filter to delete one Analytics
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsDeleteArgs>(args: SelectSubset<T, AnalyticsDeleteArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Analytics.
     * @param {AnalyticsUpdateArgs} args - Arguments to update one Analytics.
     * @example
     * // Update one Analytics
     * const analytics = await prisma.analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsUpdateArgs>(args: SelectSubset<T, AnalyticsUpdateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Analytics.
     * @param {AnalyticsDeleteManyArgs} args - Arguments to filter Analytics to delete.
     * @example
     * // Delete a few Analytics
     * const { count } = await prisma.analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsDeleteManyArgs>(args?: SelectSubset<T, AnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsUpdateManyArgs>(args: SelectSubset<T, AnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Analytics.
     * @param {AnalyticsUpsertArgs} args - Arguments to update or create a Analytics.
     * @example
     * // Update or create a Analytics
     * const analytics = await prisma.analytics.upsert({
     *   create: {
     *     // ... data to create a Analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analytics we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsUpsertArgs>(args: SelectSubset<T, AnalyticsUpsertArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCountArgs} args - Arguments to filter Analytics to count.
     * @example
     * // Count the number of Analytics
     * const count = await prisma.analytics.count({
     *   where: {
     *     // ... the filter for the Analytics we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsCountArgs>(
      args?: Subset<T, AnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsAggregateArgs>(args: Subset<T, AnalyticsAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsAggregateType<T>>

    /**
     * Group by Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Analytics model
   */
  readonly fields: AnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Analytics model
   */ 
  interface AnalyticsFieldRefs {
    readonly id: FieldRef<"Analytics", 'String'>
    readonly date: FieldRef<"Analytics", 'DateTime'>
    readonly revenue: FieldRef<"Analytics", 'Float'>
    readonly engagement: FieldRef<"Analytics", 'Int'>
    readonly supplementSales: FieldRef<"Analytics", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Analytics findUnique
   */
  export type AnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findUniqueOrThrow
   */
  export type AnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findFirst
   */
  export type AnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findFirstOrThrow
   */
  export type AnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findMany
   */
  export type AnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics create
   */
  export type AnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to create a Analytics.
     */
    data?: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
  }

  /**
   * Analytics createMany
   */
  export type AnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics createManyAndReturn
   */
  export type AnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics update
   */
  export type AnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to update a Analytics.
     */
    data: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
    /**
     * Choose, which Analytics to update.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics updateMany
   */
  export type AnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
  }

  /**
   * Analytics upsert
   */
  export type AnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * The filter to search for the Analytics to update in case it exists.
     */
    where: AnalyticsWhereUniqueInput
    /**
     * In case the Analytics found by the `where` argument doesn't exist, create a new Analytics with this data.
     */
    create: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
    /**
     * In case the Analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
  }

  /**
   * Analytics delete
   */
  export type AnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Filter which Analytics to delete.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics deleteMany
   */
  export type AnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to delete
     */
    where?: AnalyticsWhereInput
  }

  /**
   * Analytics without action
   */
  export type AnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    description: string | null
    achievedAt: Date | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    description: string | null
    achievedAt: Date | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    description: number
    achievedAt: number
    _all: number
  }


  export type MilestoneMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    achievedAt?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    achievedAt?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    achievedAt?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    userId: string
    type: string
    description: string | null
    achievedAt: Date | null
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    achievedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    achievedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    achievedAt?: boolean
  }

  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      description: string | null
      achievedAt: Date | null
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Milestones and returns the data saved in the database.
     * @param {MilestoneCreateManyAndReturnArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, MilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */ 
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly userId: FieldRef<"Milestone", 'String'>
    readonly type: FieldRef<"Milestone", 'String'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly achievedAt: FieldRef<"Milestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Milestone createManyAndReturn
   */
  export type MilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
    amountCents: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
    amountCents: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    orderId: string | null
    subscriptionId: string | null
    amount: number | null
    amountCents: number | null
    currency: string | null
    status: string | null
    provider: string | null
    providerId: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    orderId: string | null
    subscriptionId: string | null
    amount: number | null
    amountCents: number | null
    currency: string | null
    status: string | null
    provider: string | null
    providerId: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    orderId: number
    subscriptionId: number
    amount: number
    amountCents: number
    currency: number
    status: number
    provider: number
    providerId: number
    raw: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    amountCents?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    amountCents?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    subscriptionId?: true
    amount?: true
    amountCents?: true
    currency?: true
    status?: true
    provider?: true
    providerId?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    subscriptionId?: true
    amount?: true
    amountCents?: true
    currency?: true
    status?: true
    provider?: true
    providerId?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    orderId?: true
    subscriptionId?: true
    amount?: true
    amountCents?: true
    currency?: true
    status?: true
    provider?: true
    providerId?: true
    raw?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    orderId: string | null
    subscriptionId: string | null
    amount: number | null
    amountCents: number
    currency: string
    status: string
    provider: string
    providerId: string | null
    raw: JsonValue | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    provider?: boolean
    providerId?: boolean
    raw?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    provider?: boolean
    providerId?: boolean
    raw?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    orderId?: boolean
    subscriptionId?: boolean
    amount?: boolean
    amountCents?: boolean
    currency?: boolean
    status?: boolean
    provider?: boolean
    providerId?: boolean
    raw?: boolean
    createdAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
    subscription?: boolean | Payment$subscriptionArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      orderId: string | null
      subscriptionId: string | null
      amount: number | null
      amountCents: number
      currency: string
      status: string
      provider: string
      providerId: string | null
      raw: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    order<T extends Payment$orderArgs<ExtArgs> = {}>(args?: Subset<T, Payment$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subscription<T extends Payment$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Payment$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly subscriptionId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly amountCents: FieldRef<"Payment", 'Int'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly provider: FieldRef<"Payment", 'String'>
    readonly providerId: FieldRef<"Payment", 'String'>
    readonly raw: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.order
   */
  export type Payment$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Payment.subscription
   */
  export type Payment$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model WebhookEvent
   */

  export type AggregateWebhookEvent = {
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  export type WebhookEventMinAggregateOutputType = {
    id: string | null
    provider: string | null
    eventId: string | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type WebhookEventMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    eventId: string | null
    processed: boolean | null
    createdAt: Date | null
  }

  export type WebhookEventCountAggregateOutputType = {
    id: number
    provider: number
    eventId: number
    payload: number
    processed: number
    createdAt: number
    _all: number
  }


  export type WebhookEventMinAggregateInputType = {
    id?: true
    provider?: true
    eventId?: true
    processed?: true
    createdAt?: true
  }

  export type WebhookEventMaxAggregateInputType = {
    id?: true
    provider?: true
    eventId?: true
    processed?: true
    createdAt?: true
  }

  export type WebhookEventCountAggregateInputType = {
    id?: true
    provider?: true
    eventId?: true
    payload?: true
    processed?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvent to aggregate.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEvents
    **/
    _count?: true | WebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEventMaxAggregateInputType
  }

  export type GetWebhookEventAggregateType<T extends WebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEvent[P]>
      : GetScalarType<T[P], AggregateWebhookEvent[P]>
  }




  export type WebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithAggregationInput | WebhookEventOrderByWithAggregationInput[]
    by: WebhookEventScalarFieldEnum[] | WebhookEventScalarFieldEnum
    having?: WebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEventCountAggregateInputType | true
    _min?: WebhookEventMinAggregateInputType
    _max?: WebhookEventMaxAggregateInputType
  }

  export type WebhookEventGroupByOutputType = {
    id: string
    provider: string
    eventId: string
    payload: JsonValue
    processed: boolean
    createdAt: Date
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  type GetWebhookEventGroupByPayload<T extends WebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    eventId?: boolean
    payload?: boolean
    processed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    eventId?: boolean
    payload?: boolean
    processed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectScalar = {
    id?: boolean
    provider?: boolean
    eventId?: boolean
    payload?: boolean
    processed?: boolean
    createdAt?: boolean
  }


  export type $WebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      eventId: string
      payload: Prisma.JsonValue
      processed: boolean
      createdAt: Date
    }, ExtArgs["result"]["webhookEvent"]>
    composites: {}
  }

  type WebhookEventGetPayload<S extends boolean | null | undefined | WebhookEventDefaultArgs> = $Result.GetResult<Prisma.$WebhookEventPayload, S>

  type WebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookEventCountAggregateInputType | true
    }

  export interface WebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEvent'], meta: { name: 'WebhookEvent' } }
    /**
     * Find zero or one WebhookEvent that matches the filter.
     * @param {WebhookEventFindUniqueArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEventFindUniqueArgs>(args: SelectSubset<T, WebhookEventFindUniqueArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookEventFindUniqueOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEventFindFirstArgs>(args?: SelectSubset<T, WebhookEventFindFirstArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany()
     * 
     * // Get first 10 WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEventFindManyArgs>(args?: SelectSubset<T, WebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookEvent.
     * @param {WebhookEventCreateArgs} args - Arguments to create a WebhookEvent.
     * @example
     * // Create one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.create({
     *   data: {
     *     // ... data to create a WebhookEvent
     *   }
     * })
     * 
     */
    create<T extends WebhookEventCreateArgs>(args: SelectSubset<T, WebhookEventCreateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookEvents.
     * @param {WebhookEventCreateManyArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEventCreateManyArgs>(args?: SelectSubset<T, WebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEvents and returns the data saved in the database.
     * @param {WebhookEventCreateManyAndReturnArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookEvent.
     * @param {WebhookEventDeleteArgs} args - Arguments to delete one WebhookEvent.
     * @example
     * // Delete one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.delete({
     *   where: {
     *     // ... filter to delete one WebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends WebhookEventDeleteArgs>(args: SelectSubset<T, WebhookEventDeleteArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookEvent.
     * @param {WebhookEventUpdateArgs} args - Arguments to update one WebhookEvent.
     * @example
     * // Update one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEventUpdateArgs>(args: SelectSubset<T, WebhookEventUpdateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookEvents.
     * @param {WebhookEventDeleteManyArgs} args - Arguments to filter WebhookEvents to delete.
     * @example
     * // Delete a few WebhookEvents
     * const { count } = await prisma.webhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEventDeleteManyArgs>(args?: SelectSubset<T, WebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEventUpdateManyArgs>(args: SelectSubset<T, WebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookEvent.
     * @param {WebhookEventUpsertArgs} args - Arguments to update or create a WebhookEvent.
     * @example
     * // Update or create a WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.upsert({
     *   create: {
     *     // ... data to create a WebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEventUpsertArgs>(args: SelectSubset<T, WebhookEventUpsertArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventCountArgs} args - Arguments to filter WebhookEvents to count.
     * @example
     * // Count the number of WebhookEvents
     * const count = await prisma.webhookEvent.count({
     *   where: {
     *     // ... the filter for the WebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends WebhookEventCountArgs>(
      args?: Subset<T, WebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEventAggregateArgs>(args: Subset<T, WebhookEventAggregateArgs>): Prisma.PrismaPromise<GetWebhookEventAggregateType<T>>

    /**
     * Group by WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEvent model
   */
  readonly fields: WebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEvent model
   */ 
  interface WebhookEventFieldRefs {
    readonly id: FieldRef<"WebhookEvent", 'String'>
    readonly provider: FieldRef<"WebhookEvent", 'String'>
    readonly eventId: FieldRef<"WebhookEvent", 'String'>
    readonly payload: FieldRef<"WebhookEvent", 'Json'>
    readonly processed: FieldRef<"WebhookEvent", 'Boolean'>
    readonly createdAt: FieldRef<"WebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEvent findUnique
   */
  export type WebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findUniqueOrThrow
   */
  export type WebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findFirst
   */
  export type WebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findFirstOrThrow
   */
  export type WebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findMany
   */
  export type WebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter, which WebhookEvents to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent create
   */
  export type WebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * The data needed to create a WebhookEvent.
     */
    data: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
  }

  /**
   * WebhookEvent createMany
   */
  export type WebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent createManyAndReturn
   */
  export type WebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookEvent update
   */
  export type WebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * The data needed to update a WebhookEvent.
     */
    data: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
    /**
     * Choose, which WebhookEvent to update.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent updateMany
   */
  export type WebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
  }

  /**
   * WebhookEvent upsert
   */
  export type WebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * The filter to search for the WebhookEvent to update in case it exists.
     */
    where: WebhookEventWhereUniqueInput
    /**
     * In case the WebhookEvent found by the `where` argument doesn't exist, create a new WebhookEvent with this data.
     */
    create: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
    /**
     * In case the WebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
  }

  /**
   * WebhookEvent delete
   */
  export type WebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Filter which WebhookEvent to delete.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent deleteMany
   */
  export type WebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvents to delete
     */
    where?: WebhookEventWhereInput
  }

  /**
   * WebhookEvent without action
   */
  export type WebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
  }


  /**
   * Model CoachRequest
   */

  export type AggregateCoachRequest = {
    _count: CoachRequestCountAggregateOutputType | null
    _min: CoachRequestMinAggregateOutputType | null
    _max: CoachRequestMaxAggregateOutputType | null
  }

  export type CoachRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type CoachRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: string | null
    createdAt: Date | null
  }

  export type CoachRequestCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    createdAt: number
    _all: number
  }


  export type CoachRequestMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type CoachRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
  }

  export type CoachRequestCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type CoachRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachRequest to aggregate.
     */
    where?: CoachRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachRequests to fetch.
     */
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachRequests
    **/
    _count?: true | CoachRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachRequestMaxAggregateInputType
  }

  export type GetCoachRequestAggregateType<T extends CoachRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachRequest[P]>
      : GetScalarType<T[P], AggregateCoachRequest[P]>
  }




  export type CoachRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachRequestWhereInput
    orderBy?: CoachRequestOrderByWithAggregationInput | CoachRequestOrderByWithAggregationInput[]
    by: CoachRequestScalarFieldEnum[] | CoachRequestScalarFieldEnum
    having?: CoachRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachRequestCountAggregateInputType | true
    _min?: CoachRequestMinAggregateInputType
    _max?: CoachRequestMaxAggregateInputType
  }

  export type CoachRequestGroupByOutputType = {
    id: string
    userId: string
    status: string
    createdAt: Date
    _count: CoachRequestCountAggregateOutputType | null
    _min: CoachRequestMinAggregateOutputType | null
    _max: CoachRequestMaxAggregateOutputType | null
  }

  type GetCoachRequestGroupByPayload<T extends CoachRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CoachRequestGroupByOutputType[P]>
        }
      >
    >


  export type CoachRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachRequest"]>

  export type CoachRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachRequest"]>

  export type CoachRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type CoachRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CoachRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoachRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["coachRequest"]>
    composites: {}
  }

  type CoachRequestGetPayload<S extends boolean | null | undefined | CoachRequestDefaultArgs> = $Result.GetResult<Prisma.$CoachRequestPayload, S>

  type CoachRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoachRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoachRequestCountAggregateInputType | true
    }

  export interface CoachRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachRequest'], meta: { name: 'CoachRequest' } }
    /**
     * Find zero or one CoachRequest that matches the filter.
     * @param {CoachRequestFindUniqueArgs} args - Arguments to find a CoachRequest
     * @example
     * // Get one CoachRequest
     * const coachRequest = await prisma.coachRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachRequestFindUniqueArgs>(args: SelectSubset<T, CoachRequestFindUniqueArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CoachRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoachRequestFindUniqueOrThrowArgs} args - Arguments to find a CoachRequest
     * @example
     * // Get one CoachRequest
     * const coachRequest = await prisma.coachRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CoachRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestFindFirstArgs} args - Arguments to find a CoachRequest
     * @example
     * // Get one CoachRequest
     * const coachRequest = await prisma.coachRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachRequestFindFirstArgs>(args?: SelectSubset<T, CoachRequestFindFirstArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CoachRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestFindFirstOrThrowArgs} args - Arguments to find a CoachRequest
     * @example
     * // Get one CoachRequest
     * const coachRequest = await prisma.coachRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CoachRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachRequests
     * const coachRequests = await prisma.coachRequest.findMany()
     * 
     * // Get first 10 CoachRequests
     * const coachRequests = await prisma.coachRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachRequestWithIdOnly = await prisma.coachRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachRequestFindManyArgs>(args?: SelectSubset<T, CoachRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CoachRequest.
     * @param {CoachRequestCreateArgs} args - Arguments to create a CoachRequest.
     * @example
     * // Create one CoachRequest
     * const CoachRequest = await prisma.coachRequest.create({
     *   data: {
     *     // ... data to create a CoachRequest
     *   }
     * })
     * 
     */
    create<T extends CoachRequestCreateArgs>(args: SelectSubset<T, CoachRequestCreateArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CoachRequests.
     * @param {CoachRequestCreateManyArgs} args - Arguments to create many CoachRequests.
     * @example
     * // Create many CoachRequests
     * const coachRequest = await prisma.coachRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachRequestCreateManyArgs>(args?: SelectSubset<T, CoachRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachRequests and returns the data saved in the database.
     * @param {CoachRequestCreateManyAndReturnArgs} args - Arguments to create many CoachRequests.
     * @example
     * // Create many CoachRequests
     * const coachRequest = await prisma.coachRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachRequests and only return the `id`
     * const coachRequestWithIdOnly = await prisma.coachRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CoachRequest.
     * @param {CoachRequestDeleteArgs} args - Arguments to delete one CoachRequest.
     * @example
     * // Delete one CoachRequest
     * const CoachRequest = await prisma.coachRequest.delete({
     *   where: {
     *     // ... filter to delete one CoachRequest
     *   }
     * })
     * 
     */
    delete<T extends CoachRequestDeleteArgs>(args: SelectSubset<T, CoachRequestDeleteArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CoachRequest.
     * @param {CoachRequestUpdateArgs} args - Arguments to update one CoachRequest.
     * @example
     * // Update one CoachRequest
     * const coachRequest = await prisma.coachRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachRequestUpdateArgs>(args: SelectSubset<T, CoachRequestUpdateArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CoachRequests.
     * @param {CoachRequestDeleteManyArgs} args - Arguments to filter CoachRequests to delete.
     * @example
     * // Delete a few CoachRequests
     * const { count } = await prisma.coachRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachRequestDeleteManyArgs>(args?: SelectSubset<T, CoachRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachRequests
     * const coachRequest = await prisma.coachRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachRequestUpdateManyArgs>(args: SelectSubset<T, CoachRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoachRequest.
     * @param {CoachRequestUpsertArgs} args - Arguments to update or create a CoachRequest.
     * @example
     * // Update or create a CoachRequest
     * const coachRequest = await prisma.coachRequest.upsert({
     *   create: {
     *     // ... data to create a CoachRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachRequest we want to update
     *   }
     * })
     */
    upsert<T extends CoachRequestUpsertArgs>(args: SelectSubset<T, CoachRequestUpsertArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CoachRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestCountArgs} args - Arguments to filter CoachRequests to count.
     * @example
     * // Count the number of CoachRequests
     * const count = await prisma.coachRequest.count({
     *   where: {
     *     // ... the filter for the CoachRequests we want to count
     *   }
     * })
    **/
    count<T extends CoachRequestCountArgs>(
      args?: Subset<T, CoachRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachRequestAggregateArgs>(args: Subset<T, CoachRequestAggregateArgs>): Prisma.PrismaPromise<GetCoachRequestAggregateType<T>>

    /**
     * Group by CoachRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachRequestGroupByArgs['orderBy'] }
        : { orderBy?: CoachRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachRequest model
   */
  readonly fields: CoachRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachRequest model
   */ 
  interface CoachRequestFieldRefs {
    readonly id: FieldRef<"CoachRequest", 'String'>
    readonly userId: FieldRef<"CoachRequest", 'String'>
    readonly status: FieldRef<"CoachRequest", 'String'>
    readonly createdAt: FieldRef<"CoachRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachRequest findUnique
   */
  export type CoachRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter, which CoachRequest to fetch.
     */
    where: CoachRequestWhereUniqueInput
  }

  /**
   * CoachRequest findUniqueOrThrow
   */
  export type CoachRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter, which CoachRequest to fetch.
     */
    where: CoachRequestWhereUniqueInput
  }

  /**
   * CoachRequest findFirst
   */
  export type CoachRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter, which CoachRequest to fetch.
     */
    where?: CoachRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachRequests to fetch.
     */
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachRequests.
     */
    cursor?: CoachRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachRequests.
     */
    distinct?: CoachRequestScalarFieldEnum | CoachRequestScalarFieldEnum[]
  }

  /**
   * CoachRequest findFirstOrThrow
   */
  export type CoachRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter, which CoachRequest to fetch.
     */
    where?: CoachRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachRequests to fetch.
     */
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachRequests.
     */
    cursor?: CoachRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachRequests.
     */
    distinct?: CoachRequestScalarFieldEnum | CoachRequestScalarFieldEnum[]
  }

  /**
   * CoachRequest findMany
   */
  export type CoachRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter, which CoachRequests to fetch.
     */
    where?: CoachRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachRequests to fetch.
     */
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachRequests.
     */
    cursor?: CoachRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachRequests.
     */
    skip?: number
    distinct?: CoachRequestScalarFieldEnum | CoachRequestScalarFieldEnum[]
  }

  /**
   * CoachRequest create
   */
  export type CoachRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachRequest.
     */
    data: XOR<CoachRequestCreateInput, CoachRequestUncheckedCreateInput>
  }

  /**
   * CoachRequest createMany
   */
  export type CoachRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachRequests.
     */
    data: CoachRequestCreateManyInput | CoachRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoachRequest createManyAndReturn
   */
  export type CoachRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CoachRequests.
     */
    data: CoachRequestCreateManyInput | CoachRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachRequest update
   */
  export type CoachRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachRequest.
     */
    data: XOR<CoachRequestUpdateInput, CoachRequestUncheckedUpdateInput>
    /**
     * Choose, which CoachRequest to update.
     */
    where: CoachRequestWhereUniqueInput
  }

  /**
   * CoachRequest updateMany
   */
  export type CoachRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachRequests.
     */
    data: XOR<CoachRequestUpdateManyMutationInput, CoachRequestUncheckedUpdateManyInput>
    /**
     * Filter which CoachRequests to update
     */
    where?: CoachRequestWhereInput
  }

  /**
   * CoachRequest upsert
   */
  export type CoachRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachRequest to update in case it exists.
     */
    where: CoachRequestWhereUniqueInput
    /**
     * In case the CoachRequest found by the `where` argument doesn't exist, create a new CoachRequest with this data.
     */
    create: XOR<CoachRequestCreateInput, CoachRequestUncheckedCreateInput>
    /**
     * In case the CoachRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachRequestUpdateInput, CoachRequestUncheckedUpdateInput>
  }

  /**
   * CoachRequest delete
   */
  export type CoachRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter which CoachRequest to delete.
     */
    where: CoachRequestWhereUniqueInput
  }

  /**
   * CoachRequest deleteMany
   */
  export type CoachRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachRequests to delete
     */
    where?: CoachRequestWhereInput
  }

  /**
   * CoachRequest without action
   */
  export type CoachRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
  }


  /**
   * Model UserIntake
   */

  export type AggregateUserIntake = {
    _count: UserIntakeCountAggregateOutputType | null
    _avg: UserIntakeAvgAggregateOutputType | null
    _sum: UserIntakeSumAggregateOutputType | null
    _min: UserIntakeMinAggregateOutputType | null
    _max: UserIntakeMaxAggregateOutputType | null
  }

  export type UserIntakeAvgAggregateOutputType = {
    age: number | null
    weightKg: number | null
    heightCm: number | null
    workoutFrequency: number | null
  }

  export type UserIntakeSumAggregateOutputType = {
    age: number | null
    weightKg: number | null
    heightCm: number | null
    workoutFrequency: number | null
  }

  export type UserIntakeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gender: string | null
    mainGoal: string | null
    workoutLocation: string | null
    firstCompletedAt: Date | null
    age: number | null
    weightKg: number | null
    heightCm: number | null
    experienceLevel: string | null
    workoutFrequency: number | null
    secondCompletedAt: Date | null
    skippedSecond: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserIntakeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gender: string | null
    mainGoal: string | null
    workoutLocation: string | null
    firstCompletedAt: Date | null
    age: number | null
    weightKg: number | null
    heightCm: number | null
    experienceLevel: string | null
    workoutFrequency: number | null
    secondCompletedAt: Date | null
    skippedSecond: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserIntakeCountAggregateOutputType = {
    id: number
    userId: number
    gender: number
    mainGoal: number
    workoutLocation: number
    firstCompletedAt: number
    age: number
    weightKg: number
    heightCm: number
    experienceLevel: number
    workoutFrequency: number
    injuries: number
    secondCompletedAt: number
    skippedSecond: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserIntakeAvgAggregateInputType = {
    age?: true
    weightKg?: true
    heightCm?: true
    workoutFrequency?: true
  }

  export type UserIntakeSumAggregateInputType = {
    age?: true
    weightKg?: true
    heightCm?: true
    workoutFrequency?: true
  }

  export type UserIntakeMinAggregateInputType = {
    id?: true
    userId?: true
    gender?: true
    mainGoal?: true
    workoutLocation?: true
    firstCompletedAt?: true
    age?: true
    weightKg?: true
    heightCm?: true
    experienceLevel?: true
    workoutFrequency?: true
    secondCompletedAt?: true
    skippedSecond?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserIntakeMaxAggregateInputType = {
    id?: true
    userId?: true
    gender?: true
    mainGoal?: true
    workoutLocation?: true
    firstCompletedAt?: true
    age?: true
    weightKg?: true
    heightCm?: true
    experienceLevel?: true
    workoutFrequency?: true
    secondCompletedAt?: true
    skippedSecond?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserIntakeCountAggregateInputType = {
    id?: true
    userId?: true
    gender?: true
    mainGoal?: true
    workoutLocation?: true
    firstCompletedAt?: true
    age?: true
    weightKg?: true
    heightCm?: true
    experienceLevel?: true
    workoutFrequency?: true
    injuries?: true
    secondCompletedAt?: true
    skippedSecond?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserIntakeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserIntake to aggregate.
     */
    where?: UserIntakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIntakes to fetch.
     */
    orderBy?: UserIntakeOrderByWithRelationInput | UserIntakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserIntakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIntakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIntakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserIntakes
    **/
    _count?: true | UserIntakeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserIntakeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserIntakeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserIntakeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserIntakeMaxAggregateInputType
  }

  export type GetUserIntakeAggregateType<T extends UserIntakeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserIntake]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserIntake[P]>
      : GetScalarType<T[P], AggregateUserIntake[P]>
  }




  export type UserIntakeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserIntakeWhereInput
    orderBy?: UserIntakeOrderByWithAggregationInput | UserIntakeOrderByWithAggregationInput[]
    by: UserIntakeScalarFieldEnum[] | UserIntakeScalarFieldEnum
    having?: UserIntakeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserIntakeCountAggregateInputType | true
    _avg?: UserIntakeAvgAggregateInputType
    _sum?: UserIntakeSumAggregateInputType
    _min?: UserIntakeMinAggregateInputType
    _max?: UserIntakeMaxAggregateInputType
  }

  export type UserIntakeGroupByOutputType = {
    id: string
    userId: string
    gender: string | null
    mainGoal: string | null
    workoutLocation: string | null
    firstCompletedAt: Date | null
    age: number | null
    weightKg: number | null
    heightCm: number | null
    experienceLevel: string | null
    workoutFrequency: number | null
    injuries: string[]
    secondCompletedAt: Date | null
    skippedSecond: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserIntakeCountAggregateOutputType | null
    _avg: UserIntakeAvgAggregateOutputType | null
    _sum: UserIntakeSumAggregateOutputType | null
    _min: UserIntakeMinAggregateOutputType | null
    _max: UserIntakeMaxAggregateOutputType | null
  }

  type GetUserIntakeGroupByPayload<T extends UserIntakeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserIntakeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserIntakeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserIntakeGroupByOutputType[P]>
            : GetScalarType<T[P], UserIntakeGroupByOutputType[P]>
        }
      >
    >


  export type UserIntakeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gender?: boolean
    mainGoal?: boolean
    workoutLocation?: boolean
    firstCompletedAt?: boolean
    age?: boolean
    weightKg?: boolean
    heightCm?: boolean
    experienceLevel?: boolean
    workoutFrequency?: boolean
    injuries?: boolean
    secondCompletedAt?: boolean
    skippedSecond?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userIntake"]>

  export type UserIntakeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gender?: boolean
    mainGoal?: boolean
    workoutLocation?: boolean
    firstCompletedAt?: boolean
    age?: boolean
    weightKg?: boolean
    heightCm?: boolean
    experienceLevel?: boolean
    workoutFrequency?: boolean
    injuries?: boolean
    secondCompletedAt?: boolean
    skippedSecond?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userIntake"]>

  export type UserIntakeSelectScalar = {
    id?: boolean
    userId?: boolean
    gender?: boolean
    mainGoal?: boolean
    workoutLocation?: boolean
    firstCompletedAt?: boolean
    age?: boolean
    weightKg?: boolean
    heightCm?: boolean
    experienceLevel?: boolean
    workoutFrequency?: boolean
    injuries?: boolean
    secondCompletedAt?: boolean
    skippedSecond?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserIntakeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserIntakeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserIntakePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserIntake"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gender: string | null
      mainGoal: string | null
      workoutLocation: string | null
      firstCompletedAt: Date | null
      age: number | null
      weightKg: number | null
      heightCm: number | null
      experienceLevel: string | null
      workoutFrequency: number | null
      injuries: string[]
      secondCompletedAt: Date | null
      skippedSecond: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userIntake"]>
    composites: {}
  }

  type UserIntakeGetPayload<S extends boolean | null | undefined | UserIntakeDefaultArgs> = $Result.GetResult<Prisma.$UserIntakePayload, S>

  type UserIntakeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserIntakeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserIntakeCountAggregateInputType | true
    }

  export interface UserIntakeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserIntake'], meta: { name: 'UserIntake' } }
    /**
     * Find zero or one UserIntake that matches the filter.
     * @param {UserIntakeFindUniqueArgs} args - Arguments to find a UserIntake
     * @example
     * // Get one UserIntake
     * const userIntake = await prisma.userIntake.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserIntakeFindUniqueArgs>(args: SelectSubset<T, UserIntakeFindUniqueArgs<ExtArgs>>): Prisma__UserIntakeClient<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserIntake that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserIntakeFindUniqueOrThrowArgs} args - Arguments to find a UserIntake
     * @example
     * // Get one UserIntake
     * const userIntake = await prisma.userIntake.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserIntakeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserIntakeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserIntakeClient<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserIntake that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIntakeFindFirstArgs} args - Arguments to find a UserIntake
     * @example
     * // Get one UserIntake
     * const userIntake = await prisma.userIntake.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserIntakeFindFirstArgs>(args?: SelectSubset<T, UserIntakeFindFirstArgs<ExtArgs>>): Prisma__UserIntakeClient<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserIntake that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIntakeFindFirstOrThrowArgs} args - Arguments to find a UserIntake
     * @example
     * // Get one UserIntake
     * const userIntake = await prisma.userIntake.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserIntakeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserIntakeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserIntakeClient<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserIntakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIntakeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserIntakes
     * const userIntakes = await prisma.userIntake.findMany()
     * 
     * // Get first 10 UserIntakes
     * const userIntakes = await prisma.userIntake.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userIntakeWithIdOnly = await prisma.userIntake.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserIntakeFindManyArgs>(args?: SelectSubset<T, UserIntakeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserIntake.
     * @param {UserIntakeCreateArgs} args - Arguments to create a UserIntake.
     * @example
     * // Create one UserIntake
     * const UserIntake = await prisma.userIntake.create({
     *   data: {
     *     // ... data to create a UserIntake
     *   }
     * })
     * 
     */
    create<T extends UserIntakeCreateArgs>(args: SelectSubset<T, UserIntakeCreateArgs<ExtArgs>>): Prisma__UserIntakeClient<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserIntakes.
     * @param {UserIntakeCreateManyArgs} args - Arguments to create many UserIntakes.
     * @example
     * // Create many UserIntakes
     * const userIntake = await prisma.userIntake.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserIntakeCreateManyArgs>(args?: SelectSubset<T, UserIntakeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserIntakes and returns the data saved in the database.
     * @param {UserIntakeCreateManyAndReturnArgs} args - Arguments to create many UserIntakes.
     * @example
     * // Create many UserIntakes
     * const userIntake = await prisma.userIntake.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserIntakes and only return the `id`
     * const userIntakeWithIdOnly = await prisma.userIntake.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserIntakeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserIntakeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserIntake.
     * @param {UserIntakeDeleteArgs} args - Arguments to delete one UserIntake.
     * @example
     * // Delete one UserIntake
     * const UserIntake = await prisma.userIntake.delete({
     *   where: {
     *     // ... filter to delete one UserIntake
     *   }
     * })
     * 
     */
    delete<T extends UserIntakeDeleteArgs>(args: SelectSubset<T, UserIntakeDeleteArgs<ExtArgs>>): Prisma__UserIntakeClient<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserIntake.
     * @param {UserIntakeUpdateArgs} args - Arguments to update one UserIntake.
     * @example
     * // Update one UserIntake
     * const userIntake = await prisma.userIntake.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserIntakeUpdateArgs>(args: SelectSubset<T, UserIntakeUpdateArgs<ExtArgs>>): Prisma__UserIntakeClient<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserIntakes.
     * @param {UserIntakeDeleteManyArgs} args - Arguments to filter UserIntakes to delete.
     * @example
     * // Delete a few UserIntakes
     * const { count } = await prisma.userIntake.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserIntakeDeleteManyArgs>(args?: SelectSubset<T, UserIntakeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIntakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIntakeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserIntakes
     * const userIntake = await prisma.userIntake.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserIntakeUpdateManyArgs>(args: SelectSubset<T, UserIntakeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserIntake.
     * @param {UserIntakeUpsertArgs} args - Arguments to update or create a UserIntake.
     * @example
     * // Update or create a UserIntake
     * const userIntake = await prisma.userIntake.upsert({
     *   create: {
     *     // ... data to create a UserIntake
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserIntake we want to update
     *   }
     * })
     */
    upsert<T extends UserIntakeUpsertArgs>(args: SelectSubset<T, UserIntakeUpsertArgs<ExtArgs>>): Prisma__UserIntakeClient<$Result.GetResult<Prisma.$UserIntakePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserIntakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIntakeCountArgs} args - Arguments to filter UserIntakes to count.
     * @example
     * // Count the number of UserIntakes
     * const count = await prisma.userIntake.count({
     *   where: {
     *     // ... the filter for the UserIntakes we want to count
     *   }
     * })
    **/
    count<T extends UserIntakeCountArgs>(
      args?: Subset<T, UserIntakeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserIntakeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserIntake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIntakeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserIntakeAggregateArgs>(args: Subset<T, UserIntakeAggregateArgs>): Prisma.PrismaPromise<GetUserIntakeAggregateType<T>>

    /**
     * Group by UserIntake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIntakeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserIntakeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserIntakeGroupByArgs['orderBy'] }
        : { orderBy?: UserIntakeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserIntakeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserIntakeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserIntake model
   */
  readonly fields: UserIntakeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserIntake.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserIntakeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserIntake model
   */ 
  interface UserIntakeFieldRefs {
    readonly id: FieldRef<"UserIntake", 'String'>
    readonly userId: FieldRef<"UserIntake", 'String'>
    readonly gender: FieldRef<"UserIntake", 'String'>
    readonly mainGoal: FieldRef<"UserIntake", 'String'>
    readonly workoutLocation: FieldRef<"UserIntake", 'String'>
    readonly firstCompletedAt: FieldRef<"UserIntake", 'DateTime'>
    readonly age: FieldRef<"UserIntake", 'Int'>
    readonly weightKg: FieldRef<"UserIntake", 'Float'>
    readonly heightCm: FieldRef<"UserIntake", 'Float'>
    readonly experienceLevel: FieldRef<"UserIntake", 'String'>
    readonly workoutFrequency: FieldRef<"UserIntake", 'Int'>
    readonly injuries: FieldRef<"UserIntake", 'String[]'>
    readonly secondCompletedAt: FieldRef<"UserIntake", 'DateTime'>
    readonly skippedSecond: FieldRef<"UserIntake", 'Boolean'>
    readonly createdAt: FieldRef<"UserIntake", 'DateTime'>
    readonly updatedAt: FieldRef<"UserIntake", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserIntake findUnique
   */
  export type UserIntakeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
    /**
     * Filter, which UserIntake to fetch.
     */
    where: UserIntakeWhereUniqueInput
  }

  /**
   * UserIntake findUniqueOrThrow
   */
  export type UserIntakeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
    /**
     * Filter, which UserIntake to fetch.
     */
    where: UserIntakeWhereUniqueInput
  }

  /**
   * UserIntake findFirst
   */
  export type UserIntakeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
    /**
     * Filter, which UserIntake to fetch.
     */
    where?: UserIntakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIntakes to fetch.
     */
    orderBy?: UserIntakeOrderByWithRelationInput | UserIntakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIntakes.
     */
    cursor?: UserIntakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIntakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIntakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIntakes.
     */
    distinct?: UserIntakeScalarFieldEnum | UserIntakeScalarFieldEnum[]
  }

  /**
   * UserIntake findFirstOrThrow
   */
  export type UserIntakeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
    /**
     * Filter, which UserIntake to fetch.
     */
    where?: UserIntakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIntakes to fetch.
     */
    orderBy?: UserIntakeOrderByWithRelationInput | UserIntakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIntakes.
     */
    cursor?: UserIntakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIntakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIntakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIntakes.
     */
    distinct?: UserIntakeScalarFieldEnum | UserIntakeScalarFieldEnum[]
  }

  /**
   * UserIntake findMany
   */
  export type UserIntakeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
    /**
     * Filter, which UserIntakes to fetch.
     */
    where?: UserIntakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIntakes to fetch.
     */
    orderBy?: UserIntakeOrderByWithRelationInput | UserIntakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserIntakes.
     */
    cursor?: UserIntakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIntakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIntakes.
     */
    skip?: number
    distinct?: UserIntakeScalarFieldEnum | UserIntakeScalarFieldEnum[]
  }

  /**
   * UserIntake create
   */
  export type UserIntakeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserIntake.
     */
    data: XOR<UserIntakeCreateInput, UserIntakeUncheckedCreateInput>
  }

  /**
   * UserIntake createMany
   */
  export type UserIntakeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserIntakes.
     */
    data: UserIntakeCreateManyInput | UserIntakeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserIntake createManyAndReturn
   */
  export type UserIntakeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserIntakes.
     */
    data: UserIntakeCreateManyInput | UserIntakeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserIntake update
   */
  export type UserIntakeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserIntake.
     */
    data: XOR<UserIntakeUpdateInput, UserIntakeUncheckedUpdateInput>
    /**
     * Choose, which UserIntake to update.
     */
    where: UserIntakeWhereUniqueInput
  }

  /**
   * UserIntake updateMany
   */
  export type UserIntakeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserIntakes.
     */
    data: XOR<UserIntakeUpdateManyMutationInput, UserIntakeUncheckedUpdateManyInput>
    /**
     * Filter which UserIntakes to update
     */
    where?: UserIntakeWhereInput
  }

  /**
   * UserIntake upsert
   */
  export type UserIntakeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserIntake to update in case it exists.
     */
    where: UserIntakeWhereUniqueInput
    /**
     * In case the UserIntake found by the `where` argument doesn't exist, create a new UserIntake with this data.
     */
    create: XOR<UserIntakeCreateInput, UserIntakeUncheckedCreateInput>
    /**
     * In case the UserIntake was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserIntakeUpdateInput, UserIntakeUncheckedUpdateInput>
  }

  /**
   * UserIntake delete
   */
  export type UserIntakeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
    /**
     * Filter which UserIntake to delete.
     */
    where: UserIntakeWhereUniqueInput
  }

  /**
   * UserIntake deleteMany
   */
  export type UserIntakeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserIntakes to delete
     */
    where?: UserIntakeWhereInput
  }

  /**
   * UserIntake without action
   */
  export type UserIntakeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIntake
     */
    select?: UserIntakeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIntakeInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionQuota
   */

  export type AggregateSubscriptionQuota = {
    _count: SubscriptionQuotaCountAggregateOutputType | null
    _avg: SubscriptionQuotaAvgAggregateOutputType | null
    _sum: SubscriptionQuotaSumAggregateOutputType | null
    _min: SubscriptionQuotaMinAggregateOutputType | null
    _max: SubscriptionQuotaMaxAggregateOutputType | null
  }

  export type SubscriptionQuotaAvgAggregateOutputType = {
    messagesUsed: number | null
    callsUsed: number | null
    attachmentsUsed: number | null
    nutritionWindowDays: number | null
  }

  export type SubscriptionQuotaSumAggregateOutputType = {
    messagesUsed: number | null
    callsUsed: number | null
    attachmentsUsed: number | null
    nutritionWindowDays: number | null
  }

  export type SubscriptionQuotaMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tier: $Enums.SubscriptionTier | null
    messagesUsed: number | null
    callsUsed: number | null
    attachmentsUsed: number | null
    resetAt: Date | null
    nutritionWindowDays: number | null
    nutritionExpiresAt: Date | null
    nutritionLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionQuotaMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tier: $Enums.SubscriptionTier | null
    messagesUsed: number | null
    callsUsed: number | null
    attachmentsUsed: number | null
    resetAt: Date | null
    nutritionWindowDays: number | null
    nutritionExpiresAt: Date | null
    nutritionLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionQuotaCountAggregateOutputType = {
    id: number
    userId: number
    tier: number
    messagesUsed: number
    callsUsed: number
    attachmentsUsed: number
    resetAt: number
    nutritionWindowDays: number
    nutritionExpiresAt: number
    nutritionLocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionQuotaAvgAggregateInputType = {
    messagesUsed?: true
    callsUsed?: true
    attachmentsUsed?: true
    nutritionWindowDays?: true
  }

  export type SubscriptionQuotaSumAggregateInputType = {
    messagesUsed?: true
    callsUsed?: true
    attachmentsUsed?: true
    nutritionWindowDays?: true
  }

  export type SubscriptionQuotaMinAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    messagesUsed?: true
    callsUsed?: true
    attachmentsUsed?: true
    resetAt?: true
    nutritionWindowDays?: true
    nutritionExpiresAt?: true
    nutritionLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionQuotaMaxAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    messagesUsed?: true
    callsUsed?: true
    attachmentsUsed?: true
    resetAt?: true
    nutritionWindowDays?: true
    nutritionExpiresAt?: true
    nutritionLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionQuotaCountAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    messagesUsed?: true
    callsUsed?: true
    attachmentsUsed?: true
    resetAt?: true
    nutritionWindowDays?: true
    nutritionExpiresAt?: true
    nutritionLocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionQuota to aggregate.
     */
    where?: SubscriptionQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionQuotas to fetch.
     */
    orderBy?: SubscriptionQuotaOrderByWithRelationInput | SubscriptionQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionQuotas
    **/
    _count?: true | SubscriptionQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionQuotaMaxAggregateInputType
  }

  export type GetSubscriptionQuotaAggregateType<T extends SubscriptionQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionQuota[P]>
      : GetScalarType<T[P], AggregateSubscriptionQuota[P]>
  }




  export type SubscriptionQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionQuotaWhereInput
    orderBy?: SubscriptionQuotaOrderByWithAggregationInput | SubscriptionQuotaOrderByWithAggregationInput[]
    by: SubscriptionQuotaScalarFieldEnum[] | SubscriptionQuotaScalarFieldEnum
    having?: SubscriptionQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionQuotaCountAggregateInputType | true
    _avg?: SubscriptionQuotaAvgAggregateInputType
    _sum?: SubscriptionQuotaSumAggregateInputType
    _min?: SubscriptionQuotaMinAggregateInputType
    _max?: SubscriptionQuotaMaxAggregateInputType
  }

  export type SubscriptionQuotaGroupByOutputType = {
    id: string
    userId: string
    tier: $Enums.SubscriptionTier
    messagesUsed: number
    callsUsed: number
    attachmentsUsed: number
    resetAt: Date
    nutritionWindowDays: number | null
    nutritionExpiresAt: Date | null
    nutritionLocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionQuotaCountAggregateOutputType | null
    _avg: SubscriptionQuotaAvgAggregateOutputType | null
    _sum: SubscriptionQuotaSumAggregateOutputType | null
    _min: SubscriptionQuotaMinAggregateOutputType | null
    _max: SubscriptionQuotaMaxAggregateOutputType | null
  }

  type GetSubscriptionQuotaGroupByPayload<T extends SubscriptionQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionQuotaGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    messagesUsed?: boolean
    callsUsed?: boolean
    attachmentsUsed?: boolean
    resetAt?: boolean
    nutritionWindowDays?: boolean
    nutritionExpiresAt?: boolean
    nutritionLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionQuota"]>

  export type SubscriptionQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    messagesUsed?: boolean
    callsUsed?: boolean
    attachmentsUsed?: boolean
    resetAt?: boolean
    nutritionWindowDays?: boolean
    nutritionExpiresAt?: boolean
    nutritionLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionQuota"]>

  export type SubscriptionQuotaSelectScalar = {
    id?: boolean
    userId?: boolean
    tier?: boolean
    messagesUsed?: boolean
    callsUsed?: boolean
    attachmentsUsed?: boolean
    resetAt?: boolean
    nutritionWindowDays?: boolean
    nutritionExpiresAt?: boolean
    nutritionLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionQuota"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tier: $Enums.SubscriptionTier
      messagesUsed: number
      callsUsed: number
      attachmentsUsed: number
      resetAt: Date
      nutritionWindowDays: number | null
      nutritionExpiresAt: Date | null
      nutritionLocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionQuota"]>
    composites: {}
  }

  type SubscriptionQuotaGetPayload<S extends boolean | null | undefined | SubscriptionQuotaDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionQuotaPayload, S>

  type SubscriptionQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionQuotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionQuotaCountAggregateInputType | true
    }

  export interface SubscriptionQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionQuota'], meta: { name: 'SubscriptionQuota' } }
    /**
     * Find zero or one SubscriptionQuota that matches the filter.
     * @param {SubscriptionQuotaFindUniqueArgs} args - Arguments to find a SubscriptionQuota
     * @example
     * // Get one SubscriptionQuota
     * const subscriptionQuota = await prisma.subscriptionQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionQuotaFindUniqueArgs>(args: SelectSubset<T, SubscriptionQuotaFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionQuotaClient<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionQuota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionQuotaFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionQuota
     * @example
     * // Get one SubscriptionQuota
     * const subscriptionQuota = await prisma.subscriptionQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionQuotaClient<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionQuotaFindFirstArgs} args - Arguments to find a SubscriptionQuota
     * @example
     * // Get one SubscriptionQuota
     * const subscriptionQuota = await prisma.subscriptionQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionQuotaFindFirstArgs>(args?: SelectSubset<T, SubscriptionQuotaFindFirstArgs<ExtArgs>>): Prisma__SubscriptionQuotaClient<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionQuotaFindFirstOrThrowArgs} args - Arguments to find a SubscriptionQuota
     * @example
     * // Get one SubscriptionQuota
     * const subscriptionQuota = await prisma.subscriptionQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionQuotaClient<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionQuotas
     * const subscriptionQuotas = await prisma.subscriptionQuota.findMany()
     * 
     * // Get first 10 SubscriptionQuotas
     * const subscriptionQuotas = await prisma.subscriptionQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionQuotaWithIdOnly = await prisma.subscriptionQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionQuotaFindManyArgs>(args?: SelectSubset<T, SubscriptionQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionQuota.
     * @param {SubscriptionQuotaCreateArgs} args - Arguments to create a SubscriptionQuota.
     * @example
     * // Create one SubscriptionQuota
     * const SubscriptionQuota = await prisma.subscriptionQuota.create({
     *   data: {
     *     // ... data to create a SubscriptionQuota
     *   }
     * })
     * 
     */
    create<T extends SubscriptionQuotaCreateArgs>(args: SelectSubset<T, SubscriptionQuotaCreateArgs<ExtArgs>>): Prisma__SubscriptionQuotaClient<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionQuotas.
     * @param {SubscriptionQuotaCreateManyArgs} args - Arguments to create many SubscriptionQuotas.
     * @example
     * // Create many SubscriptionQuotas
     * const subscriptionQuota = await prisma.subscriptionQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionQuotaCreateManyArgs>(args?: SelectSubset<T, SubscriptionQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionQuotas and returns the data saved in the database.
     * @param {SubscriptionQuotaCreateManyAndReturnArgs} args - Arguments to create many SubscriptionQuotas.
     * @example
     * // Create many SubscriptionQuotas
     * const subscriptionQuota = await prisma.subscriptionQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionQuotas and only return the `id`
     * const subscriptionQuotaWithIdOnly = await prisma.subscriptionQuota.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionQuota.
     * @param {SubscriptionQuotaDeleteArgs} args - Arguments to delete one SubscriptionQuota.
     * @example
     * // Delete one SubscriptionQuota
     * const SubscriptionQuota = await prisma.subscriptionQuota.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionQuota
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionQuotaDeleteArgs>(args: SelectSubset<T, SubscriptionQuotaDeleteArgs<ExtArgs>>): Prisma__SubscriptionQuotaClient<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionQuota.
     * @param {SubscriptionQuotaUpdateArgs} args - Arguments to update one SubscriptionQuota.
     * @example
     * // Update one SubscriptionQuota
     * const subscriptionQuota = await prisma.subscriptionQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionQuotaUpdateArgs>(args: SelectSubset<T, SubscriptionQuotaUpdateArgs<ExtArgs>>): Prisma__SubscriptionQuotaClient<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionQuotas.
     * @param {SubscriptionQuotaDeleteManyArgs} args - Arguments to filter SubscriptionQuotas to delete.
     * @example
     * // Delete a few SubscriptionQuotas
     * const { count } = await prisma.subscriptionQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionQuotaDeleteManyArgs>(args?: SelectSubset<T, SubscriptionQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionQuotas
     * const subscriptionQuota = await prisma.subscriptionQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionQuotaUpdateManyArgs>(args: SelectSubset<T, SubscriptionQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionQuota.
     * @param {SubscriptionQuotaUpsertArgs} args - Arguments to update or create a SubscriptionQuota.
     * @example
     * // Update or create a SubscriptionQuota
     * const subscriptionQuota = await prisma.subscriptionQuota.upsert({
     *   create: {
     *     // ... data to create a SubscriptionQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionQuota we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionQuotaUpsertArgs>(args: SelectSubset<T, SubscriptionQuotaUpsertArgs<ExtArgs>>): Prisma__SubscriptionQuotaClient<$Result.GetResult<Prisma.$SubscriptionQuotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionQuotaCountArgs} args - Arguments to filter SubscriptionQuotas to count.
     * @example
     * // Count the number of SubscriptionQuotas
     * const count = await prisma.subscriptionQuota.count({
     *   where: {
     *     // ... the filter for the SubscriptionQuotas we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionQuotaCountArgs>(
      args?: Subset<T, SubscriptionQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionQuotaAggregateArgs>(args: Subset<T, SubscriptionQuotaAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionQuotaAggregateType<T>>

    /**
     * Group by SubscriptionQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionQuotaGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionQuota model
   */
  readonly fields: SubscriptionQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionQuota model
   */ 
  interface SubscriptionQuotaFieldRefs {
    readonly id: FieldRef<"SubscriptionQuota", 'String'>
    readonly userId: FieldRef<"SubscriptionQuota", 'String'>
    readonly tier: FieldRef<"SubscriptionQuota", 'SubscriptionTier'>
    readonly messagesUsed: FieldRef<"SubscriptionQuota", 'Int'>
    readonly callsUsed: FieldRef<"SubscriptionQuota", 'Int'>
    readonly attachmentsUsed: FieldRef<"SubscriptionQuota", 'Int'>
    readonly resetAt: FieldRef<"SubscriptionQuota", 'DateTime'>
    readonly nutritionWindowDays: FieldRef<"SubscriptionQuota", 'Int'>
    readonly nutritionExpiresAt: FieldRef<"SubscriptionQuota", 'DateTime'>
    readonly nutritionLocked: FieldRef<"SubscriptionQuota", 'Boolean'>
    readonly createdAt: FieldRef<"SubscriptionQuota", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionQuota findUnique
   */
  export type SubscriptionQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionQuota to fetch.
     */
    where: SubscriptionQuotaWhereUniqueInput
  }

  /**
   * SubscriptionQuota findUniqueOrThrow
   */
  export type SubscriptionQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionQuota to fetch.
     */
    where: SubscriptionQuotaWhereUniqueInput
  }

  /**
   * SubscriptionQuota findFirst
   */
  export type SubscriptionQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionQuota to fetch.
     */
    where?: SubscriptionQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionQuotas to fetch.
     */
    orderBy?: SubscriptionQuotaOrderByWithRelationInput | SubscriptionQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionQuotas.
     */
    cursor?: SubscriptionQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionQuotas.
     */
    distinct?: SubscriptionQuotaScalarFieldEnum | SubscriptionQuotaScalarFieldEnum[]
  }

  /**
   * SubscriptionQuota findFirstOrThrow
   */
  export type SubscriptionQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionQuota to fetch.
     */
    where?: SubscriptionQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionQuotas to fetch.
     */
    orderBy?: SubscriptionQuotaOrderByWithRelationInput | SubscriptionQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionQuotas.
     */
    cursor?: SubscriptionQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionQuotas.
     */
    distinct?: SubscriptionQuotaScalarFieldEnum | SubscriptionQuotaScalarFieldEnum[]
  }

  /**
   * SubscriptionQuota findMany
   */
  export type SubscriptionQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionQuotas to fetch.
     */
    where?: SubscriptionQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionQuotas to fetch.
     */
    orderBy?: SubscriptionQuotaOrderByWithRelationInput | SubscriptionQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionQuotas.
     */
    cursor?: SubscriptionQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionQuotas.
     */
    skip?: number
    distinct?: SubscriptionQuotaScalarFieldEnum | SubscriptionQuotaScalarFieldEnum[]
  }

  /**
   * SubscriptionQuota create
   */
  export type SubscriptionQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionQuota.
     */
    data: XOR<SubscriptionQuotaCreateInput, SubscriptionQuotaUncheckedCreateInput>
  }

  /**
   * SubscriptionQuota createMany
   */
  export type SubscriptionQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionQuotas.
     */
    data: SubscriptionQuotaCreateManyInput | SubscriptionQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionQuota createManyAndReturn
   */
  export type SubscriptionQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionQuotas.
     */
    data: SubscriptionQuotaCreateManyInput | SubscriptionQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionQuota update
   */
  export type SubscriptionQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionQuota.
     */
    data: XOR<SubscriptionQuotaUpdateInput, SubscriptionQuotaUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionQuota to update.
     */
    where: SubscriptionQuotaWhereUniqueInput
  }

  /**
   * SubscriptionQuota updateMany
   */
  export type SubscriptionQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionQuotas.
     */
    data: XOR<SubscriptionQuotaUpdateManyMutationInput, SubscriptionQuotaUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionQuotas to update
     */
    where?: SubscriptionQuotaWhereInput
  }

  /**
   * SubscriptionQuota upsert
   */
  export type SubscriptionQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionQuota to update in case it exists.
     */
    where: SubscriptionQuotaWhereUniqueInput
    /**
     * In case the SubscriptionQuota found by the `where` argument doesn't exist, create a new SubscriptionQuota with this data.
     */
    create: XOR<SubscriptionQuotaCreateInput, SubscriptionQuotaUncheckedCreateInput>
    /**
     * In case the SubscriptionQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionQuotaUpdateInput, SubscriptionQuotaUncheckedUpdateInput>
  }

  /**
   * SubscriptionQuota delete
   */
  export type SubscriptionQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionQuota to delete.
     */
    where: SubscriptionQuotaWhereUniqueInput
  }

  /**
   * SubscriptionQuota deleteMany
   */
  export type SubscriptionQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionQuotas to delete
     */
    where?: SubscriptionQuotaWhereInput
  }

  /**
   * SubscriptionQuota without action
   */
  export type SubscriptionQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionQuota
     */
    select?: SubscriptionQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionQuotaInclude<ExtArgs> | null
  }


  /**
   * Model NutritionPreference
   */

  export type AggregateNutritionPreference = {
    _count: NutritionPreferenceCountAggregateOutputType | null
    _min: NutritionPreferenceMinAggregateOutputType | null
    _max: NutritionPreferenceMaxAggregateOutputType | null
  }

  export type NutritionPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    additionalNotes: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    additionalNotes: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    proteinSources: number
    proteinAllergies: number
    dinnerPreferences: number
    additionalNotes: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NutritionPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    additionalNotes?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    additionalNotes?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    proteinSources?: true
    proteinAllergies?: true
    dinnerPreferences?: true
    additionalNotes?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NutritionPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionPreference to aggregate.
     */
    where?: NutritionPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionPreferences to fetch.
     */
    orderBy?: NutritionPreferenceOrderByWithRelationInput | NutritionPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutritionPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutritionPreferences
    **/
    _count?: true | NutritionPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionPreferenceMaxAggregateInputType
  }

  export type GetNutritionPreferenceAggregateType<T extends NutritionPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionPreference[P]>
      : GetScalarType<T[P], AggregateNutritionPreference[P]>
  }




  export type NutritionPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionPreferenceWhereInput
    orderBy?: NutritionPreferenceOrderByWithAggregationInput | NutritionPreferenceOrderByWithAggregationInput[]
    by: NutritionPreferenceScalarFieldEnum[] | NutritionPreferenceScalarFieldEnum
    having?: NutritionPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionPreferenceCountAggregateInputType | true
    _min?: NutritionPreferenceMinAggregateInputType
    _max?: NutritionPreferenceMaxAggregateInputType
  }

  export type NutritionPreferenceGroupByOutputType = {
    id: string
    userId: string
    proteinSources: string[]
    proteinAllergies: string[]
    dinnerPreferences: JsonValue | null
    additionalNotes: string | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NutritionPreferenceCountAggregateOutputType | null
    _min: NutritionPreferenceMinAggregateOutputType | null
    _max: NutritionPreferenceMaxAggregateOutputType | null
  }

  type GetNutritionPreferenceGroupByPayload<T extends NutritionPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NutritionPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    proteinSources?: boolean
    proteinAllergies?: boolean
    dinnerPreferences?: boolean
    additionalNotes?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionPreference"]>

  export type NutritionPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    proteinSources?: boolean
    proteinAllergies?: boolean
    dinnerPreferences?: boolean
    additionalNotes?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionPreference"]>

  export type NutritionPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    proteinSources?: boolean
    proteinAllergies?: boolean
    dinnerPreferences?: boolean
    additionalNotes?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NutritionPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NutritionPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NutritionPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NutritionPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      proteinSources: string[]
      proteinAllergies: string[]
      dinnerPreferences: Prisma.JsonValue | null
      additionalNotes: string | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nutritionPreference"]>
    composites: {}
  }

  type NutritionPreferenceGetPayload<S extends boolean | null | undefined | NutritionPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NutritionPreferencePayload, S>

  type NutritionPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NutritionPreferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NutritionPreferenceCountAggregateInputType | true
    }

  export interface NutritionPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NutritionPreference'], meta: { name: 'NutritionPreference' } }
    /**
     * Find zero or one NutritionPreference that matches the filter.
     * @param {NutritionPreferenceFindUniqueArgs} args - Arguments to find a NutritionPreference
     * @example
     * // Get one NutritionPreference
     * const nutritionPreference = await prisma.nutritionPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutritionPreferenceFindUniqueArgs>(args: SelectSubset<T, NutritionPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NutritionPreferenceClient<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NutritionPreference that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NutritionPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NutritionPreference
     * @example
     * // Get one NutritionPreference
     * const nutritionPreference = await prisma.nutritionPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutritionPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NutritionPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutritionPreferenceClient<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NutritionPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionPreferenceFindFirstArgs} args - Arguments to find a NutritionPreference
     * @example
     * // Get one NutritionPreference
     * const nutritionPreference = await prisma.nutritionPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutritionPreferenceFindFirstArgs>(args?: SelectSubset<T, NutritionPreferenceFindFirstArgs<ExtArgs>>): Prisma__NutritionPreferenceClient<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NutritionPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionPreferenceFindFirstOrThrowArgs} args - Arguments to find a NutritionPreference
     * @example
     * // Get one NutritionPreference
     * const nutritionPreference = await prisma.nutritionPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutritionPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NutritionPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutritionPreferenceClient<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NutritionPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionPreferences
     * const nutritionPreferences = await prisma.nutritionPreference.findMany()
     * 
     * // Get first 10 NutritionPreferences
     * const nutritionPreferences = await prisma.nutritionPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionPreferenceWithIdOnly = await prisma.nutritionPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NutritionPreferenceFindManyArgs>(args?: SelectSubset<T, NutritionPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NutritionPreference.
     * @param {NutritionPreferenceCreateArgs} args - Arguments to create a NutritionPreference.
     * @example
     * // Create one NutritionPreference
     * const NutritionPreference = await prisma.nutritionPreference.create({
     *   data: {
     *     // ... data to create a NutritionPreference
     *   }
     * })
     * 
     */
    create<T extends NutritionPreferenceCreateArgs>(args: SelectSubset<T, NutritionPreferenceCreateArgs<ExtArgs>>): Prisma__NutritionPreferenceClient<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NutritionPreferences.
     * @param {NutritionPreferenceCreateManyArgs} args - Arguments to create many NutritionPreferences.
     * @example
     * // Create many NutritionPreferences
     * const nutritionPreference = await prisma.nutritionPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutritionPreferenceCreateManyArgs>(args?: SelectSubset<T, NutritionPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutritionPreferences and returns the data saved in the database.
     * @param {NutritionPreferenceCreateManyAndReturnArgs} args - Arguments to create many NutritionPreferences.
     * @example
     * // Create many NutritionPreferences
     * const nutritionPreference = await prisma.nutritionPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutritionPreferences and only return the `id`
     * const nutritionPreferenceWithIdOnly = await prisma.nutritionPreference.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NutritionPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NutritionPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NutritionPreference.
     * @param {NutritionPreferenceDeleteArgs} args - Arguments to delete one NutritionPreference.
     * @example
     * // Delete one NutritionPreference
     * const NutritionPreference = await prisma.nutritionPreference.delete({
     *   where: {
     *     // ... filter to delete one NutritionPreference
     *   }
     * })
     * 
     */
    delete<T extends NutritionPreferenceDeleteArgs>(args: SelectSubset<T, NutritionPreferenceDeleteArgs<ExtArgs>>): Prisma__NutritionPreferenceClient<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NutritionPreference.
     * @param {NutritionPreferenceUpdateArgs} args - Arguments to update one NutritionPreference.
     * @example
     * // Update one NutritionPreference
     * const nutritionPreference = await prisma.nutritionPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutritionPreferenceUpdateArgs>(args: SelectSubset<T, NutritionPreferenceUpdateArgs<ExtArgs>>): Prisma__NutritionPreferenceClient<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NutritionPreferences.
     * @param {NutritionPreferenceDeleteManyArgs} args - Arguments to filter NutritionPreferences to delete.
     * @example
     * // Delete a few NutritionPreferences
     * const { count } = await prisma.nutritionPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutritionPreferenceDeleteManyArgs>(args?: SelectSubset<T, NutritionPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionPreferences
     * const nutritionPreference = await prisma.nutritionPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutritionPreferenceUpdateManyArgs>(args: SelectSubset<T, NutritionPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NutritionPreference.
     * @param {NutritionPreferenceUpsertArgs} args - Arguments to update or create a NutritionPreference.
     * @example
     * // Update or create a NutritionPreference
     * const nutritionPreference = await prisma.nutritionPreference.upsert({
     *   create: {
     *     // ... data to create a NutritionPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionPreference we want to update
     *   }
     * })
     */
    upsert<T extends NutritionPreferenceUpsertArgs>(args: SelectSubset<T, NutritionPreferenceUpsertArgs<ExtArgs>>): Prisma__NutritionPreferenceClient<$Result.GetResult<Prisma.$NutritionPreferencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NutritionPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionPreferenceCountArgs} args - Arguments to filter NutritionPreferences to count.
     * @example
     * // Count the number of NutritionPreferences
     * const count = await prisma.nutritionPreference.count({
     *   where: {
     *     // ... the filter for the NutritionPreferences we want to count
     *   }
     * })
    **/
    count<T extends NutritionPreferenceCountArgs>(
      args?: Subset<T, NutritionPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionPreferenceAggregateArgs>(args: Subset<T, NutritionPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNutritionPreferenceAggregateType<T>>

    /**
     * Group by NutritionPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutritionPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutritionPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NutritionPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutritionPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NutritionPreference model
   */
  readonly fields: NutritionPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutritionPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutritionPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NutritionPreference model
   */ 
  interface NutritionPreferenceFieldRefs {
    readonly id: FieldRef<"NutritionPreference", 'String'>
    readonly userId: FieldRef<"NutritionPreference", 'String'>
    readonly proteinSources: FieldRef<"NutritionPreference", 'String[]'>
    readonly proteinAllergies: FieldRef<"NutritionPreference", 'String[]'>
    readonly dinnerPreferences: FieldRef<"NutritionPreference", 'Json'>
    readonly additionalNotes: FieldRef<"NutritionPreference", 'String'>
    readonly completedAt: FieldRef<"NutritionPreference", 'DateTime'>
    readonly createdAt: FieldRef<"NutritionPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"NutritionPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NutritionPreference findUnique
   */
  export type NutritionPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NutritionPreference to fetch.
     */
    where: NutritionPreferenceWhereUniqueInput
  }

  /**
   * NutritionPreference findUniqueOrThrow
   */
  export type NutritionPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NutritionPreference to fetch.
     */
    where: NutritionPreferenceWhereUniqueInput
  }

  /**
   * NutritionPreference findFirst
   */
  export type NutritionPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NutritionPreference to fetch.
     */
    where?: NutritionPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionPreferences to fetch.
     */
    orderBy?: NutritionPreferenceOrderByWithRelationInput | NutritionPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionPreferences.
     */
    cursor?: NutritionPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionPreferences.
     */
    distinct?: NutritionPreferenceScalarFieldEnum | NutritionPreferenceScalarFieldEnum[]
  }

  /**
   * NutritionPreference findFirstOrThrow
   */
  export type NutritionPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NutritionPreference to fetch.
     */
    where?: NutritionPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionPreferences to fetch.
     */
    orderBy?: NutritionPreferenceOrderByWithRelationInput | NutritionPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionPreferences.
     */
    cursor?: NutritionPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionPreferences.
     */
    distinct?: NutritionPreferenceScalarFieldEnum | NutritionPreferenceScalarFieldEnum[]
  }

  /**
   * NutritionPreference findMany
   */
  export type NutritionPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NutritionPreferences to fetch.
     */
    where?: NutritionPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionPreferences to fetch.
     */
    orderBy?: NutritionPreferenceOrderByWithRelationInput | NutritionPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutritionPreferences.
     */
    cursor?: NutritionPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionPreferences.
     */
    skip?: number
    distinct?: NutritionPreferenceScalarFieldEnum | NutritionPreferenceScalarFieldEnum[]
  }

  /**
   * NutritionPreference create
   */
  export type NutritionPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NutritionPreference.
     */
    data: XOR<NutritionPreferenceCreateInput, NutritionPreferenceUncheckedCreateInput>
  }

  /**
   * NutritionPreference createMany
   */
  export type NutritionPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NutritionPreferences.
     */
    data: NutritionPreferenceCreateManyInput | NutritionPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NutritionPreference createManyAndReturn
   */
  export type NutritionPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NutritionPreferences.
     */
    data: NutritionPreferenceCreateManyInput | NutritionPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionPreference update
   */
  export type NutritionPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NutritionPreference.
     */
    data: XOR<NutritionPreferenceUpdateInput, NutritionPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NutritionPreference to update.
     */
    where: NutritionPreferenceWhereUniqueInput
  }

  /**
   * NutritionPreference updateMany
   */
  export type NutritionPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NutritionPreferences.
     */
    data: XOR<NutritionPreferenceUpdateManyMutationInput, NutritionPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NutritionPreferences to update
     */
    where?: NutritionPreferenceWhereInput
  }

  /**
   * NutritionPreference upsert
   */
  export type NutritionPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NutritionPreference to update in case it exists.
     */
    where: NutritionPreferenceWhereUniqueInput
    /**
     * In case the NutritionPreference found by the `where` argument doesn't exist, create a new NutritionPreference with this data.
     */
    create: XOR<NutritionPreferenceCreateInput, NutritionPreferenceUncheckedCreateInput>
    /**
     * In case the NutritionPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutritionPreferenceUpdateInput, NutritionPreferenceUncheckedUpdateInput>
  }

  /**
   * NutritionPreference delete
   */
  export type NutritionPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NutritionPreference to delete.
     */
    where: NutritionPreferenceWhereUniqueInput
  }

  /**
   * NutritionPreference deleteMany
   */
  export type NutritionPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionPreferences to delete
     */
    where?: NutritionPreferenceWhereInput
  }

  /**
   * NutritionPreference without action
   */
  export type NutritionPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionPreference
     */
    select?: NutritionPreferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model NutritionAccess
   */

  export type AggregateNutritionAccess = {
    _count: NutritionAccessCountAggregateOutputType | null
    _avg: NutritionAccessAvgAggregateOutputType | null
    _sum: NutritionAccessSumAggregateOutputType | null
    _min: NutritionAccessMinAggregateOutputType | null
    _max: NutritionAccessMaxAggregateOutputType | null
  }

  export type NutritionAccessAvgAggregateOutputType = {
    windowDays: number | null
  }

  export type NutritionAccessSumAggregateOutputType = {
    windowDays: number | null
  }

  export type NutritionAccessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planGeneratedAt: Date | null
    expiresAt: Date | null
    locked: boolean | null
    windowDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionAccessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planGeneratedAt: Date | null
    expiresAt: Date | null
    locked: boolean | null
    windowDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NutritionAccessCountAggregateOutputType = {
    id: number
    userId: number
    planGeneratedAt: number
    expiresAt: number
    locked: number
    windowDays: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NutritionAccessAvgAggregateInputType = {
    windowDays?: true
  }

  export type NutritionAccessSumAggregateInputType = {
    windowDays?: true
  }

  export type NutritionAccessMinAggregateInputType = {
    id?: true
    userId?: true
    planGeneratedAt?: true
    expiresAt?: true
    locked?: true
    windowDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionAccessMaxAggregateInputType = {
    id?: true
    userId?: true
    planGeneratedAt?: true
    expiresAt?: true
    locked?: true
    windowDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NutritionAccessCountAggregateInputType = {
    id?: true
    userId?: true
    planGeneratedAt?: true
    expiresAt?: true
    locked?: true
    windowDays?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NutritionAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionAccess to aggregate.
     */
    where?: NutritionAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionAccesses to fetch.
     */
    orderBy?: NutritionAccessOrderByWithRelationInput | NutritionAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutritionAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutritionAccesses
    **/
    _count?: true | NutritionAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NutritionAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NutritionAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionAccessMaxAggregateInputType
  }

  export type GetNutritionAccessAggregateType<T extends NutritionAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionAccess[P]>
      : GetScalarType<T[P], AggregateNutritionAccess[P]>
  }




  export type NutritionAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionAccessWhereInput
    orderBy?: NutritionAccessOrderByWithAggregationInput | NutritionAccessOrderByWithAggregationInput[]
    by: NutritionAccessScalarFieldEnum[] | NutritionAccessScalarFieldEnum
    having?: NutritionAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionAccessCountAggregateInputType | true
    _avg?: NutritionAccessAvgAggregateInputType
    _sum?: NutritionAccessSumAggregateInputType
    _min?: NutritionAccessMinAggregateInputType
    _max?: NutritionAccessMaxAggregateInputType
  }

  export type NutritionAccessGroupByOutputType = {
    id: string
    userId: string
    planGeneratedAt: Date
    expiresAt: Date | null
    locked: boolean
    windowDays: number | null
    createdAt: Date
    updatedAt: Date
    _count: NutritionAccessCountAggregateOutputType | null
    _avg: NutritionAccessAvgAggregateOutputType | null
    _sum: NutritionAccessSumAggregateOutputType | null
    _min: NutritionAccessMinAggregateOutputType | null
    _max: NutritionAccessMaxAggregateOutputType | null
  }

  type GetNutritionAccessGroupByPayload<T extends NutritionAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionAccessGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionAccessGroupByOutputType[P]>
        }
      >
    >


  export type NutritionAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planGeneratedAt?: boolean
    expiresAt?: boolean
    locked?: boolean
    windowDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionAccess"]>

  export type NutritionAccessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planGeneratedAt?: boolean
    expiresAt?: boolean
    locked?: boolean
    windowDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionAccess"]>

  export type NutritionAccessSelectScalar = {
    id?: boolean
    userId?: boolean
    planGeneratedAt?: boolean
    expiresAt?: boolean
    locked?: boolean
    windowDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NutritionAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NutritionAccessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NutritionAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NutritionAccess"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planGeneratedAt: Date
      expiresAt: Date | null
      locked: boolean
      windowDays: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nutritionAccess"]>
    composites: {}
  }

  type NutritionAccessGetPayload<S extends boolean | null | undefined | NutritionAccessDefaultArgs> = $Result.GetResult<Prisma.$NutritionAccessPayload, S>

  type NutritionAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NutritionAccessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NutritionAccessCountAggregateInputType | true
    }

  export interface NutritionAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NutritionAccess'], meta: { name: 'NutritionAccess' } }
    /**
     * Find zero or one NutritionAccess that matches the filter.
     * @param {NutritionAccessFindUniqueArgs} args - Arguments to find a NutritionAccess
     * @example
     * // Get one NutritionAccess
     * const nutritionAccess = await prisma.nutritionAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutritionAccessFindUniqueArgs>(args: SelectSubset<T, NutritionAccessFindUniqueArgs<ExtArgs>>): Prisma__NutritionAccessClient<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NutritionAccess that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NutritionAccessFindUniqueOrThrowArgs} args - Arguments to find a NutritionAccess
     * @example
     * // Get one NutritionAccess
     * const nutritionAccess = await prisma.nutritionAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutritionAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, NutritionAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutritionAccessClient<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NutritionAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionAccessFindFirstArgs} args - Arguments to find a NutritionAccess
     * @example
     * // Get one NutritionAccess
     * const nutritionAccess = await prisma.nutritionAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutritionAccessFindFirstArgs>(args?: SelectSubset<T, NutritionAccessFindFirstArgs<ExtArgs>>): Prisma__NutritionAccessClient<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NutritionAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionAccessFindFirstOrThrowArgs} args - Arguments to find a NutritionAccess
     * @example
     * // Get one NutritionAccess
     * const nutritionAccess = await prisma.nutritionAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutritionAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, NutritionAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutritionAccessClient<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NutritionAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionAccesses
     * const nutritionAccesses = await prisma.nutritionAccess.findMany()
     * 
     * // Get first 10 NutritionAccesses
     * const nutritionAccesses = await prisma.nutritionAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionAccessWithIdOnly = await prisma.nutritionAccess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NutritionAccessFindManyArgs>(args?: SelectSubset<T, NutritionAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NutritionAccess.
     * @param {NutritionAccessCreateArgs} args - Arguments to create a NutritionAccess.
     * @example
     * // Create one NutritionAccess
     * const NutritionAccess = await prisma.nutritionAccess.create({
     *   data: {
     *     // ... data to create a NutritionAccess
     *   }
     * })
     * 
     */
    create<T extends NutritionAccessCreateArgs>(args: SelectSubset<T, NutritionAccessCreateArgs<ExtArgs>>): Prisma__NutritionAccessClient<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NutritionAccesses.
     * @param {NutritionAccessCreateManyArgs} args - Arguments to create many NutritionAccesses.
     * @example
     * // Create many NutritionAccesses
     * const nutritionAccess = await prisma.nutritionAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutritionAccessCreateManyArgs>(args?: SelectSubset<T, NutritionAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutritionAccesses and returns the data saved in the database.
     * @param {NutritionAccessCreateManyAndReturnArgs} args - Arguments to create many NutritionAccesses.
     * @example
     * // Create many NutritionAccesses
     * const nutritionAccess = await prisma.nutritionAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutritionAccesses and only return the `id`
     * const nutritionAccessWithIdOnly = await prisma.nutritionAccess.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NutritionAccessCreateManyAndReturnArgs>(args?: SelectSubset<T, NutritionAccessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NutritionAccess.
     * @param {NutritionAccessDeleteArgs} args - Arguments to delete one NutritionAccess.
     * @example
     * // Delete one NutritionAccess
     * const NutritionAccess = await prisma.nutritionAccess.delete({
     *   where: {
     *     // ... filter to delete one NutritionAccess
     *   }
     * })
     * 
     */
    delete<T extends NutritionAccessDeleteArgs>(args: SelectSubset<T, NutritionAccessDeleteArgs<ExtArgs>>): Prisma__NutritionAccessClient<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NutritionAccess.
     * @param {NutritionAccessUpdateArgs} args - Arguments to update one NutritionAccess.
     * @example
     * // Update one NutritionAccess
     * const nutritionAccess = await prisma.nutritionAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutritionAccessUpdateArgs>(args: SelectSubset<T, NutritionAccessUpdateArgs<ExtArgs>>): Prisma__NutritionAccessClient<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NutritionAccesses.
     * @param {NutritionAccessDeleteManyArgs} args - Arguments to filter NutritionAccesses to delete.
     * @example
     * // Delete a few NutritionAccesses
     * const { count } = await prisma.nutritionAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutritionAccessDeleteManyArgs>(args?: SelectSubset<T, NutritionAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionAccesses
     * const nutritionAccess = await prisma.nutritionAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutritionAccessUpdateManyArgs>(args: SelectSubset<T, NutritionAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NutritionAccess.
     * @param {NutritionAccessUpsertArgs} args - Arguments to update or create a NutritionAccess.
     * @example
     * // Update or create a NutritionAccess
     * const nutritionAccess = await prisma.nutritionAccess.upsert({
     *   create: {
     *     // ... data to create a NutritionAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionAccess we want to update
     *   }
     * })
     */
    upsert<T extends NutritionAccessUpsertArgs>(args: SelectSubset<T, NutritionAccessUpsertArgs<ExtArgs>>): Prisma__NutritionAccessClient<$Result.GetResult<Prisma.$NutritionAccessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NutritionAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionAccessCountArgs} args - Arguments to filter NutritionAccesses to count.
     * @example
     * // Count the number of NutritionAccesses
     * const count = await prisma.nutritionAccess.count({
     *   where: {
     *     // ... the filter for the NutritionAccesses we want to count
     *   }
     * })
    **/
    count<T extends NutritionAccessCountArgs>(
      args?: Subset<T, NutritionAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionAccessAggregateArgs>(args: Subset<T, NutritionAccessAggregateArgs>): Prisma.PrismaPromise<GetNutritionAccessAggregateType<T>>

    /**
     * Group by NutritionAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutritionAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutritionAccessGroupByArgs['orderBy'] }
        : { orderBy?: NutritionAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutritionAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NutritionAccess model
   */
  readonly fields: NutritionAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutritionAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutritionAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NutritionAccess model
   */ 
  interface NutritionAccessFieldRefs {
    readonly id: FieldRef<"NutritionAccess", 'String'>
    readonly userId: FieldRef<"NutritionAccess", 'String'>
    readonly planGeneratedAt: FieldRef<"NutritionAccess", 'DateTime'>
    readonly expiresAt: FieldRef<"NutritionAccess", 'DateTime'>
    readonly locked: FieldRef<"NutritionAccess", 'Boolean'>
    readonly windowDays: FieldRef<"NutritionAccess", 'Int'>
    readonly createdAt: FieldRef<"NutritionAccess", 'DateTime'>
    readonly updatedAt: FieldRef<"NutritionAccess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NutritionAccess findUnique
   */
  export type NutritionAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
    /**
     * Filter, which NutritionAccess to fetch.
     */
    where: NutritionAccessWhereUniqueInput
  }

  /**
   * NutritionAccess findUniqueOrThrow
   */
  export type NutritionAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
    /**
     * Filter, which NutritionAccess to fetch.
     */
    where: NutritionAccessWhereUniqueInput
  }

  /**
   * NutritionAccess findFirst
   */
  export type NutritionAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
    /**
     * Filter, which NutritionAccess to fetch.
     */
    where?: NutritionAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionAccesses to fetch.
     */
    orderBy?: NutritionAccessOrderByWithRelationInput | NutritionAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionAccesses.
     */
    cursor?: NutritionAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionAccesses.
     */
    distinct?: NutritionAccessScalarFieldEnum | NutritionAccessScalarFieldEnum[]
  }

  /**
   * NutritionAccess findFirstOrThrow
   */
  export type NutritionAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
    /**
     * Filter, which NutritionAccess to fetch.
     */
    where?: NutritionAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionAccesses to fetch.
     */
    orderBy?: NutritionAccessOrderByWithRelationInput | NutritionAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionAccesses.
     */
    cursor?: NutritionAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionAccesses.
     */
    distinct?: NutritionAccessScalarFieldEnum | NutritionAccessScalarFieldEnum[]
  }

  /**
   * NutritionAccess findMany
   */
  export type NutritionAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
    /**
     * Filter, which NutritionAccesses to fetch.
     */
    where?: NutritionAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionAccesses to fetch.
     */
    orderBy?: NutritionAccessOrderByWithRelationInput | NutritionAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutritionAccesses.
     */
    cursor?: NutritionAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionAccesses.
     */
    skip?: number
    distinct?: NutritionAccessScalarFieldEnum | NutritionAccessScalarFieldEnum[]
  }

  /**
   * NutritionAccess create
   */
  export type NutritionAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
    /**
     * The data needed to create a NutritionAccess.
     */
    data: XOR<NutritionAccessCreateInput, NutritionAccessUncheckedCreateInput>
  }

  /**
   * NutritionAccess createMany
   */
  export type NutritionAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NutritionAccesses.
     */
    data: NutritionAccessCreateManyInput | NutritionAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NutritionAccess createManyAndReturn
   */
  export type NutritionAccessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NutritionAccesses.
     */
    data: NutritionAccessCreateManyInput | NutritionAccessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionAccess update
   */
  export type NutritionAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
    /**
     * The data needed to update a NutritionAccess.
     */
    data: XOR<NutritionAccessUpdateInput, NutritionAccessUncheckedUpdateInput>
    /**
     * Choose, which NutritionAccess to update.
     */
    where: NutritionAccessWhereUniqueInput
  }

  /**
   * NutritionAccess updateMany
   */
  export type NutritionAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NutritionAccesses.
     */
    data: XOR<NutritionAccessUpdateManyMutationInput, NutritionAccessUncheckedUpdateManyInput>
    /**
     * Filter which NutritionAccesses to update
     */
    where?: NutritionAccessWhereInput
  }

  /**
   * NutritionAccess upsert
   */
  export type NutritionAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
    /**
     * The filter to search for the NutritionAccess to update in case it exists.
     */
    where: NutritionAccessWhereUniqueInput
    /**
     * In case the NutritionAccess found by the `where` argument doesn't exist, create a new NutritionAccess with this data.
     */
    create: XOR<NutritionAccessCreateInput, NutritionAccessUncheckedCreateInput>
    /**
     * In case the NutritionAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutritionAccessUpdateInput, NutritionAccessUncheckedUpdateInput>
  }

  /**
   * NutritionAccess delete
   */
  export type NutritionAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
    /**
     * Filter which NutritionAccess to delete.
     */
    where: NutritionAccessWhereUniqueInput
  }

  /**
   * NutritionAccess deleteMany
   */
  export type NutritionAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionAccesses to delete
     */
    where?: NutritionAccessWhereInput
  }

  /**
   * NutritionAccess without action
   */
  export type NutritionAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionAccess
     */
    select?: NutritionAccessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionAccessInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    preferredLocale: 'preferredLocale',
    deviceToken: 'deviceToken',
    role: 'role',
    coachId: 'coachId',
    coachClientsId: 'coachClientsId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    coachId: 'coachId',
    scheduledAt: 'scheduledAt',
    durationMin: 'durationMin',
    status: 'status',
    agoraChannel: 'agoraChannel',
    rating: 'rating',
    ratingNote: 'ratingNote',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalCents: 'totalCents',
    currency: 'currency',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    sku: 'sku',
    qty: 'qty',
    priceCents: 'priceCents'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const CoachScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bio: 'bio',
    certifications: 'certifications',
    referralCode: 'referralCode',
    specializations: 'specializations',
    experienceYears: 'experienceYears',
    headline: 'headline',
    verified: 'verified'
  };

  export type CoachScalarFieldEnum = (typeof CoachScalarFieldEnum)[keyof typeof CoachScalarFieldEnum]


  export const CoachCertificateScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    name: 'name',
    issuingOrganization: 'issuingOrganization',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    certificateUrl: 'certificateUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoachCertificateScalarFieldEnum = (typeof CoachCertificateScalarFieldEnum)[keyof typeof CoachCertificateScalarFieldEnum]


  export const CoachExperienceScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    title: 'title',
    organization: 'organization',
    startDate: 'startDate',
    endDate: 'endDate',
    isCurrent: 'isCurrent',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoachExperienceScalarFieldEnum = (typeof CoachExperienceScalarFieldEnum)[keyof typeof CoachExperienceScalarFieldEnum]


  export const CoachAchievementScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    title: 'title',
    description: 'description',
    achievedAt: 'achievedAt',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoachAchievementScalarFieldEnum = (typeof CoachAchievementScalarFieldEnum)[keyof typeof CoachAchievementScalarFieldEnum]


  export const WorkoutLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    activity: 'activity',
    duration: 'duration',
    notes: 'notes'
  };

  export type WorkoutLogScalarFieldEnum = (typeof WorkoutLogScalarFieldEnum)[keyof typeof WorkoutLogScalarFieldEnum]


  export const NutritionLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    meal: 'meal',
    calories: 'calories',
    protein: 'protein',
    carbs: 'carbs',
    fats: 'fats',
    mealType: 'mealType',
    notes: 'notes'
  };

  export type NutritionLogScalarFieldEnum = (typeof NutritionLogScalarFieldEnum)[keyof typeof NutritionLogScalarFieldEnum]


  export const SupplementLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    supplementName: 'supplementName',
    dose: 'dose',
    notes: 'notes'
  };

  export type SupplementLogScalarFieldEnum = (typeof SupplementLogScalarFieldEnum)[keyof typeof SupplementLogScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    status: 'status',
    planCode: 'planCode',
    currentPeriodEnd: 'currentPeriodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const RecommendationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    coachId: 'coachId',
    type: 'type',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type RecommendationScalarFieldEnum = (typeof RecommendationScalarFieldEnum)[keyof typeof RecommendationScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const BundleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price'
  };

  export type BundleScalarFieldEnum = (typeof BundleScalarFieldEnum)[keyof typeof BundleScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    description: 'description',
    price: 'price',
    priceCents: 'priceCents',
    currency: 'currency',
    inventory: 'inventory',
    categoryId: 'categoryId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const DeliveryScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    status: 'status',
    trackingUrl: 'trackingUrl',
    address: 'address',
    courier: 'courier',
    estimatedDate: 'estimatedDate',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type DeliveryScalarFieldEnum = (typeof DeliveryScalarFieldEnum)[keyof typeof DeliveryScalarFieldEnum]


  export const AffiliateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    referralCode: 'referralCode',
    brandUrl: 'brandUrl'
  };

  export type AffiliateScalarFieldEnum = (typeof AffiliateScalarFieldEnum)[keyof typeof AffiliateScalarFieldEnum]


  export const CoachMessageScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    userId: 'userId',
    sender: 'sender',
    body: 'body',
    attachmentUrl: 'attachmentUrl',
    attachmentName: 'attachmentName',
    attachmentType: 'attachmentType',
    attachmentSize: 'attachmentSize',
    createdAt: 'createdAt'
  };

  export type CoachMessageScalarFieldEnum = (typeof CoachMessageScalarFieldEnum)[keyof typeof CoachMessageScalarFieldEnum]


  export const CommissionScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    orderId: 'orderId',
    affiliateId: 'affiliateId',
    amount: 'amount',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type CommissionScalarFieldEnum = (typeof CommissionScalarFieldEnum)[keyof typeof CommissionScalarFieldEnum]


  export const AnalyticsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    revenue: 'revenue',
    engagement: 'engagement',
    supplementSales: 'supplementSales'
  };

  export type AnalyticsScalarFieldEnum = (typeof AnalyticsScalarFieldEnum)[keyof typeof AnalyticsScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    description: 'description',
    achievedAt: 'achievedAt'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orderId: 'orderId',
    subscriptionId: 'subscriptionId',
    amount: 'amount',
    amountCents: 'amountCents',
    currency: 'currency',
    status: 'status',
    provider: 'provider',
    providerId: 'providerId',
    raw: 'raw',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const WebhookEventScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    eventId: 'eventId',
    payload: 'payload',
    processed: 'processed',
    createdAt: 'createdAt'
  };

  export type WebhookEventScalarFieldEnum = (typeof WebhookEventScalarFieldEnum)[keyof typeof WebhookEventScalarFieldEnum]


  export const CoachRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type CoachRequestScalarFieldEnum = (typeof CoachRequestScalarFieldEnum)[keyof typeof CoachRequestScalarFieldEnum]


  export const UserIntakeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gender: 'gender',
    mainGoal: 'mainGoal',
    workoutLocation: 'workoutLocation',
    firstCompletedAt: 'firstCompletedAt',
    age: 'age',
    weightKg: 'weightKg',
    heightCm: 'heightCm',
    experienceLevel: 'experienceLevel',
    workoutFrequency: 'workoutFrequency',
    injuries: 'injuries',
    secondCompletedAt: 'secondCompletedAt',
    skippedSecond: 'skippedSecond',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserIntakeScalarFieldEnum = (typeof UserIntakeScalarFieldEnum)[keyof typeof UserIntakeScalarFieldEnum]


  export const SubscriptionQuotaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tier: 'tier',
    messagesUsed: 'messagesUsed',
    callsUsed: 'callsUsed',
    attachmentsUsed: 'attachmentsUsed',
    resetAt: 'resetAt',
    nutritionWindowDays: 'nutritionWindowDays',
    nutritionExpiresAt: 'nutritionExpiresAt',
    nutritionLocked: 'nutritionLocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionQuotaScalarFieldEnum = (typeof SubscriptionQuotaScalarFieldEnum)[keyof typeof SubscriptionQuotaScalarFieldEnum]


  export const NutritionPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    proteinSources: 'proteinSources',
    proteinAllergies: 'proteinAllergies',
    dinnerPreferences: 'dinnerPreferences',
    additionalNotes: 'additionalNotes',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NutritionPreferenceScalarFieldEnum = (typeof NutritionPreferenceScalarFieldEnum)[keyof typeof NutritionPreferenceScalarFieldEnum]


  export const NutritionAccessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planGeneratedAt: 'planGeneratedAt',
    expiresAt: 'expiresAt',
    locked: 'locked',
    windowDays: 'windowDays',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NutritionAccessScalarFieldEnum = (typeof NutritionAccessScalarFieldEnum)[keyof typeof NutritionAccessScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    preferredLocale?: StringNullableFilter<"User"> | string | null
    deviceToken?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    coachId?: StringNullableFilter<"User"> | string | null
    coachClientsId?: StringNullableFilter<"User"> | string | null
    coach?: XOR<CoachNullableRelationFilter, CoachWhereInput> | null
    notifications?: NotificationListRelationFilter
    milestones?: MilestoneListRelationFilter
    payments?: PaymentListRelationFilter
    recommendations?: RecommendationListRelationFilter
    commissions?: CommissionListRelationFilter
    coachClients?: XOR<CoachNullableRelationFilter, CoachWhereInput> | null
    Session?: SessionListRelationFilter
    Order?: OrderListRelationFilter
    WorkoutLog?: WorkoutLogListRelationFilter
    NutritionLog?: NutritionLogListRelationFilter
    SupplementLog?: SupplementLogListRelationFilter
    Subscription?: SubscriptionListRelationFilter
    coachRequests?: CoachRequestListRelationFilter
    intake?: XOR<UserIntakeNullableRelationFilter, UserIntakeWhereInput> | null
    subscriptionQuota?: XOR<SubscriptionQuotaNullableRelationFilter, SubscriptionQuotaWhereInput> | null
    nutritionPreference?: XOR<NutritionPreferenceNullableRelationFilter, NutritionPreferenceWhereInput> | null
    nutritionAccess?: XOR<NutritionAccessNullableRelationFilter, NutritionAccessWhereInput> | null
    coachMessages?: CoachMessageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    preferredLocale?: SortOrderInput | SortOrder
    deviceToken?: SortOrderInput | SortOrder
    role?: SortOrder
    coachId?: SortOrderInput | SortOrder
    coachClientsId?: SortOrderInput | SortOrder
    coach?: CoachOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    milestones?: MilestoneOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    recommendations?: RecommendationOrderByRelationAggregateInput
    commissions?: CommissionOrderByRelationAggregateInput
    coachClients?: CoachOrderByWithRelationInput
    Session?: SessionOrderByRelationAggregateInput
    Order?: OrderOrderByRelationAggregateInput
    WorkoutLog?: WorkoutLogOrderByRelationAggregateInput
    NutritionLog?: NutritionLogOrderByRelationAggregateInput
    SupplementLog?: SupplementLogOrderByRelationAggregateInput
    Subscription?: SubscriptionOrderByRelationAggregateInput
    coachRequests?: CoachRequestOrderByRelationAggregateInput
    intake?: UserIntakeOrderByWithRelationInput
    subscriptionQuota?: SubscriptionQuotaOrderByWithRelationInput
    nutritionPreference?: NutritionPreferenceOrderByWithRelationInput
    nutritionAccess?: NutritionAccessOrderByWithRelationInput
    coachMessages?: CoachMessageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    preferredLocale?: StringNullableFilter<"User"> | string | null
    deviceToken?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    coachId?: StringNullableFilter<"User"> | string | null
    coachClientsId?: StringNullableFilter<"User"> | string | null
    coach?: XOR<CoachNullableRelationFilter, CoachWhereInput> | null
    notifications?: NotificationListRelationFilter
    milestones?: MilestoneListRelationFilter
    payments?: PaymentListRelationFilter
    recommendations?: RecommendationListRelationFilter
    commissions?: CommissionListRelationFilter
    coachClients?: XOR<CoachNullableRelationFilter, CoachWhereInput> | null
    Session?: SessionListRelationFilter
    Order?: OrderListRelationFilter
    WorkoutLog?: WorkoutLogListRelationFilter
    NutritionLog?: NutritionLogListRelationFilter
    SupplementLog?: SupplementLogListRelationFilter
    Subscription?: SubscriptionListRelationFilter
    coachRequests?: CoachRequestListRelationFilter
    intake?: XOR<UserIntakeNullableRelationFilter, UserIntakeWhereInput> | null
    subscriptionQuota?: XOR<SubscriptionQuotaNullableRelationFilter, SubscriptionQuotaWhereInput> | null
    nutritionPreference?: XOR<NutritionPreferenceNullableRelationFilter, NutritionPreferenceWhereInput> | null
    nutritionAccess?: XOR<NutritionAccessNullableRelationFilter, NutritionAccessWhereInput> | null
    coachMessages?: CoachMessageListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    preferredLocale?: SortOrderInput | SortOrder
    deviceToken?: SortOrderInput | SortOrder
    role?: SortOrder
    coachId?: SortOrderInput | SortOrder
    coachClientsId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferredLocale?: StringNullableWithAggregatesFilter<"User"> | string | null
    deviceToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    coachId?: StringNullableWithAggregatesFilter<"User"> | string | null
    coachClientsId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    coachId?: StringNullableFilter<"Session"> | string | null
    scheduledAt?: DateTimeFilter<"Session"> | Date | string
    durationMin?: IntFilter<"Session"> | number
    status?: StringFilter<"Session"> | string
    agoraChannel?: StringNullableFilter<"Session"> | string | null
    rating?: IntNullableFilter<"Session"> | number | null
    ratingNote?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    coach?: XOR<CoachNullableRelationFilter, CoachWhereInput> | null
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrderInput | SortOrder
    scheduledAt?: SortOrder
    durationMin?: SortOrder
    status?: SortOrder
    agoraChannel?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    ratingNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    coach?: CoachOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    coachId?: StringNullableFilter<"Session"> | string | null
    scheduledAt?: DateTimeFilter<"Session"> | Date | string
    durationMin?: IntFilter<"Session"> | number
    status?: StringFilter<"Session"> | string
    agoraChannel?: StringNullableFilter<"Session"> | string | null
    rating?: IntNullableFilter<"Session"> | number | null
    ratingNote?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    coach?: XOR<CoachNullableRelationFilter, CoachWhereInput> | null
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrderInput | SortOrder
    scheduledAt?: SortOrder
    durationMin?: SortOrder
    status?: SortOrder
    agoraChannel?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    ratingNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    coachId?: StringNullableWithAggregatesFilter<"Session"> | string | null
    scheduledAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    durationMin?: IntWithAggregatesFilter<"Session"> | number
    status?: StringWithAggregatesFilter<"Session"> | string
    agoraChannel?: StringNullableWithAggregatesFilter<"Session"> | string | null
    rating?: IntNullableWithAggregatesFilter<"Session"> | number | null
    ratingNote?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    totalCents?: IntFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    items?: OrderItemListRelationFilter
    commissions?: CommissionListRelationFilter
    payments?: PaymentListRelationFilter
    Delivery?: XOR<DeliveryNullableRelationFilter, DeliveryWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    commissions?: CommissionOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    Delivery?: DeliveryOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    totalCents?: IntFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    items?: OrderItemListRelationFilter
    commissions?: CommissionListRelationFilter
    payments?: PaymentListRelationFilter
    Delivery?: XOR<DeliveryNullableRelationFilter, DeliveryWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    totalCents?: IntWithAggregatesFilter<"Order"> | number
    currency?: StringWithAggregatesFilter<"Order"> | string
    status?: StringWithAggregatesFilter<"Order"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    sku?: StringFilter<"OrderItem"> | string
    qty?: IntFilter<"OrderItem"> | number
    priceCents?: IntFilter<"OrderItem"> | number
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    sku?: SortOrder
    qty?: SortOrder
    priceCents?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    sku?: StringFilter<"OrderItem"> | string
    qty?: IntFilter<"OrderItem"> | number
    priceCents?: IntFilter<"OrderItem"> | number
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    sku?: SortOrder
    qty?: SortOrder
    priceCents?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    sku?: StringWithAggregatesFilter<"OrderItem"> | string
    qty?: IntWithAggregatesFilter<"OrderItem"> | number
    priceCents?: IntWithAggregatesFilter<"OrderItem"> | number
  }

  export type CoachWhereInput = {
    AND?: CoachWhereInput | CoachWhereInput[]
    OR?: CoachWhereInput[]
    NOT?: CoachWhereInput | CoachWhereInput[]
    id?: StringFilter<"Coach"> | string
    userId?: StringFilter<"Coach"> | string
    bio?: StringNullableFilter<"Coach"> | string | null
    certifications?: StringNullableFilter<"Coach"> | string | null
    referralCode?: StringNullableFilter<"Coach"> | string | null
    specializations?: StringNullableListFilter<"Coach">
    experienceYears?: IntNullableFilter<"Coach"> | number | null
    headline?: StringNullableFilter<"Coach"> | string | null
    verified?: BoolFilter<"Coach"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    clients?: UserListRelationFilter
    commissions?: CommissionListRelationFilter
    recommendations?: RecommendationListRelationFilter
    sessions?: SessionListRelationFilter
    messages?: CoachMessageListRelationFilter
    certificates?: CoachCertificateListRelationFilter
    experiences?: CoachExperienceListRelationFilter
    achievements?: CoachAchievementListRelationFilter
  }

  export type CoachOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    certifications?: SortOrderInput | SortOrder
    referralCode?: SortOrderInput | SortOrder
    specializations?: SortOrder
    experienceYears?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    verified?: SortOrder
    user?: UserOrderByWithRelationInput
    clients?: UserOrderByRelationAggregateInput
    commissions?: CommissionOrderByRelationAggregateInput
    recommendations?: RecommendationOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    messages?: CoachMessageOrderByRelationAggregateInput
    certificates?: CoachCertificateOrderByRelationAggregateInput
    experiences?: CoachExperienceOrderByRelationAggregateInput
    achievements?: CoachAchievementOrderByRelationAggregateInput
  }

  export type CoachWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CoachWhereInput | CoachWhereInput[]
    OR?: CoachWhereInput[]
    NOT?: CoachWhereInput | CoachWhereInput[]
    bio?: StringNullableFilter<"Coach"> | string | null
    certifications?: StringNullableFilter<"Coach"> | string | null
    referralCode?: StringNullableFilter<"Coach"> | string | null
    specializations?: StringNullableListFilter<"Coach">
    experienceYears?: IntNullableFilter<"Coach"> | number | null
    headline?: StringNullableFilter<"Coach"> | string | null
    verified?: BoolFilter<"Coach"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    clients?: UserListRelationFilter
    commissions?: CommissionListRelationFilter
    recommendations?: RecommendationListRelationFilter
    sessions?: SessionListRelationFilter
    messages?: CoachMessageListRelationFilter
    certificates?: CoachCertificateListRelationFilter
    experiences?: CoachExperienceListRelationFilter
    achievements?: CoachAchievementListRelationFilter
  }, "id" | "userId">

  export type CoachOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    certifications?: SortOrderInput | SortOrder
    referralCode?: SortOrderInput | SortOrder
    specializations?: SortOrder
    experienceYears?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    verified?: SortOrder
    _count?: CoachCountOrderByAggregateInput
    _avg?: CoachAvgOrderByAggregateInput
    _max?: CoachMaxOrderByAggregateInput
    _min?: CoachMinOrderByAggregateInput
    _sum?: CoachSumOrderByAggregateInput
  }

  export type CoachScalarWhereWithAggregatesInput = {
    AND?: CoachScalarWhereWithAggregatesInput | CoachScalarWhereWithAggregatesInput[]
    OR?: CoachScalarWhereWithAggregatesInput[]
    NOT?: CoachScalarWhereWithAggregatesInput | CoachScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coach"> | string
    userId?: StringWithAggregatesFilter<"Coach"> | string
    bio?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    certifications?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    referralCode?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    specializations?: StringNullableListFilter<"Coach">
    experienceYears?: IntNullableWithAggregatesFilter<"Coach"> | number | null
    headline?: StringNullableWithAggregatesFilter<"Coach"> | string | null
    verified?: BoolWithAggregatesFilter<"Coach"> | boolean
  }

  export type CoachCertificateWhereInput = {
    AND?: CoachCertificateWhereInput | CoachCertificateWhereInput[]
    OR?: CoachCertificateWhereInput[]
    NOT?: CoachCertificateWhereInput | CoachCertificateWhereInput[]
    id?: StringFilter<"CoachCertificate"> | string
    coachId?: StringFilter<"CoachCertificate"> | string
    name?: StringFilter<"CoachCertificate"> | string
    issuingOrganization?: StringFilter<"CoachCertificate"> | string
    issuedAt?: DateTimeFilter<"CoachCertificate"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CoachCertificate"> | Date | string | null
    certificateUrl?: StringNullableFilter<"CoachCertificate"> | string | null
    createdAt?: DateTimeFilter<"CoachCertificate"> | Date | string
    updatedAt?: DateTimeFilter<"CoachCertificate"> | Date | string
    coach?: XOR<CoachRelationFilter, CoachWhereInput>
  }

  export type CoachCertificateOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    name?: SortOrder
    issuingOrganization?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coach?: CoachOrderByWithRelationInput
  }

  export type CoachCertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CoachCertificateWhereInput | CoachCertificateWhereInput[]
    OR?: CoachCertificateWhereInput[]
    NOT?: CoachCertificateWhereInput | CoachCertificateWhereInput[]
    coachId?: StringFilter<"CoachCertificate"> | string
    name?: StringFilter<"CoachCertificate"> | string
    issuingOrganization?: StringFilter<"CoachCertificate"> | string
    issuedAt?: DateTimeFilter<"CoachCertificate"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CoachCertificate"> | Date | string | null
    certificateUrl?: StringNullableFilter<"CoachCertificate"> | string | null
    createdAt?: DateTimeFilter<"CoachCertificate"> | Date | string
    updatedAt?: DateTimeFilter<"CoachCertificate"> | Date | string
    coach?: XOR<CoachRelationFilter, CoachWhereInput>
  }, "id">

  export type CoachCertificateOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    name?: SortOrder
    issuingOrganization?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoachCertificateCountOrderByAggregateInput
    _max?: CoachCertificateMaxOrderByAggregateInput
    _min?: CoachCertificateMinOrderByAggregateInput
  }

  export type CoachCertificateScalarWhereWithAggregatesInput = {
    AND?: CoachCertificateScalarWhereWithAggregatesInput | CoachCertificateScalarWhereWithAggregatesInput[]
    OR?: CoachCertificateScalarWhereWithAggregatesInput[]
    NOT?: CoachCertificateScalarWhereWithAggregatesInput | CoachCertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoachCertificate"> | string
    coachId?: StringWithAggregatesFilter<"CoachCertificate"> | string
    name?: StringWithAggregatesFilter<"CoachCertificate"> | string
    issuingOrganization?: StringWithAggregatesFilter<"CoachCertificate"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"CoachCertificate"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"CoachCertificate"> | Date | string | null
    certificateUrl?: StringNullableWithAggregatesFilter<"CoachCertificate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CoachCertificate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoachCertificate"> | Date | string
  }

  export type CoachExperienceWhereInput = {
    AND?: CoachExperienceWhereInput | CoachExperienceWhereInput[]
    OR?: CoachExperienceWhereInput[]
    NOT?: CoachExperienceWhereInput | CoachExperienceWhereInput[]
    id?: StringFilter<"CoachExperience"> | string
    coachId?: StringFilter<"CoachExperience"> | string
    title?: StringFilter<"CoachExperience"> | string
    organization?: StringFilter<"CoachExperience"> | string
    startDate?: DateTimeFilter<"CoachExperience"> | Date | string
    endDate?: DateTimeNullableFilter<"CoachExperience"> | Date | string | null
    isCurrent?: BoolFilter<"CoachExperience"> | boolean
    description?: StringNullableFilter<"CoachExperience"> | string | null
    createdAt?: DateTimeFilter<"CoachExperience"> | Date | string
    updatedAt?: DateTimeFilter<"CoachExperience"> | Date | string
    coach?: XOR<CoachRelationFilter, CoachWhereInput>
  }

  export type CoachExperienceOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    organization?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isCurrent?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coach?: CoachOrderByWithRelationInput
  }

  export type CoachExperienceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CoachExperienceWhereInput | CoachExperienceWhereInput[]
    OR?: CoachExperienceWhereInput[]
    NOT?: CoachExperienceWhereInput | CoachExperienceWhereInput[]
    coachId?: StringFilter<"CoachExperience"> | string
    title?: StringFilter<"CoachExperience"> | string
    organization?: StringFilter<"CoachExperience"> | string
    startDate?: DateTimeFilter<"CoachExperience"> | Date | string
    endDate?: DateTimeNullableFilter<"CoachExperience"> | Date | string | null
    isCurrent?: BoolFilter<"CoachExperience"> | boolean
    description?: StringNullableFilter<"CoachExperience"> | string | null
    createdAt?: DateTimeFilter<"CoachExperience"> | Date | string
    updatedAt?: DateTimeFilter<"CoachExperience"> | Date | string
    coach?: XOR<CoachRelationFilter, CoachWhereInput>
  }, "id">

  export type CoachExperienceOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    organization?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isCurrent?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoachExperienceCountOrderByAggregateInput
    _max?: CoachExperienceMaxOrderByAggregateInput
    _min?: CoachExperienceMinOrderByAggregateInput
  }

  export type CoachExperienceScalarWhereWithAggregatesInput = {
    AND?: CoachExperienceScalarWhereWithAggregatesInput | CoachExperienceScalarWhereWithAggregatesInput[]
    OR?: CoachExperienceScalarWhereWithAggregatesInput[]
    NOT?: CoachExperienceScalarWhereWithAggregatesInput | CoachExperienceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoachExperience"> | string
    coachId?: StringWithAggregatesFilter<"CoachExperience"> | string
    title?: StringWithAggregatesFilter<"CoachExperience"> | string
    organization?: StringWithAggregatesFilter<"CoachExperience"> | string
    startDate?: DateTimeWithAggregatesFilter<"CoachExperience"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"CoachExperience"> | Date | string | null
    isCurrent?: BoolWithAggregatesFilter<"CoachExperience"> | boolean
    description?: StringNullableWithAggregatesFilter<"CoachExperience"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CoachExperience"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoachExperience"> | Date | string
  }

  export type CoachAchievementWhereInput = {
    AND?: CoachAchievementWhereInput | CoachAchievementWhereInput[]
    OR?: CoachAchievementWhereInput[]
    NOT?: CoachAchievementWhereInput | CoachAchievementWhereInput[]
    id?: StringFilter<"CoachAchievement"> | string
    coachId?: StringFilter<"CoachAchievement"> | string
    title?: StringFilter<"CoachAchievement"> | string
    description?: StringNullableFilter<"CoachAchievement"> | string | null
    achievedAt?: DateTimeFilter<"CoachAchievement"> | Date | string
    type?: StringFilter<"CoachAchievement"> | string
    createdAt?: DateTimeFilter<"CoachAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"CoachAchievement"> | Date | string
    coach?: XOR<CoachRelationFilter, CoachWhereInput>
  }

  export type CoachAchievementOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    achievedAt?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coach?: CoachOrderByWithRelationInput
  }

  export type CoachAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CoachAchievementWhereInput | CoachAchievementWhereInput[]
    OR?: CoachAchievementWhereInput[]
    NOT?: CoachAchievementWhereInput | CoachAchievementWhereInput[]
    coachId?: StringFilter<"CoachAchievement"> | string
    title?: StringFilter<"CoachAchievement"> | string
    description?: StringNullableFilter<"CoachAchievement"> | string | null
    achievedAt?: DateTimeFilter<"CoachAchievement"> | Date | string
    type?: StringFilter<"CoachAchievement"> | string
    createdAt?: DateTimeFilter<"CoachAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"CoachAchievement"> | Date | string
    coach?: XOR<CoachRelationFilter, CoachWhereInput>
  }, "id">

  export type CoachAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    achievedAt?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoachAchievementCountOrderByAggregateInput
    _max?: CoachAchievementMaxOrderByAggregateInput
    _min?: CoachAchievementMinOrderByAggregateInput
  }

  export type CoachAchievementScalarWhereWithAggregatesInput = {
    AND?: CoachAchievementScalarWhereWithAggregatesInput | CoachAchievementScalarWhereWithAggregatesInput[]
    OR?: CoachAchievementScalarWhereWithAggregatesInput[]
    NOT?: CoachAchievementScalarWhereWithAggregatesInput | CoachAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoachAchievement"> | string
    coachId?: StringWithAggregatesFilter<"CoachAchievement"> | string
    title?: StringWithAggregatesFilter<"CoachAchievement"> | string
    description?: StringNullableWithAggregatesFilter<"CoachAchievement"> | string | null
    achievedAt?: DateTimeWithAggregatesFilter<"CoachAchievement"> | Date | string
    type?: StringWithAggregatesFilter<"CoachAchievement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CoachAchievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoachAchievement"> | Date | string
  }

  export type WorkoutLogWhereInput = {
    AND?: WorkoutLogWhereInput | WorkoutLogWhereInput[]
    OR?: WorkoutLogWhereInput[]
    NOT?: WorkoutLogWhereInput | WorkoutLogWhereInput[]
    id?: StringFilter<"WorkoutLog"> | string
    userId?: StringFilter<"WorkoutLog"> | string
    date?: DateTimeFilter<"WorkoutLog"> | Date | string
    activity?: StringFilter<"WorkoutLog"> | string
    duration?: IntFilter<"WorkoutLog"> | number
    notes?: StringNullableFilter<"WorkoutLog"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WorkoutLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    activity?: SortOrder
    duration?: SortOrder
    notes?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WorkoutLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkoutLogWhereInput | WorkoutLogWhereInput[]
    OR?: WorkoutLogWhereInput[]
    NOT?: WorkoutLogWhereInput | WorkoutLogWhereInput[]
    userId?: StringFilter<"WorkoutLog"> | string
    date?: DateTimeFilter<"WorkoutLog"> | Date | string
    activity?: StringFilter<"WorkoutLog"> | string
    duration?: IntFilter<"WorkoutLog"> | number
    notes?: StringNullableFilter<"WorkoutLog"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type WorkoutLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    activity?: SortOrder
    duration?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: WorkoutLogCountOrderByAggregateInput
    _avg?: WorkoutLogAvgOrderByAggregateInput
    _max?: WorkoutLogMaxOrderByAggregateInput
    _min?: WorkoutLogMinOrderByAggregateInput
    _sum?: WorkoutLogSumOrderByAggregateInput
  }

  export type WorkoutLogScalarWhereWithAggregatesInput = {
    AND?: WorkoutLogScalarWhereWithAggregatesInput | WorkoutLogScalarWhereWithAggregatesInput[]
    OR?: WorkoutLogScalarWhereWithAggregatesInput[]
    NOT?: WorkoutLogScalarWhereWithAggregatesInput | WorkoutLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkoutLog"> | string
    userId?: StringWithAggregatesFilter<"WorkoutLog"> | string
    date?: DateTimeWithAggregatesFilter<"WorkoutLog"> | Date | string
    activity?: StringWithAggregatesFilter<"WorkoutLog"> | string
    duration?: IntWithAggregatesFilter<"WorkoutLog"> | number
    notes?: StringNullableWithAggregatesFilter<"WorkoutLog"> | string | null
  }

  export type NutritionLogWhereInput = {
    AND?: NutritionLogWhereInput | NutritionLogWhereInput[]
    OR?: NutritionLogWhereInput[]
    NOT?: NutritionLogWhereInput | NutritionLogWhereInput[]
    id?: StringFilter<"NutritionLog"> | string
    userId?: StringFilter<"NutritionLog"> | string
    date?: DateTimeFilter<"NutritionLog"> | Date | string
    meal?: StringFilter<"NutritionLog"> | string
    calories?: IntFilter<"NutritionLog"> | number
    protein?: FloatNullableFilter<"NutritionLog"> | number | null
    carbs?: FloatNullableFilter<"NutritionLog"> | number | null
    fats?: FloatNullableFilter<"NutritionLog"> | number | null
    mealType?: StringNullableFilter<"NutritionLog"> | string | null
    notes?: StringNullableFilter<"NutritionLog"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NutritionLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    meal?: SortOrder
    calories?: SortOrder
    protein?: SortOrderInput | SortOrder
    carbs?: SortOrderInput | SortOrder
    fats?: SortOrderInput | SortOrder
    mealType?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NutritionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NutritionLogWhereInput | NutritionLogWhereInput[]
    OR?: NutritionLogWhereInput[]
    NOT?: NutritionLogWhereInput | NutritionLogWhereInput[]
    userId?: StringFilter<"NutritionLog"> | string
    date?: DateTimeFilter<"NutritionLog"> | Date | string
    meal?: StringFilter<"NutritionLog"> | string
    calories?: IntFilter<"NutritionLog"> | number
    protein?: FloatNullableFilter<"NutritionLog"> | number | null
    carbs?: FloatNullableFilter<"NutritionLog"> | number | null
    fats?: FloatNullableFilter<"NutritionLog"> | number | null
    mealType?: StringNullableFilter<"NutritionLog"> | string | null
    notes?: StringNullableFilter<"NutritionLog"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NutritionLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    meal?: SortOrder
    calories?: SortOrder
    protein?: SortOrderInput | SortOrder
    carbs?: SortOrderInput | SortOrder
    fats?: SortOrderInput | SortOrder
    mealType?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: NutritionLogCountOrderByAggregateInput
    _avg?: NutritionLogAvgOrderByAggregateInput
    _max?: NutritionLogMaxOrderByAggregateInput
    _min?: NutritionLogMinOrderByAggregateInput
    _sum?: NutritionLogSumOrderByAggregateInput
  }

  export type NutritionLogScalarWhereWithAggregatesInput = {
    AND?: NutritionLogScalarWhereWithAggregatesInput | NutritionLogScalarWhereWithAggregatesInput[]
    OR?: NutritionLogScalarWhereWithAggregatesInput[]
    NOT?: NutritionLogScalarWhereWithAggregatesInput | NutritionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NutritionLog"> | string
    userId?: StringWithAggregatesFilter<"NutritionLog"> | string
    date?: DateTimeWithAggregatesFilter<"NutritionLog"> | Date | string
    meal?: StringWithAggregatesFilter<"NutritionLog"> | string
    calories?: IntWithAggregatesFilter<"NutritionLog"> | number
    protein?: FloatNullableWithAggregatesFilter<"NutritionLog"> | number | null
    carbs?: FloatNullableWithAggregatesFilter<"NutritionLog"> | number | null
    fats?: FloatNullableWithAggregatesFilter<"NutritionLog"> | number | null
    mealType?: StringNullableWithAggregatesFilter<"NutritionLog"> | string | null
    notes?: StringNullableWithAggregatesFilter<"NutritionLog"> | string | null
  }

  export type SupplementLogWhereInput = {
    AND?: SupplementLogWhereInput | SupplementLogWhereInput[]
    OR?: SupplementLogWhereInput[]
    NOT?: SupplementLogWhereInput | SupplementLogWhereInput[]
    id?: StringFilter<"SupplementLog"> | string
    userId?: StringFilter<"SupplementLog"> | string
    date?: DateTimeFilter<"SupplementLog"> | Date | string
    supplementName?: StringFilter<"SupplementLog"> | string
    dose?: StringFilter<"SupplementLog"> | string
    notes?: StringNullableFilter<"SupplementLog"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SupplementLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    supplementName?: SortOrder
    dose?: SortOrder
    notes?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SupplementLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplementLogWhereInput | SupplementLogWhereInput[]
    OR?: SupplementLogWhereInput[]
    NOT?: SupplementLogWhereInput | SupplementLogWhereInput[]
    userId?: StringFilter<"SupplementLog"> | string
    date?: DateTimeFilter<"SupplementLog"> | Date | string
    supplementName?: StringFilter<"SupplementLog"> | string
    dose?: StringFilter<"SupplementLog"> | string
    notes?: StringNullableFilter<"SupplementLog"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SupplementLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    supplementName?: SortOrder
    dose?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: SupplementLogCountOrderByAggregateInput
    _max?: SupplementLogMaxOrderByAggregateInput
    _min?: SupplementLogMinOrderByAggregateInput
  }

  export type SupplementLogScalarWhereWithAggregatesInput = {
    AND?: SupplementLogScalarWhereWithAggregatesInput | SupplementLogScalarWhereWithAggregatesInput[]
    OR?: SupplementLogScalarWhereWithAggregatesInput[]
    NOT?: SupplementLogScalarWhereWithAggregatesInput | SupplementLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupplementLog"> | string
    userId?: StringWithAggregatesFilter<"SupplementLog"> | string
    date?: DateTimeWithAggregatesFilter<"SupplementLog"> | Date | string
    supplementName?: StringWithAggregatesFilter<"SupplementLog"> | string
    dose?: StringWithAggregatesFilter<"SupplementLog"> | string
    notes?: StringNullableWithAggregatesFilter<"SupplementLog"> | string | null
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    planCode?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    status?: SortOrder
    planCode?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    userId?: StringFilter<"Subscription"> | string
    status?: StringFilter<"Subscription"> | string
    planCode?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    status?: SortOrder
    planCode?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    status?: StringWithAggregatesFilter<"Subscription"> | string
    planCode?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type RecommendationWhereInput = {
    AND?: RecommendationWhereInput | RecommendationWhereInput[]
    OR?: RecommendationWhereInput[]
    NOT?: RecommendationWhereInput | RecommendationWhereInput[]
    id?: StringFilter<"Recommendation"> | string
    userId?: StringFilter<"Recommendation"> | string
    coachId?: StringNullableFilter<"Recommendation"> | string | null
    type?: StringFilter<"Recommendation"> | string
    content?: StringFilter<"Recommendation"> | string
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    coach?: XOR<CoachNullableRelationFilter, CoachWhereInput> | null
  }

  export type RecommendationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrderInput | SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    coach?: CoachOrderByWithRelationInput
  }

  export type RecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecommendationWhereInput | RecommendationWhereInput[]
    OR?: RecommendationWhereInput[]
    NOT?: RecommendationWhereInput | RecommendationWhereInput[]
    userId?: StringFilter<"Recommendation"> | string
    coachId?: StringNullableFilter<"Recommendation"> | string | null
    type?: StringFilter<"Recommendation"> | string
    content?: StringFilter<"Recommendation"> | string
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    coach?: XOR<CoachNullableRelationFilter, CoachWhereInput> | null
  }, "id">

  export type RecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrderInput | SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: RecommendationCountOrderByAggregateInput
    _max?: RecommendationMaxOrderByAggregateInput
    _min?: RecommendationMinOrderByAggregateInput
  }

  export type RecommendationScalarWhereWithAggregatesInput = {
    AND?: RecommendationScalarWhereWithAggregatesInput | RecommendationScalarWhereWithAggregatesInput[]
    OR?: RecommendationScalarWhereWithAggregatesInput[]
    NOT?: RecommendationScalarWhereWithAggregatesInput | RecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recommendation"> | string
    userId?: StringWithAggregatesFilter<"Recommendation"> | string
    coachId?: StringNullableWithAggregatesFilter<"Recommendation"> | string | null
    type?: StringWithAggregatesFilter<"Recommendation"> | string
    content?: StringWithAggregatesFilter<"Recommendation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Recommendation"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    products?: ProductListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
  }

  export type BundleWhereInput = {
    AND?: BundleWhereInput | BundleWhereInput[]
    OR?: BundleWhereInput[]
    NOT?: BundleWhereInput | BundleWhereInput[]
    id?: StringFilter<"Bundle"> | string
    name?: StringFilter<"Bundle"> | string
    price?: FloatFilter<"Bundle"> | number
    products?: ProductListRelationFilter
  }

  export type BundleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type BundleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BundleWhereInput | BundleWhereInput[]
    OR?: BundleWhereInput[]
    NOT?: BundleWhereInput | BundleWhereInput[]
    name?: StringFilter<"Bundle"> | string
    price?: FloatFilter<"Bundle"> | number
    products?: ProductListRelationFilter
  }, "id">

  export type BundleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    _count?: BundleCountOrderByAggregateInput
    _avg?: BundleAvgOrderByAggregateInput
    _max?: BundleMaxOrderByAggregateInput
    _min?: BundleMinOrderByAggregateInput
    _sum?: BundleSumOrderByAggregateInput
  }

  export type BundleScalarWhereWithAggregatesInput = {
    AND?: BundleScalarWhereWithAggregatesInput | BundleScalarWhereWithAggregatesInput[]
    OR?: BundleScalarWhereWithAggregatesInput[]
    NOT?: BundleScalarWhereWithAggregatesInput | BundleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bundle"> | string
    name?: StringWithAggregatesFilter<"Bundle"> | string
    price?: FloatWithAggregatesFilter<"Bundle"> | number
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatNullableFilter<"Product"> | number | null
    priceCents?: IntFilter<"Product"> | number
    currency?: StringFilter<"Product"> | string
    inventory?: IntFilter<"Product"> | number
    categoryId?: StringFilter<"Product"> | string
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    bundles?: BundleListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    inventory?: SortOrder
    categoryId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    bundles?: BundleOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatNullableFilter<"Product"> | number | null
    priceCents?: IntFilter<"Product"> | number
    currency?: StringFilter<"Product"> | string
    inventory?: IntFilter<"Product"> | number
    categoryId?: StringFilter<"Product"> | string
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    bundles?: BundleListRelationFilter
  }, "id" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    inventory?: SortOrder
    categoryId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    sku?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    priceCents?: IntWithAggregatesFilter<"Product"> | number
    currency?: StringWithAggregatesFilter<"Product"> | string
    inventory?: IntWithAggregatesFilter<"Product"> | number
    categoryId?: StringWithAggregatesFilter<"Product"> | string
  }

  export type DeliveryWhereInput = {
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    id?: StringFilter<"Delivery"> | string
    orderId?: StringFilter<"Delivery"> | string
    status?: StringFilter<"Delivery"> | string
    trackingUrl?: StringNullableFilter<"Delivery"> | string | null
    address?: StringFilter<"Delivery"> | string
    courier?: StringNullableFilter<"Delivery"> | string | null
    estimatedDate?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }

  export type DeliveryOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    trackingUrl?: SortOrderInput | SortOrder
    address?: SortOrder
    courier?: SortOrderInput | SortOrder
    estimatedDate?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type DeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    status?: StringFilter<"Delivery"> | string
    trackingUrl?: StringNullableFilter<"Delivery"> | string | null
    address?: StringFilter<"Delivery"> | string
    courier?: StringNullableFilter<"Delivery"> | string | null
    estimatedDate?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }, "id" | "orderId">

  export type DeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    trackingUrl?: SortOrderInput | SortOrder
    address?: SortOrder
    courier?: SortOrderInput | SortOrder
    estimatedDate?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: DeliveryCountOrderByAggregateInput
    _max?: DeliveryMaxOrderByAggregateInput
    _min?: DeliveryMinOrderByAggregateInput
  }

  export type DeliveryScalarWhereWithAggregatesInput = {
    AND?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    OR?: DeliveryScalarWhereWithAggregatesInput[]
    NOT?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Delivery"> | string
    orderId?: StringWithAggregatesFilter<"Delivery"> | string
    status?: StringWithAggregatesFilter<"Delivery"> | string
    trackingUrl?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    address?: StringWithAggregatesFilter<"Delivery"> | string
    courier?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    estimatedDate?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
  }

  export type AffiliateWhereInput = {
    AND?: AffiliateWhereInput | AffiliateWhereInput[]
    OR?: AffiliateWhereInput[]
    NOT?: AffiliateWhereInput | AffiliateWhereInput[]
    id?: StringFilter<"Affiliate"> | string
    name?: StringFilter<"Affiliate"> | string
    referralCode?: StringFilter<"Affiliate"> | string
    brandUrl?: StringNullableFilter<"Affiliate"> | string | null
    commissions?: CommissionListRelationFilter
  }

  export type AffiliateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    referralCode?: SortOrder
    brandUrl?: SortOrderInput | SortOrder
    commissions?: CommissionOrderByRelationAggregateInput
  }

  export type AffiliateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AffiliateWhereInput | AffiliateWhereInput[]
    OR?: AffiliateWhereInput[]
    NOT?: AffiliateWhereInput | AffiliateWhereInput[]
    name?: StringFilter<"Affiliate"> | string
    referralCode?: StringFilter<"Affiliate"> | string
    brandUrl?: StringNullableFilter<"Affiliate"> | string | null
    commissions?: CommissionListRelationFilter
  }, "id">

  export type AffiliateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    referralCode?: SortOrder
    brandUrl?: SortOrderInput | SortOrder
    _count?: AffiliateCountOrderByAggregateInput
    _max?: AffiliateMaxOrderByAggregateInput
    _min?: AffiliateMinOrderByAggregateInput
  }

  export type AffiliateScalarWhereWithAggregatesInput = {
    AND?: AffiliateScalarWhereWithAggregatesInput | AffiliateScalarWhereWithAggregatesInput[]
    OR?: AffiliateScalarWhereWithAggregatesInput[]
    NOT?: AffiliateScalarWhereWithAggregatesInput | AffiliateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Affiliate"> | string
    name?: StringWithAggregatesFilter<"Affiliate"> | string
    referralCode?: StringWithAggregatesFilter<"Affiliate"> | string
    brandUrl?: StringNullableWithAggregatesFilter<"Affiliate"> | string | null
  }

  export type CoachMessageWhereInput = {
    AND?: CoachMessageWhereInput | CoachMessageWhereInput[]
    OR?: CoachMessageWhereInput[]
    NOT?: CoachMessageWhereInput | CoachMessageWhereInput[]
    id?: StringFilter<"CoachMessage"> | string
    coachId?: StringFilter<"CoachMessage"> | string
    userId?: StringFilter<"CoachMessage"> | string
    sender?: StringFilter<"CoachMessage"> | string
    body?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentUrl?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentName?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentType?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentSize?: IntNullableFilter<"CoachMessage"> | number | null
    createdAt?: DateTimeFilter<"CoachMessage"> | Date | string
    coach?: XOR<CoachRelationFilter, CoachWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CoachMessageOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    userId?: SortOrder
    sender?: SortOrder
    body?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    attachmentName?: SortOrderInput | SortOrder
    attachmentType?: SortOrderInput | SortOrder
    attachmentSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    coach?: CoachOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CoachMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CoachMessageWhereInput | CoachMessageWhereInput[]
    OR?: CoachMessageWhereInput[]
    NOT?: CoachMessageWhereInput | CoachMessageWhereInput[]
    coachId?: StringFilter<"CoachMessage"> | string
    userId?: StringFilter<"CoachMessage"> | string
    sender?: StringFilter<"CoachMessage"> | string
    body?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentUrl?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentName?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentType?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentSize?: IntNullableFilter<"CoachMessage"> | number | null
    createdAt?: DateTimeFilter<"CoachMessage"> | Date | string
    coach?: XOR<CoachRelationFilter, CoachWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CoachMessageOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    userId?: SortOrder
    sender?: SortOrder
    body?: SortOrderInput | SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    attachmentName?: SortOrderInput | SortOrder
    attachmentType?: SortOrderInput | SortOrder
    attachmentSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CoachMessageCountOrderByAggregateInput
    _avg?: CoachMessageAvgOrderByAggregateInput
    _max?: CoachMessageMaxOrderByAggregateInput
    _min?: CoachMessageMinOrderByAggregateInput
    _sum?: CoachMessageSumOrderByAggregateInput
  }

  export type CoachMessageScalarWhereWithAggregatesInput = {
    AND?: CoachMessageScalarWhereWithAggregatesInput | CoachMessageScalarWhereWithAggregatesInput[]
    OR?: CoachMessageScalarWhereWithAggregatesInput[]
    NOT?: CoachMessageScalarWhereWithAggregatesInput | CoachMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoachMessage"> | string
    coachId?: StringWithAggregatesFilter<"CoachMessage"> | string
    userId?: StringWithAggregatesFilter<"CoachMessage"> | string
    sender?: StringWithAggregatesFilter<"CoachMessage"> | string
    body?: StringNullableWithAggregatesFilter<"CoachMessage"> | string | null
    attachmentUrl?: StringNullableWithAggregatesFilter<"CoachMessage"> | string | null
    attachmentName?: StringNullableWithAggregatesFilter<"CoachMessage"> | string | null
    attachmentType?: StringNullableWithAggregatesFilter<"CoachMessage"> | string | null
    attachmentSize?: IntNullableWithAggregatesFilter<"CoachMessage"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CoachMessage"> | Date | string
  }

  export type CommissionWhereInput = {
    AND?: CommissionWhereInput | CommissionWhereInput[]
    OR?: CommissionWhereInput[]
    NOT?: CommissionWhereInput | CommissionWhereInput[]
    id?: StringFilter<"Commission"> | string
    coachId?: StringFilter<"Commission"> | string
    orderId?: StringFilter<"Commission"> | string
    affiliateId?: StringNullableFilter<"Commission"> | string | null
    amount?: FloatFilter<"Commission"> | number
    createdAt?: DateTimeFilter<"Commission"> | Date | string
    userId?: StringNullableFilter<"Commission"> | string | null
    coach?: XOR<CoachRelationFilter, CoachWhereInput>
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    affiliate?: XOR<AffiliateNullableRelationFilter, AffiliateWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CommissionOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    orderId?: SortOrder
    affiliateId?: SortOrderInput | SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    coach?: CoachOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    affiliate?: AffiliateOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type CommissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommissionWhereInput | CommissionWhereInput[]
    OR?: CommissionWhereInput[]
    NOT?: CommissionWhereInput | CommissionWhereInput[]
    coachId?: StringFilter<"Commission"> | string
    orderId?: StringFilter<"Commission"> | string
    affiliateId?: StringNullableFilter<"Commission"> | string | null
    amount?: FloatFilter<"Commission"> | number
    createdAt?: DateTimeFilter<"Commission"> | Date | string
    userId?: StringNullableFilter<"Commission"> | string | null
    coach?: XOR<CoachRelationFilter, CoachWhereInput>
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    affiliate?: XOR<AffiliateNullableRelationFilter, AffiliateWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type CommissionOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    orderId?: SortOrder
    affiliateId?: SortOrderInput | SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: CommissionCountOrderByAggregateInput
    _avg?: CommissionAvgOrderByAggregateInput
    _max?: CommissionMaxOrderByAggregateInput
    _min?: CommissionMinOrderByAggregateInput
    _sum?: CommissionSumOrderByAggregateInput
  }

  export type CommissionScalarWhereWithAggregatesInput = {
    AND?: CommissionScalarWhereWithAggregatesInput | CommissionScalarWhereWithAggregatesInput[]
    OR?: CommissionScalarWhereWithAggregatesInput[]
    NOT?: CommissionScalarWhereWithAggregatesInput | CommissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Commission"> | string
    coachId?: StringWithAggregatesFilter<"Commission"> | string
    orderId?: StringWithAggregatesFilter<"Commission"> | string
    affiliateId?: StringNullableWithAggregatesFilter<"Commission"> | string | null
    amount?: FloatWithAggregatesFilter<"Commission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Commission"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Commission"> | string | null
  }

  export type AnalyticsWhereInput = {
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    id?: StringFilter<"Analytics"> | string
    date?: DateTimeFilter<"Analytics"> | Date | string
    revenue?: FloatFilter<"Analytics"> | number
    engagement?: IntFilter<"Analytics"> | number
    supplementSales?: IntFilter<"Analytics"> | number
  }

  export type AnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    engagement?: SortOrder
    supplementSales?: SortOrder
  }

  export type AnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    date?: DateTimeFilter<"Analytics"> | Date | string
    revenue?: FloatFilter<"Analytics"> | number
    engagement?: IntFilter<"Analytics"> | number
    supplementSales?: IntFilter<"Analytics"> | number
  }, "id">

  export type AnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    engagement?: SortOrder
    supplementSales?: SortOrder
    _count?: AnalyticsCountOrderByAggregateInput
    _avg?: AnalyticsAvgOrderByAggregateInput
    _max?: AnalyticsMaxOrderByAggregateInput
    _min?: AnalyticsMinOrderByAggregateInput
    _sum?: AnalyticsSumOrderByAggregateInput
  }

  export type AnalyticsScalarWhereWithAggregatesInput = {
    AND?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    OR?: AnalyticsScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Analytics"> | string
    date?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
    revenue?: FloatWithAggregatesFilter<"Analytics"> | number
    engagement?: IntWithAggregatesFilter<"Analytics"> | number
    supplementSales?: IntWithAggregatesFilter<"Analytics"> | number
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    userId?: StringFilter<"Milestone"> | string
    type?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    achievedAt?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    achievedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    userId?: StringFilter<"Milestone"> | string
    type?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    achievedAt?: DateTimeNullableFilter<"Milestone"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    achievedAt?: SortOrderInput | SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    userId?: StringWithAggregatesFilter<"Milestone"> | string
    type?: StringWithAggregatesFilter<"Milestone"> | string
    description?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    achievedAt?: DateTimeNullableWithAggregatesFilter<"Milestone"> | Date | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    orderId?: StringNullableFilter<"Payment"> | string | null
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatNullableFilter<"Payment"> | number | null
    amountCents?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    providerId?: StringNullableFilter<"Payment"> | string | null
    raw?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    providerId?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    orderId?: StringNullableFilter<"Payment"> | string | null
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatNullableFilter<"Payment"> | number | null
    amountCents?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    raw?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
  }, "id" | "providerId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    providerId?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    orderId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    subscriptionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    amountCents?: IntWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    provider?: StringWithAggregatesFilter<"Payment"> | string
    providerId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    raw?: JsonNullableWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type WebhookEventWhereInput = {
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    id?: StringFilter<"WebhookEvent"> | string
    provider?: StringFilter<"WebhookEvent"> | string
    eventId?: StringFilter<"WebhookEvent"> | string
    payload?: JsonFilter<"WebhookEvent">
    processed?: BoolFilter<"WebhookEvent"> | boolean
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
  }

  export type WebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    eventId?: SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId?: string
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    provider?: StringFilter<"WebhookEvent"> | string
    payload?: JsonFilter<"WebhookEvent">
    processed?: BoolFilter<"WebhookEvent"> | boolean
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
  }, "id" | "eventId">

  export type WebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    eventId?: SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
    _count?: WebhookEventCountOrderByAggregateInput
    _max?: WebhookEventMaxOrderByAggregateInput
    _min?: WebhookEventMinOrderByAggregateInput
  }

  export type WebhookEventScalarWhereWithAggregatesInput = {
    AND?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    OR?: WebhookEventScalarWhereWithAggregatesInput[]
    NOT?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookEvent"> | string
    provider?: StringWithAggregatesFilter<"WebhookEvent"> | string
    eventId?: StringWithAggregatesFilter<"WebhookEvent"> | string
    payload?: JsonWithAggregatesFilter<"WebhookEvent">
    processed?: BoolWithAggregatesFilter<"WebhookEvent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WebhookEvent"> | Date | string
  }

  export type CoachRequestWhereInput = {
    AND?: CoachRequestWhereInput | CoachRequestWhereInput[]
    OR?: CoachRequestWhereInput[]
    NOT?: CoachRequestWhereInput | CoachRequestWhereInput[]
    id?: StringFilter<"CoachRequest"> | string
    userId?: StringFilter<"CoachRequest"> | string
    status?: StringFilter<"CoachRequest"> | string
    createdAt?: DateTimeFilter<"CoachRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CoachRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CoachRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CoachRequestWhereInput | CoachRequestWhereInput[]
    OR?: CoachRequestWhereInput[]
    NOT?: CoachRequestWhereInput | CoachRequestWhereInput[]
    userId?: StringFilter<"CoachRequest"> | string
    status?: StringFilter<"CoachRequest"> | string
    createdAt?: DateTimeFilter<"CoachRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CoachRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: CoachRequestCountOrderByAggregateInput
    _max?: CoachRequestMaxOrderByAggregateInput
    _min?: CoachRequestMinOrderByAggregateInput
  }

  export type CoachRequestScalarWhereWithAggregatesInput = {
    AND?: CoachRequestScalarWhereWithAggregatesInput | CoachRequestScalarWhereWithAggregatesInput[]
    OR?: CoachRequestScalarWhereWithAggregatesInput[]
    NOT?: CoachRequestScalarWhereWithAggregatesInput | CoachRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoachRequest"> | string
    userId?: StringWithAggregatesFilter<"CoachRequest"> | string
    status?: StringWithAggregatesFilter<"CoachRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CoachRequest"> | Date | string
  }

  export type UserIntakeWhereInput = {
    AND?: UserIntakeWhereInput | UserIntakeWhereInput[]
    OR?: UserIntakeWhereInput[]
    NOT?: UserIntakeWhereInput | UserIntakeWhereInput[]
    id?: StringFilter<"UserIntake"> | string
    userId?: StringFilter<"UserIntake"> | string
    gender?: StringNullableFilter<"UserIntake"> | string | null
    mainGoal?: StringNullableFilter<"UserIntake"> | string | null
    workoutLocation?: StringNullableFilter<"UserIntake"> | string | null
    firstCompletedAt?: DateTimeNullableFilter<"UserIntake"> | Date | string | null
    age?: IntNullableFilter<"UserIntake"> | number | null
    weightKg?: FloatNullableFilter<"UserIntake"> | number | null
    heightCm?: FloatNullableFilter<"UserIntake"> | number | null
    experienceLevel?: StringNullableFilter<"UserIntake"> | string | null
    workoutFrequency?: IntNullableFilter<"UserIntake"> | number | null
    injuries?: StringNullableListFilter<"UserIntake">
    secondCompletedAt?: DateTimeNullableFilter<"UserIntake"> | Date | string | null
    skippedSecond?: BoolFilter<"UserIntake"> | boolean
    createdAt?: DateTimeFilter<"UserIntake"> | Date | string
    updatedAt?: DateTimeFilter<"UserIntake"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserIntakeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrderInput | SortOrder
    mainGoal?: SortOrderInput | SortOrder
    workoutLocation?: SortOrderInput | SortOrder
    firstCompletedAt?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    experienceLevel?: SortOrderInput | SortOrder
    workoutFrequency?: SortOrderInput | SortOrder
    injuries?: SortOrder
    secondCompletedAt?: SortOrderInput | SortOrder
    skippedSecond?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserIntakeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserIntakeWhereInput | UserIntakeWhereInput[]
    OR?: UserIntakeWhereInput[]
    NOT?: UserIntakeWhereInput | UserIntakeWhereInput[]
    gender?: StringNullableFilter<"UserIntake"> | string | null
    mainGoal?: StringNullableFilter<"UserIntake"> | string | null
    workoutLocation?: StringNullableFilter<"UserIntake"> | string | null
    firstCompletedAt?: DateTimeNullableFilter<"UserIntake"> | Date | string | null
    age?: IntNullableFilter<"UserIntake"> | number | null
    weightKg?: FloatNullableFilter<"UserIntake"> | number | null
    heightCm?: FloatNullableFilter<"UserIntake"> | number | null
    experienceLevel?: StringNullableFilter<"UserIntake"> | string | null
    workoutFrequency?: IntNullableFilter<"UserIntake"> | number | null
    injuries?: StringNullableListFilter<"UserIntake">
    secondCompletedAt?: DateTimeNullableFilter<"UserIntake"> | Date | string | null
    skippedSecond?: BoolFilter<"UserIntake"> | boolean
    createdAt?: DateTimeFilter<"UserIntake"> | Date | string
    updatedAt?: DateTimeFilter<"UserIntake"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserIntakeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrderInput | SortOrder
    mainGoal?: SortOrderInput | SortOrder
    workoutLocation?: SortOrderInput | SortOrder
    firstCompletedAt?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    experienceLevel?: SortOrderInput | SortOrder
    workoutFrequency?: SortOrderInput | SortOrder
    injuries?: SortOrder
    secondCompletedAt?: SortOrderInput | SortOrder
    skippedSecond?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserIntakeCountOrderByAggregateInput
    _avg?: UserIntakeAvgOrderByAggregateInput
    _max?: UserIntakeMaxOrderByAggregateInput
    _min?: UserIntakeMinOrderByAggregateInput
    _sum?: UserIntakeSumOrderByAggregateInput
  }

  export type UserIntakeScalarWhereWithAggregatesInput = {
    AND?: UserIntakeScalarWhereWithAggregatesInput | UserIntakeScalarWhereWithAggregatesInput[]
    OR?: UserIntakeScalarWhereWithAggregatesInput[]
    NOT?: UserIntakeScalarWhereWithAggregatesInput | UserIntakeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserIntake"> | string
    userId?: StringWithAggregatesFilter<"UserIntake"> | string
    gender?: StringNullableWithAggregatesFilter<"UserIntake"> | string | null
    mainGoal?: StringNullableWithAggregatesFilter<"UserIntake"> | string | null
    workoutLocation?: StringNullableWithAggregatesFilter<"UserIntake"> | string | null
    firstCompletedAt?: DateTimeNullableWithAggregatesFilter<"UserIntake"> | Date | string | null
    age?: IntNullableWithAggregatesFilter<"UserIntake"> | number | null
    weightKg?: FloatNullableWithAggregatesFilter<"UserIntake"> | number | null
    heightCm?: FloatNullableWithAggregatesFilter<"UserIntake"> | number | null
    experienceLevel?: StringNullableWithAggregatesFilter<"UserIntake"> | string | null
    workoutFrequency?: IntNullableWithAggregatesFilter<"UserIntake"> | number | null
    injuries?: StringNullableListFilter<"UserIntake">
    secondCompletedAt?: DateTimeNullableWithAggregatesFilter<"UserIntake"> | Date | string | null
    skippedSecond?: BoolWithAggregatesFilter<"UserIntake"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserIntake"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserIntake"> | Date | string
  }

  export type SubscriptionQuotaWhereInput = {
    AND?: SubscriptionQuotaWhereInput | SubscriptionQuotaWhereInput[]
    OR?: SubscriptionQuotaWhereInput[]
    NOT?: SubscriptionQuotaWhereInput | SubscriptionQuotaWhereInput[]
    id?: StringFilter<"SubscriptionQuota"> | string
    userId?: StringFilter<"SubscriptionQuota"> | string
    tier?: EnumSubscriptionTierFilter<"SubscriptionQuota"> | $Enums.SubscriptionTier
    messagesUsed?: IntFilter<"SubscriptionQuota"> | number
    callsUsed?: IntFilter<"SubscriptionQuota"> | number
    attachmentsUsed?: IntFilter<"SubscriptionQuota"> | number
    resetAt?: DateTimeFilter<"SubscriptionQuota"> | Date | string
    nutritionWindowDays?: IntNullableFilter<"SubscriptionQuota"> | number | null
    nutritionExpiresAt?: DateTimeNullableFilter<"SubscriptionQuota"> | Date | string | null
    nutritionLocked?: BoolFilter<"SubscriptionQuota"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionQuota"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionQuota"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SubscriptionQuotaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    messagesUsed?: SortOrder
    callsUsed?: SortOrder
    attachmentsUsed?: SortOrder
    resetAt?: SortOrder
    nutritionWindowDays?: SortOrderInput | SortOrder
    nutritionExpiresAt?: SortOrderInput | SortOrder
    nutritionLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubscriptionQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SubscriptionQuotaWhereInput | SubscriptionQuotaWhereInput[]
    OR?: SubscriptionQuotaWhereInput[]
    NOT?: SubscriptionQuotaWhereInput | SubscriptionQuotaWhereInput[]
    tier?: EnumSubscriptionTierFilter<"SubscriptionQuota"> | $Enums.SubscriptionTier
    messagesUsed?: IntFilter<"SubscriptionQuota"> | number
    callsUsed?: IntFilter<"SubscriptionQuota"> | number
    attachmentsUsed?: IntFilter<"SubscriptionQuota"> | number
    resetAt?: DateTimeFilter<"SubscriptionQuota"> | Date | string
    nutritionWindowDays?: IntNullableFilter<"SubscriptionQuota"> | number | null
    nutritionExpiresAt?: DateTimeNullableFilter<"SubscriptionQuota"> | Date | string | null
    nutritionLocked?: BoolFilter<"SubscriptionQuota"> | boolean
    createdAt?: DateTimeFilter<"SubscriptionQuota"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionQuota"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type SubscriptionQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    messagesUsed?: SortOrder
    callsUsed?: SortOrder
    attachmentsUsed?: SortOrder
    resetAt?: SortOrder
    nutritionWindowDays?: SortOrderInput | SortOrder
    nutritionExpiresAt?: SortOrderInput | SortOrder
    nutritionLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionQuotaCountOrderByAggregateInput
    _avg?: SubscriptionQuotaAvgOrderByAggregateInput
    _max?: SubscriptionQuotaMaxOrderByAggregateInput
    _min?: SubscriptionQuotaMinOrderByAggregateInput
    _sum?: SubscriptionQuotaSumOrderByAggregateInput
  }

  export type SubscriptionQuotaScalarWhereWithAggregatesInput = {
    AND?: SubscriptionQuotaScalarWhereWithAggregatesInput | SubscriptionQuotaScalarWhereWithAggregatesInput[]
    OR?: SubscriptionQuotaScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionQuotaScalarWhereWithAggregatesInput | SubscriptionQuotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubscriptionQuota"> | string
    userId?: StringWithAggregatesFilter<"SubscriptionQuota"> | string
    tier?: EnumSubscriptionTierWithAggregatesFilter<"SubscriptionQuota"> | $Enums.SubscriptionTier
    messagesUsed?: IntWithAggregatesFilter<"SubscriptionQuota"> | number
    callsUsed?: IntWithAggregatesFilter<"SubscriptionQuota"> | number
    attachmentsUsed?: IntWithAggregatesFilter<"SubscriptionQuota"> | number
    resetAt?: DateTimeWithAggregatesFilter<"SubscriptionQuota"> | Date | string
    nutritionWindowDays?: IntNullableWithAggregatesFilter<"SubscriptionQuota"> | number | null
    nutritionExpiresAt?: DateTimeNullableWithAggregatesFilter<"SubscriptionQuota"> | Date | string | null
    nutritionLocked?: BoolWithAggregatesFilter<"SubscriptionQuota"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionQuota"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionQuota"> | Date | string
  }

  export type NutritionPreferenceWhereInput = {
    AND?: NutritionPreferenceWhereInput | NutritionPreferenceWhereInput[]
    OR?: NutritionPreferenceWhereInput[]
    NOT?: NutritionPreferenceWhereInput | NutritionPreferenceWhereInput[]
    id?: StringFilter<"NutritionPreference"> | string
    userId?: StringFilter<"NutritionPreference"> | string
    proteinSources?: StringNullableListFilter<"NutritionPreference">
    proteinAllergies?: StringNullableListFilter<"NutritionPreference">
    dinnerPreferences?: JsonNullableFilter<"NutritionPreference">
    additionalNotes?: StringNullableFilter<"NutritionPreference"> | string | null
    completedAt?: DateTimeNullableFilter<"NutritionPreference"> | Date | string | null
    createdAt?: DateTimeFilter<"NutritionPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NutritionPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NutritionPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    proteinSources?: SortOrder
    proteinAllergies?: SortOrder
    dinnerPreferences?: SortOrderInput | SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NutritionPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NutritionPreferenceWhereInput | NutritionPreferenceWhereInput[]
    OR?: NutritionPreferenceWhereInput[]
    NOT?: NutritionPreferenceWhereInput | NutritionPreferenceWhereInput[]
    proteinSources?: StringNullableListFilter<"NutritionPreference">
    proteinAllergies?: StringNullableListFilter<"NutritionPreference">
    dinnerPreferences?: JsonNullableFilter<"NutritionPreference">
    additionalNotes?: StringNullableFilter<"NutritionPreference"> | string | null
    completedAt?: DateTimeNullableFilter<"NutritionPreference"> | Date | string | null
    createdAt?: DateTimeFilter<"NutritionPreference"> | Date | string
    updatedAt?: DateTimeFilter<"NutritionPreference"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NutritionPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    proteinSources?: SortOrder
    proteinAllergies?: SortOrder
    dinnerPreferences?: SortOrderInput | SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NutritionPreferenceCountOrderByAggregateInput
    _max?: NutritionPreferenceMaxOrderByAggregateInput
    _min?: NutritionPreferenceMinOrderByAggregateInput
  }

  export type NutritionPreferenceScalarWhereWithAggregatesInput = {
    AND?: NutritionPreferenceScalarWhereWithAggregatesInput | NutritionPreferenceScalarWhereWithAggregatesInput[]
    OR?: NutritionPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NutritionPreferenceScalarWhereWithAggregatesInput | NutritionPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NutritionPreference"> | string
    userId?: StringWithAggregatesFilter<"NutritionPreference"> | string
    proteinSources?: StringNullableListFilter<"NutritionPreference">
    proteinAllergies?: StringNullableListFilter<"NutritionPreference">
    dinnerPreferences?: JsonNullableWithAggregatesFilter<"NutritionPreference">
    additionalNotes?: StringNullableWithAggregatesFilter<"NutritionPreference"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"NutritionPreference"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NutritionPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NutritionPreference"> | Date | string
  }

  export type NutritionAccessWhereInput = {
    AND?: NutritionAccessWhereInput | NutritionAccessWhereInput[]
    OR?: NutritionAccessWhereInput[]
    NOT?: NutritionAccessWhereInput | NutritionAccessWhereInput[]
    id?: StringFilter<"NutritionAccess"> | string
    userId?: StringFilter<"NutritionAccess"> | string
    planGeneratedAt?: DateTimeFilter<"NutritionAccess"> | Date | string
    expiresAt?: DateTimeNullableFilter<"NutritionAccess"> | Date | string | null
    locked?: BoolFilter<"NutritionAccess"> | boolean
    windowDays?: IntNullableFilter<"NutritionAccess"> | number | null
    createdAt?: DateTimeFilter<"NutritionAccess"> | Date | string
    updatedAt?: DateTimeFilter<"NutritionAccess"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NutritionAccessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planGeneratedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    locked?: SortOrder
    windowDays?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NutritionAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NutritionAccessWhereInput | NutritionAccessWhereInput[]
    OR?: NutritionAccessWhereInput[]
    NOT?: NutritionAccessWhereInput | NutritionAccessWhereInput[]
    planGeneratedAt?: DateTimeFilter<"NutritionAccess"> | Date | string
    expiresAt?: DateTimeNullableFilter<"NutritionAccess"> | Date | string | null
    locked?: BoolFilter<"NutritionAccess"> | boolean
    windowDays?: IntNullableFilter<"NutritionAccess"> | number | null
    createdAt?: DateTimeFilter<"NutritionAccess"> | Date | string
    updatedAt?: DateTimeFilter<"NutritionAccess"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NutritionAccessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planGeneratedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    locked?: SortOrder
    windowDays?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NutritionAccessCountOrderByAggregateInput
    _avg?: NutritionAccessAvgOrderByAggregateInput
    _max?: NutritionAccessMaxOrderByAggregateInput
    _min?: NutritionAccessMinOrderByAggregateInput
    _sum?: NutritionAccessSumOrderByAggregateInput
  }

  export type NutritionAccessScalarWhereWithAggregatesInput = {
    AND?: NutritionAccessScalarWhereWithAggregatesInput | NutritionAccessScalarWhereWithAggregatesInput[]
    OR?: NutritionAccessScalarWhereWithAggregatesInput[]
    NOT?: NutritionAccessScalarWhereWithAggregatesInput | NutritionAccessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NutritionAccess"> | string
    userId?: StringWithAggregatesFilter<"NutritionAccess"> | string
    planGeneratedAt?: DateTimeWithAggregatesFilter<"NutritionAccess"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"NutritionAccess"> | Date | string | null
    locked?: BoolWithAggregatesFilter<"NutritionAccess"> | boolean
    windowDays?: IntNullableWithAggregatesFilter<"NutritionAccess"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"NutritionAccess"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NutritionAccess"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    scheduledAt: Date | string
    durationMin?: number
    status?: string
    agoraChannel?: string | null
    rating?: number | null
    ratingNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionInput
    coach?: CoachCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    coachId?: string | null
    scheduledAt: Date | string
    durationMin?: number
    status?: string
    agoraChannel?: string | null
    rating?: number | null
    ratingNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMin?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    agoraChannel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    ratingNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionNestedInput
    coach?: CoachUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMin?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    agoraChannel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    ratingNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    coachId?: string | null
    scheduledAt: Date | string
    durationMin?: number
    status?: string
    agoraChannel?: string | null
    rating?: number | null
    ratingNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMin?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    agoraChannel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    ratingNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMin?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    agoraChannel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    ratingNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    commissions?: CommissionCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Delivery?: DeliveryCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    userId: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    commissions?: CommissionUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Delivery?: DeliveryUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    userId: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    sku: string
    qty: number
    priceCents: number
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    sku: string
    qty: number
    priceCents: number
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    priceCents?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    priceCents?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    sku: string
    qty: number
    priceCents: number
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    priceCents?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    priceCents?: IntFieldUpdateOperationsInput | number
  }

  export type CoachCreateInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    user: UserCreateNestedOneWithoutCoachInput
    clients?: UserCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationCreateNestedManyWithoutCoachInput
    sessions?: SessionCreateNestedManyWithoutCoachInput
    messages?: CoachMessageCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateInput = {
    id?: string
    userId: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    clients?: UserUncheckedCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutCoachInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCoachInput
    messages?: CoachMessageUncheckedCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateUncheckedCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceUncheckedCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCoachNestedInput
    clients?: UserUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUpdateManyWithoutCoachNestedInput
    sessions?: SessionUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    clients?: UserUncheckedUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutCoachNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUncheckedUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUncheckedUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUncheckedUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type CoachCreateManyInput = {
    id?: string
    userId: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
  }

  export type CoachUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CoachUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CoachCertificateCreateInput = {
    id?: string
    name: string
    issuingOrganization: string
    issuedAt: Date | string
    expiresAt?: Date | string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachCreateNestedOneWithoutCertificatesInput
  }

  export type CoachCertificateUncheckedCreateInput = {
    id?: string
    coachId: string
    name: string
    issuingOrganization: string
    issuedAt: Date | string
    expiresAt?: Date | string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachCertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuingOrganization?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CoachCertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuingOrganization?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachCertificateCreateManyInput = {
    id?: string
    coachId: string
    name: string
    issuingOrganization: string
    issuedAt: Date | string
    expiresAt?: Date | string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachCertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuingOrganization?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachCertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuingOrganization?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachExperienceCreateInput = {
    id?: string
    title: string
    organization: string
    startDate: Date | string
    endDate?: Date | string | null
    isCurrent?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachCreateNestedOneWithoutExperiencesInput
  }

  export type CoachExperienceUncheckedCreateInput = {
    id?: string
    coachId: string
    title: string
    organization: string
    startDate: Date | string
    endDate?: Date | string | null
    isCurrent?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachExperienceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type CoachExperienceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachExperienceCreateManyInput = {
    id?: string
    coachId: string
    title: string
    organization: string
    startDate: Date | string
    endDate?: Date | string | null
    isCurrent?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachExperienceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachExperienceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAchievementCreateInput = {
    id?: string
    title: string
    description?: string | null
    achievedAt: Date | string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachCreateNestedOneWithoutAchievementsInput
  }

  export type CoachAchievementUncheckedCreateInput = {
    id?: string
    coachId: string
    title: string
    description?: string | null
    achievedAt: Date | string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type CoachAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAchievementCreateManyInput = {
    id?: string
    coachId: string
    title: string
    description?: string | null
    achievedAt: Date | string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutLogCreateInput = {
    id?: string
    date: Date | string
    activity: string
    duration: number
    notes?: string | null
    user: UserCreateNestedOneWithoutWorkoutLogInput
  }

  export type WorkoutLogUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    activity: string
    duration: number
    notes?: string | null
  }

  export type WorkoutLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutWorkoutLogNestedInput
  }

  export type WorkoutLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutLogCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    activity: string
    duration: number
    notes?: string | null
  }

  export type WorkoutLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NutritionLogCreateInput = {
    id?: string
    date: Date | string
    meal: string
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    mealType?: string | null
    notes?: string | null
    user: UserCreateNestedOneWithoutNutritionLogInput
  }

  export type NutritionLogUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    meal: string
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    mealType?: string | null
    notes?: string | null
  }

  export type NutritionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutNutritionLogNestedInput
  }

  export type NutritionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NutritionLogCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    meal: string
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    mealType?: string | null
    notes?: string | null
  }

  export type NutritionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NutritionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplementLogCreateInput = {
    id?: string
    date: Date | string
    supplementName: string
    dose: string
    notes?: string | null
    user: UserCreateNestedOneWithoutSupplementLogInput
  }

  export type SupplementLogUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    supplementName: string
    dose: string
    notes?: string | null
  }

  export type SupplementLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplementName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSupplementLogNestedInput
  }

  export type SupplementLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplementName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplementLogCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    supplementName: string
    dose: string
    notes?: string | null
  }

  export type SupplementLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplementName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplementLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplementName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionCreateInput = {
    id?: string
    stripeSubscriptionId?: string | null
    status?: string
    planCode?: string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    stripeSubscriptionId?: string | null
    status?: string
    planCode?: string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    planCode?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    planCode?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    stripeSubscriptionId?: string | null
    status?: string
    planCode?: string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    planCode?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    planCode?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationCreateInput = {
    id?: string
    type: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRecommendationsInput
    coach?: CoachCreateNestedOneWithoutRecommendationsInput
  }

  export type RecommendationUncheckedCreateInput = {
    id?: string
    userId: string
    coachId?: string | null
    type: string
    content: string
    createdAt?: Date | string
  }

  export type RecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecommendationsNestedInput
    coach?: CoachUpdateOneWithoutRecommendationsNestedInput
  }

  export type RecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationCreateManyInput = {
    id?: string
    userId: string
    coachId?: string | null
    type: string
    content: string
    createdAt?: Date | string
  }

  export type RecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BundleCreateInput = {
    id?: string
    name: string
    price: number
    products?: ProductCreateNestedManyWithoutBundlesInput
  }

  export type BundleUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    products?: ProductUncheckedCreateNestedManyWithoutBundlesInput
  }

  export type BundleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    products?: ProductUpdateManyWithoutBundlesNestedInput
  }

  export type BundleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutBundlesNestedInput
  }

  export type BundleCreateManyInput = {
    id?: string
    name: string
    price: number
  }

  export type BundleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type BundleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    price?: number | null
    priceCents: number
    currency?: string
    inventory?: number
    category: CategoryCreateNestedOneWithoutProductsInput
    bundles?: BundleCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    price?: number | null
    priceCents: number
    currency?: string
    inventory?: number
    categoryId: string
    bundles?: BundleUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    bundles?: BundleUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    bundles?: BundleUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    price?: number | null
    priceCents: number
    currency?: string
    inventory?: number
    categoryId: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryCreateInput = {
    id?: string
    status: string
    trackingUrl?: string | null
    address: string
    courier?: string | null
    estimatedDate?: Date | string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateInput = {
    id?: string
    orderId: string
    status: string
    trackingUrl?: string | null
    address: string
    courier?: string | null
    estimatedDate?: Date | string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type DeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trackingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    courier?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trackingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    courier?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryCreateManyInput = {
    id?: string
    orderId: string
    status: string
    trackingUrl?: string | null
    address: string
    courier?: string | null
    estimatedDate?: Date | string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type DeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trackingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    courier?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trackingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    courier?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateCreateInput = {
    id?: string
    name: string
    referralCode: string
    brandUrl?: string | null
    commissions?: CommissionCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateUncheckedCreateInput = {
    id?: string
    name: string
    referralCode: string
    brandUrl?: string | null
    commissions?: CommissionUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    brandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissions?: CommissionUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    brandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    commissions?: CommissionUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateCreateManyInput = {
    id?: string
    name: string
    referralCode: string
    brandUrl?: string | null
  }

  export type AffiliateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    brandUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AffiliateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    brandUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CoachMessageCreateInput = {
    id?: string
    sender: string
    body?: string | null
    attachmentUrl?: string | null
    attachmentName?: string | null
    attachmentType?: string | null
    attachmentSize?: number | null
    createdAt?: Date | string
    coach: CoachCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutCoachMessagesInput
  }

  export type CoachMessageUncheckedCreateInput = {
    id?: string
    coachId: string
    userId: string
    sender: string
    body?: string | null
    attachmentUrl?: string | null
    attachmentName?: string | null
    attachmentType?: string | null
    attachmentSize?: number | null
    createdAt?: Date | string
  }

  export type CoachMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentName?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentType?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutCoachMessagesNestedInput
  }

  export type CoachMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentName?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentType?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachMessageCreateManyInput = {
    id?: string
    coachId: string
    userId: string
    sender: string
    body?: string | null
    attachmentUrl?: string | null
    attachmentName?: string | null
    attachmentType?: string | null
    attachmentSize?: number | null
    createdAt?: Date | string
  }

  export type CoachMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentName?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentType?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentName?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentType?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionCreateInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    coach: CoachCreateNestedOneWithoutCommissionsInput
    order: OrderCreateNestedOneWithoutCommissionsInput
    affiliate?: AffiliateCreateNestedOneWithoutCommissionsInput
    User?: UserCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionUncheckedCreateInput = {
    id?: string
    coachId: string
    orderId: string
    affiliateId?: string | null
    amount: number
    createdAt?: Date | string
    userId?: string | null
  }

  export type CommissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneRequiredWithoutCommissionsNestedInput
    order?: OrderUpdateOneRequiredWithoutCommissionsNestedInput
    affiliate?: AffiliateUpdateOneWithoutCommissionsNestedInput
    User?: UserUpdateOneWithoutCommissionsNestedInput
  }

  export type CommissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommissionCreateManyInput = {
    id?: string
    coachId: string
    orderId: string
    affiliateId?: string | null
    amount: number
    createdAt?: Date | string
    userId?: string | null
  }

  export type CommissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnalyticsCreateInput = {
    id?: string
    date?: Date | string
    revenue?: number
    engagement?: number
    supplementSales?: number
  }

  export type AnalyticsUncheckedCreateInput = {
    id?: string
    date?: Date | string
    revenue?: number
    engagement?: number
    supplementSales?: number
  }

  export type AnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: FloatFieldUpdateOperationsInput | number
    engagement?: IntFieldUpdateOperationsInput | number
    supplementSales?: IntFieldUpdateOperationsInput | number
  }

  export type AnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: FloatFieldUpdateOperationsInput | number
    engagement?: IntFieldUpdateOperationsInput | number
    supplementSales?: IntFieldUpdateOperationsInput | number
  }

  export type AnalyticsCreateManyInput = {
    id?: string
    date?: Date | string
    revenue?: number
    engagement?: number
    supplementSales?: number
  }

  export type AnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: FloatFieldUpdateOperationsInput | number
    engagement?: IntFieldUpdateOperationsInput | number
    supplementSales?: IntFieldUpdateOperationsInput | number
  }

  export type AnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    revenue?: FloatFieldUpdateOperationsInput | number
    engagement?: IntFieldUpdateOperationsInput | number
    supplementSales?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateInput = {
    id?: string
    type: string
    description?: string | null
    achievedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    description?: string | null
    achievedAt?: Date | string | null
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MilestoneCreateManyInput = {
    id?: string
    userId: string
    type: string
    description?: string | null
    achievedAt?: Date | string | null
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    order?: OrderCreateNestedOneWithoutPaymentsInput
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    orderId?: string | null
    subscriptionId?: string | null
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    order?: OrderUpdateOneWithoutPaymentsNestedInput
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    orderId?: string | null
    subscriptionId?: string | null
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateInput = {
    id?: string
    provider: string
    eventId: string
    payload: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
  }

  export type WebhookEventUncheckedCreateInput = {
    id?: string
    provider: string
    eventId: string
    payload: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
  }

  export type WebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateManyInput = {
    id?: string
    provider: string
    eventId: string
    payload: JsonNullValueInput | InputJsonValue
    processed?: boolean
    createdAt?: Date | string
  }

  export type WebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    processed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestCreateInput = {
    id?: string
    status: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCoachRequestsInput
  }

  export type CoachRequestUncheckedCreateInput = {
    id?: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type CoachRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachRequestsNestedInput
  }

  export type CoachRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestCreateManyInput = {
    id?: string
    userId: string
    status: string
    createdAt?: Date | string
  }

  export type CoachRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIntakeCreateInput = {
    id?: string
    gender?: string | null
    mainGoal?: string | null
    workoutLocation?: string | null
    firstCompletedAt?: Date | string | null
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    experienceLevel?: string | null
    workoutFrequency?: number | null
    injuries?: UserIntakeCreateinjuriesInput | string[]
    secondCompletedAt?: Date | string | null
    skippedSecond?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIntakeInput
  }

  export type UserIntakeUncheckedCreateInput = {
    id?: string
    userId: string
    gender?: string | null
    mainGoal?: string | null
    workoutLocation?: string | null
    firstCompletedAt?: Date | string | null
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    experienceLevel?: string | null
    workoutFrequency?: number | null
    injuries?: UserIntakeCreateinjuriesInput | string[]
    secondCompletedAt?: Date | string | null
    skippedSecond?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIntakeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    mainGoal?: NullableStringFieldUpdateOperationsInput | string | null
    workoutLocation?: NullableStringFieldUpdateOperationsInput | string | null
    firstCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    injuries?: UserIntakeUpdateinjuriesInput | string[]
    secondCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skippedSecond?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIntakeNestedInput
  }

  export type UserIntakeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    mainGoal?: NullableStringFieldUpdateOperationsInput | string | null
    workoutLocation?: NullableStringFieldUpdateOperationsInput | string | null
    firstCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    injuries?: UserIntakeUpdateinjuriesInput | string[]
    secondCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skippedSecond?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIntakeCreateManyInput = {
    id?: string
    userId: string
    gender?: string | null
    mainGoal?: string | null
    workoutLocation?: string | null
    firstCompletedAt?: Date | string | null
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    experienceLevel?: string | null
    workoutFrequency?: number | null
    injuries?: UserIntakeCreateinjuriesInput | string[]
    secondCompletedAt?: Date | string | null
    skippedSecond?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIntakeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    mainGoal?: NullableStringFieldUpdateOperationsInput | string | null
    workoutLocation?: NullableStringFieldUpdateOperationsInput | string | null
    firstCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    injuries?: UserIntakeUpdateinjuriesInput | string[]
    secondCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skippedSecond?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIntakeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    mainGoal?: NullableStringFieldUpdateOperationsInput | string | null
    workoutLocation?: NullableStringFieldUpdateOperationsInput | string | null
    firstCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    injuries?: UserIntakeUpdateinjuriesInput | string[]
    secondCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skippedSecond?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionQuotaCreateInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    messagesUsed?: number
    callsUsed?: number
    attachmentsUsed?: number
    resetAt?: Date | string
    nutritionWindowDays?: number | null
    nutritionExpiresAt?: Date | string | null
    nutritionLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionQuotaInput
  }

  export type SubscriptionQuotaUncheckedCreateInput = {
    id?: string
    userId: string
    tier?: $Enums.SubscriptionTier
    messagesUsed?: number
    callsUsed?: number
    attachmentsUsed?: number
    resetAt?: Date | string
    nutritionWindowDays?: number | null
    nutritionExpiresAt?: Date | string | null
    nutritionLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    messagesUsed?: IntFieldUpdateOperationsInput | number
    callsUsed?: IntFieldUpdateOperationsInput | number
    attachmentsUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nutritionWindowDays?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nutritionLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionQuotaNestedInput
  }

  export type SubscriptionQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    messagesUsed?: IntFieldUpdateOperationsInput | number
    callsUsed?: IntFieldUpdateOperationsInput | number
    attachmentsUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nutritionWindowDays?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nutritionLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionQuotaCreateManyInput = {
    id?: string
    userId: string
    tier?: $Enums.SubscriptionTier
    messagesUsed?: number
    callsUsed?: number
    attachmentsUsed?: number
    resetAt?: Date | string
    nutritionWindowDays?: number | null
    nutritionExpiresAt?: Date | string | null
    nutritionLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    messagesUsed?: IntFieldUpdateOperationsInput | number
    callsUsed?: IntFieldUpdateOperationsInput | number
    attachmentsUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nutritionWindowDays?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nutritionLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    messagesUsed?: IntFieldUpdateOperationsInput | number
    callsUsed?: IntFieldUpdateOperationsInput | number
    attachmentsUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nutritionWindowDays?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nutritionLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionPreferenceCreateInput = {
    id?: string
    proteinSources?: NutritionPreferenceCreateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceCreateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNutritionPreferenceInput
  }

  export type NutritionPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    proteinSources?: NutritionPreferenceCreateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceCreateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proteinSources?: NutritionPreferenceUpdateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceUpdateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNutritionPreferenceNestedInput
  }

  export type NutritionPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    proteinSources?: NutritionPreferenceUpdateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceUpdateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionPreferenceCreateManyInput = {
    id?: string
    userId: string
    proteinSources?: NutritionPreferenceCreateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceCreateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proteinSources?: NutritionPreferenceUpdateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceUpdateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    proteinSources?: NutritionPreferenceUpdateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceUpdateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionAccessCreateInput = {
    id?: string
    planGeneratedAt: Date | string
    expiresAt?: Date | string | null
    locked?: boolean
    windowDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNutritionAccessInput
  }

  export type NutritionAccessUncheckedCreateInput = {
    id?: string
    userId: string
    planGeneratedAt: Date | string
    expiresAt?: Date | string | null
    locked?: boolean
    windowDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    windowDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNutritionAccessNestedInput
  }

  export type NutritionAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    windowDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionAccessCreateManyInput = {
    id?: string
    userId: string
    planGeneratedAt: Date | string
    expiresAt?: Date | string | null
    locked?: boolean
    windowDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    windowDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    windowDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type CoachNullableRelationFilter = {
    is?: CoachWhereInput | null
    isNot?: CoachWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type RecommendationListRelationFilter = {
    every?: RecommendationWhereInput
    some?: RecommendationWhereInput
    none?: RecommendationWhereInput
  }

  export type CommissionListRelationFilter = {
    every?: CommissionWhereInput
    some?: CommissionWhereInput
    none?: CommissionWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type WorkoutLogListRelationFilter = {
    every?: WorkoutLogWhereInput
    some?: WorkoutLogWhereInput
    none?: WorkoutLogWhereInput
  }

  export type NutritionLogListRelationFilter = {
    every?: NutritionLogWhereInput
    some?: NutritionLogWhereInput
    none?: NutritionLogWhereInput
  }

  export type SupplementLogListRelationFilter = {
    every?: SupplementLogWhereInput
    some?: SupplementLogWhereInput
    none?: SupplementLogWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type CoachRequestListRelationFilter = {
    every?: CoachRequestWhereInput
    some?: CoachRequestWhereInput
    none?: CoachRequestWhereInput
  }

  export type UserIntakeNullableRelationFilter = {
    is?: UserIntakeWhereInput | null
    isNot?: UserIntakeWhereInput | null
  }

  export type SubscriptionQuotaNullableRelationFilter = {
    is?: SubscriptionQuotaWhereInput | null
    isNot?: SubscriptionQuotaWhereInput | null
  }

  export type NutritionPreferenceNullableRelationFilter = {
    is?: NutritionPreferenceWhereInput | null
    isNot?: NutritionPreferenceWhereInput | null
  }

  export type NutritionAccessNullableRelationFilter = {
    is?: NutritionAccessWhereInput | null
    isNot?: NutritionAccessWhereInput | null
  }

  export type CoachMessageListRelationFilter = {
    every?: CoachMessageWhereInput
    some?: CoachMessageWhereInput
    none?: CoachMessageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NutritionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplementLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    preferredLocale?: SortOrder
    deviceToken?: SortOrder
    role?: SortOrder
    coachId?: SortOrder
    coachClientsId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    preferredLocale?: SortOrder
    deviceToken?: SortOrder
    role?: SortOrder
    coachId?: SortOrder
    coachClientsId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    preferredLocale?: SortOrder
    deviceToken?: SortOrder
    role?: SortOrder
    coachId?: SortOrder
    coachClientsId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrder
    scheduledAt?: SortOrder
    durationMin?: SortOrder
    status?: SortOrder
    agoraChannel?: SortOrder
    rating?: SortOrder
    ratingNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    durationMin?: SortOrder
    rating?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrder
    scheduledAt?: SortOrder
    durationMin?: SortOrder
    status?: SortOrder
    agoraChannel?: SortOrder
    rating?: SortOrder
    ratingNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrder
    scheduledAt?: SortOrder
    durationMin?: SortOrder
    status?: SortOrder
    agoraChannel?: SortOrder
    rating?: SortOrder
    ratingNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    durationMin?: SortOrder
    rating?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type DeliveryNullableRelationFilter = {
    is?: DeliveryWhereInput | null
    isNot?: DeliveryWhereInput | null
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalCents?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalCents?: SortOrder
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    sku?: SortOrder
    qty?: SortOrder
    priceCents?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    qty?: SortOrder
    priceCents?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    sku?: SortOrder
    qty?: SortOrder
    priceCents?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    sku?: SortOrder
    qty?: SortOrder
    priceCents?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    qty?: SortOrder
    priceCents?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CoachCertificateListRelationFilter = {
    every?: CoachCertificateWhereInput
    some?: CoachCertificateWhereInput
    none?: CoachCertificateWhereInput
  }

  export type CoachExperienceListRelationFilter = {
    every?: CoachExperienceWhereInput
    some?: CoachExperienceWhereInput
    none?: CoachExperienceWhereInput
  }

  export type CoachAchievementListRelationFilter = {
    every?: CoachAchievementWhereInput
    some?: CoachAchievementWhereInput
    none?: CoachAchievementWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachCertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    certifications?: SortOrder
    referralCode?: SortOrder
    specializations?: SortOrder
    experienceYears?: SortOrder
    headline?: SortOrder
    verified?: SortOrder
  }

  export type CoachAvgOrderByAggregateInput = {
    experienceYears?: SortOrder
  }

  export type CoachMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    certifications?: SortOrder
    referralCode?: SortOrder
    experienceYears?: SortOrder
    headline?: SortOrder
    verified?: SortOrder
  }

  export type CoachMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    certifications?: SortOrder
    referralCode?: SortOrder
    experienceYears?: SortOrder
    headline?: SortOrder
    verified?: SortOrder
  }

  export type CoachSumOrderByAggregateInput = {
    experienceYears?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CoachRelationFilter = {
    is?: CoachWhereInput
    isNot?: CoachWhereInput
  }

  export type CoachCertificateCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    name?: SortOrder
    issuingOrganization?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    certificateUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachCertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    name?: SortOrder
    issuingOrganization?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    certificateUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachCertificateMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    name?: SortOrder
    issuingOrganization?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    certificateUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CoachExperienceCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    organization?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachExperienceMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    organization?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachExperienceMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    organization?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCurrent?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    achievedAt?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    achievedAt?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    achievedAt?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkoutLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    activity?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutLogAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type WorkoutLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    activity?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    activity?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
  }

  export type WorkoutLogSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NutritionLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    meal?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    mealType?: SortOrder
    notes?: SortOrder
  }

  export type NutritionLogAvgOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
  }

  export type NutritionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    meal?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    mealType?: SortOrder
    notes?: SortOrder
  }

  export type NutritionLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    meal?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    mealType?: SortOrder
    notes?: SortOrder
  }

  export type NutritionLogSumOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SupplementLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    supplementName?: SortOrder
    dose?: SortOrder
    notes?: SortOrder
  }

  export type SupplementLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    supplementName?: SortOrder
    dose?: SortOrder
    notes?: SortOrder
  }

  export type SupplementLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    supplementName?: SortOrder
    dose?: SortOrder
    notes?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type RecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type RecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BundleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type BundleAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BundleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type BundleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type BundleSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type BundleListRelationFilter = {
    every?: BundleWhereInput
    some?: BundleWhereInput
    none?: BundleWhereInput
  }

  export type BundleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    inventory?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    priceCents?: SortOrder
    inventory?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    inventory?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    priceCents?: SortOrder
    currency?: SortOrder
    inventory?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    priceCents?: SortOrder
    inventory?: SortOrder
  }

  export type DeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    trackingUrl?: SortOrder
    address?: SortOrder
    courier?: SortOrder
    estimatedDate?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    trackingUrl?: SortOrder
    address?: SortOrder
    courier?: SortOrder
    estimatedDate?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    trackingUrl?: SortOrder
    address?: SortOrder
    courier?: SortOrder
    estimatedDate?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AffiliateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    referralCode?: SortOrder
    brandUrl?: SortOrder
  }

  export type AffiliateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    referralCode?: SortOrder
    brandUrl?: SortOrder
  }

  export type AffiliateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    referralCode?: SortOrder
    brandUrl?: SortOrder
  }

  export type CoachMessageCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    userId?: SortOrder
    sender?: SortOrder
    body?: SortOrder
    attachmentUrl?: SortOrder
    attachmentName?: SortOrder
    attachmentType?: SortOrder
    attachmentSize?: SortOrder
    createdAt?: SortOrder
  }

  export type CoachMessageAvgOrderByAggregateInput = {
    attachmentSize?: SortOrder
  }

  export type CoachMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    userId?: SortOrder
    sender?: SortOrder
    body?: SortOrder
    attachmentUrl?: SortOrder
    attachmentName?: SortOrder
    attachmentType?: SortOrder
    attachmentSize?: SortOrder
    createdAt?: SortOrder
  }

  export type CoachMessageMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    userId?: SortOrder
    sender?: SortOrder
    body?: SortOrder
    attachmentUrl?: SortOrder
    attachmentName?: SortOrder
    attachmentType?: SortOrder
    attachmentSize?: SortOrder
    createdAt?: SortOrder
  }

  export type CoachMessageSumOrderByAggregateInput = {
    attachmentSize?: SortOrder
  }

  export type AffiliateNullableRelationFilter = {
    is?: AffiliateWhereInput | null
    isNot?: AffiliateWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CommissionCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    orderId?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type CommissionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CommissionMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    orderId?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type CommissionMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    orderId?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type CommissionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    engagement?: SortOrder
    supplementSales?: SortOrder
  }

  export type AnalyticsAvgOrderByAggregateInput = {
    revenue?: SortOrder
    engagement?: SortOrder
    supplementSales?: SortOrder
  }

  export type AnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    engagement?: SortOrder
    supplementSales?: SortOrder
  }

  export type AnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    revenue?: SortOrder
    engagement?: SortOrder
    supplementSales?: SortOrder
  }

  export type AnalyticsSumOrderByAggregateInput = {
    revenue?: SortOrder
    engagement?: SortOrder
    supplementSales?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    achievedAt?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    achievedAt?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    achievedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OrderNullableRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    amountCents?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    amountCents?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    amountCents?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    eventId?: SortOrder
    payload?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    eventId?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    eventId?: SortOrder
    processed?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CoachRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type CoachRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type CoachRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type UserIntakeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    mainGoal?: SortOrder
    workoutLocation?: SortOrder
    firstCompletedAt?: SortOrder
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    experienceLevel?: SortOrder
    workoutFrequency?: SortOrder
    injuries?: SortOrder
    secondCompletedAt?: SortOrder
    skippedSecond?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserIntakeAvgOrderByAggregateInput = {
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    workoutFrequency?: SortOrder
  }

  export type UserIntakeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    mainGoal?: SortOrder
    workoutLocation?: SortOrder
    firstCompletedAt?: SortOrder
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    experienceLevel?: SortOrder
    workoutFrequency?: SortOrder
    secondCompletedAt?: SortOrder
    skippedSecond?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserIntakeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    mainGoal?: SortOrder
    workoutLocation?: SortOrder
    firstCompletedAt?: SortOrder
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    experienceLevel?: SortOrder
    workoutFrequency?: SortOrder
    secondCompletedAt?: SortOrder
    skippedSecond?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserIntakeSumOrderByAggregateInput = {
    age?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    workoutFrequency?: SortOrder
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type SubscriptionQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    messagesUsed?: SortOrder
    callsUsed?: SortOrder
    attachmentsUsed?: SortOrder
    resetAt?: SortOrder
    nutritionWindowDays?: SortOrder
    nutritionExpiresAt?: SortOrder
    nutritionLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionQuotaAvgOrderByAggregateInput = {
    messagesUsed?: SortOrder
    callsUsed?: SortOrder
    attachmentsUsed?: SortOrder
    nutritionWindowDays?: SortOrder
  }

  export type SubscriptionQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    messagesUsed?: SortOrder
    callsUsed?: SortOrder
    attachmentsUsed?: SortOrder
    resetAt?: SortOrder
    nutritionWindowDays?: SortOrder
    nutritionExpiresAt?: SortOrder
    nutritionLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    messagesUsed?: SortOrder
    callsUsed?: SortOrder
    attachmentsUsed?: SortOrder
    resetAt?: SortOrder
    nutritionWindowDays?: SortOrder
    nutritionExpiresAt?: SortOrder
    nutritionLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionQuotaSumOrderByAggregateInput = {
    messagesUsed?: SortOrder
    callsUsed?: SortOrder
    attachmentsUsed?: SortOrder
    nutritionWindowDays?: SortOrder
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NutritionPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    proteinSources?: SortOrder
    proteinAllergies?: SortOrder
    dinnerPreferences?: SortOrder
    additionalNotes?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    additionalNotes?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    additionalNotes?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionAccessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planGeneratedAt?: SortOrder
    expiresAt?: SortOrder
    locked?: SortOrder
    windowDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionAccessAvgOrderByAggregateInput = {
    windowDays?: SortOrder
  }

  export type NutritionAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planGeneratedAt?: SortOrder
    expiresAt?: SortOrder
    locked?: SortOrder
    windowDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionAccessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planGeneratedAt?: SortOrder
    expiresAt?: SortOrder
    locked?: SortOrder
    windowDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NutritionAccessSumOrderByAggregateInput = {
    windowDays?: SortOrder
  }

  export type CoachCreateNestedOneWithoutUserInput = {
    create?: XOR<CoachCreateWithoutUserInput, CoachUncheckedCreateWithoutUserInput>
    connectOrCreate?: CoachCreateOrConnectWithoutUserInput
    connect?: CoachWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MilestoneCreateNestedManyWithoutUserInput = {
    create?: XOR<MilestoneCreateWithoutUserInput, MilestoneUncheckedCreateWithoutUserInput> | MilestoneCreateWithoutUserInput[] | MilestoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutUserInput | MilestoneCreateOrConnectWithoutUserInput[]
    createMany?: MilestoneCreateManyUserInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RecommendationCreateNestedManyWithoutUserInput = {
    create?: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput> | RecommendationCreateWithoutUserInput[] | RecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutUserInput | RecommendationCreateOrConnectWithoutUserInput[]
    createMany?: RecommendationCreateManyUserInputEnvelope
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
  }

  export type CommissionCreateNestedManyWithoutUserInput = {
    create?: XOR<CommissionCreateWithoutUserInput, CommissionUncheckedCreateWithoutUserInput> | CommissionCreateWithoutUserInput[] | CommissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutUserInput | CommissionCreateOrConnectWithoutUserInput[]
    createMany?: CommissionCreateManyUserInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type CoachCreateNestedOneWithoutClientsInput = {
    create?: XOR<CoachCreateWithoutClientsInput, CoachUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutClientsInput
    connect?: CoachWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type WorkoutLogCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkoutLogCreateWithoutUserInput, WorkoutLogUncheckedCreateWithoutUserInput> | WorkoutLogCreateWithoutUserInput[] | WorkoutLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutLogCreateOrConnectWithoutUserInput | WorkoutLogCreateOrConnectWithoutUserInput[]
    createMany?: WorkoutLogCreateManyUserInputEnvelope
    connect?: WorkoutLogWhereUniqueInput | WorkoutLogWhereUniqueInput[]
  }

  export type NutritionLogCreateNestedManyWithoutUserInput = {
    create?: XOR<NutritionLogCreateWithoutUserInput, NutritionLogUncheckedCreateWithoutUserInput> | NutritionLogCreateWithoutUserInput[] | NutritionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NutritionLogCreateOrConnectWithoutUserInput | NutritionLogCreateOrConnectWithoutUserInput[]
    createMany?: NutritionLogCreateManyUserInputEnvelope
    connect?: NutritionLogWhereUniqueInput | NutritionLogWhereUniqueInput[]
  }

  export type SupplementLogCreateNestedManyWithoutUserInput = {
    create?: XOR<SupplementLogCreateWithoutUserInput, SupplementLogUncheckedCreateWithoutUserInput> | SupplementLogCreateWithoutUserInput[] | SupplementLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupplementLogCreateOrConnectWithoutUserInput | SupplementLogCreateOrConnectWithoutUserInput[]
    createMany?: SupplementLogCreateManyUserInputEnvelope
    connect?: SupplementLogWhereUniqueInput | SupplementLogWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type CoachRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<CoachRequestCreateWithoutUserInput, CoachRequestUncheckedCreateWithoutUserInput> | CoachRequestCreateWithoutUserInput[] | CoachRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutUserInput | CoachRequestCreateOrConnectWithoutUserInput[]
    createMany?: CoachRequestCreateManyUserInputEnvelope
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
  }

  export type UserIntakeCreateNestedOneWithoutUserInput = {
    create?: XOR<UserIntakeCreateWithoutUserInput, UserIntakeUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserIntakeCreateOrConnectWithoutUserInput
    connect?: UserIntakeWhereUniqueInput
  }

  export type SubscriptionQuotaCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionQuotaCreateWithoutUserInput, SubscriptionQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionQuotaCreateOrConnectWithoutUserInput
    connect?: SubscriptionQuotaWhereUniqueInput
  }

  export type NutritionPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<NutritionPreferenceCreateWithoutUserInput, NutritionPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NutritionPreferenceCreateOrConnectWithoutUserInput
    connect?: NutritionPreferenceWhereUniqueInput
  }

  export type NutritionAccessCreateNestedOneWithoutUserInput = {
    create?: XOR<NutritionAccessCreateWithoutUserInput, NutritionAccessUncheckedCreateWithoutUserInput>
    connectOrCreate?: NutritionAccessCreateOrConnectWithoutUserInput
    connect?: NutritionAccessWhereUniqueInput
  }

  export type CoachMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<CoachMessageCreateWithoutUserInput, CoachMessageUncheckedCreateWithoutUserInput> | CoachMessageCreateWithoutUserInput[] | CoachMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachMessageCreateOrConnectWithoutUserInput | CoachMessageCreateOrConnectWithoutUserInput[]
    createMany?: CoachMessageCreateManyUserInputEnvelope
    connect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
  }

  export type CoachUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CoachCreateWithoutUserInput, CoachUncheckedCreateWithoutUserInput>
    connectOrCreate?: CoachCreateOrConnectWithoutUserInput
    connect?: CoachWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MilestoneCreateWithoutUserInput, MilestoneUncheckedCreateWithoutUserInput> | MilestoneCreateWithoutUserInput[] | MilestoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutUserInput | MilestoneCreateOrConnectWithoutUserInput[]
    createMany?: MilestoneCreateManyUserInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RecommendationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput> | RecommendationCreateWithoutUserInput[] | RecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutUserInput | RecommendationCreateOrConnectWithoutUserInput[]
    createMany?: RecommendationCreateManyUserInputEnvelope
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
  }

  export type CommissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommissionCreateWithoutUserInput, CommissionUncheckedCreateWithoutUserInput> | CommissionCreateWithoutUserInput[] | CommissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutUserInput | CommissionCreateOrConnectWithoutUserInput[]
    createMany?: CommissionCreateManyUserInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type WorkoutLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkoutLogCreateWithoutUserInput, WorkoutLogUncheckedCreateWithoutUserInput> | WorkoutLogCreateWithoutUserInput[] | WorkoutLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutLogCreateOrConnectWithoutUserInput | WorkoutLogCreateOrConnectWithoutUserInput[]
    createMany?: WorkoutLogCreateManyUserInputEnvelope
    connect?: WorkoutLogWhereUniqueInput | WorkoutLogWhereUniqueInput[]
  }

  export type NutritionLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NutritionLogCreateWithoutUserInput, NutritionLogUncheckedCreateWithoutUserInput> | NutritionLogCreateWithoutUserInput[] | NutritionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NutritionLogCreateOrConnectWithoutUserInput | NutritionLogCreateOrConnectWithoutUserInput[]
    createMany?: NutritionLogCreateManyUserInputEnvelope
    connect?: NutritionLogWhereUniqueInput | NutritionLogWhereUniqueInput[]
  }

  export type SupplementLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupplementLogCreateWithoutUserInput, SupplementLogUncheckedCreateWithoutUserInput> | SupplementLogCreateWithoutUserInput[] | SupplementLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupplementLogCreateOrConnectWithoutUserInput | SupplementLogCreateOrConnectWithoutUserInput[]
    createMany?: SupplementLogCreateManyUserInputEnvelope
    connect?: SupplementLogWhereUniqueInput | SupplementLogWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type CoachRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CoachRequestCreateWithoutUserInput, CoachRequestUncheckedCreateWithoutUserInput> | CoachRequestCreateWithoutUserInput[] | CoachRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutUserInput | CoachRequestCreateOrConnectWithoutUserInput[]
    createMany?: CoachRequestCreateManyUserInputEnvelope
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
  }

  export type UserIntakeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserIntakeCreateWithoutUserInput, UserIntakeUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserIntakeCreateOrConnectWithoutUserInput
    connect?: UserIntakeWhereUniqueInput
  }

  export type SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionQuotaCreateWithoutUserInput, SubscriptionQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionQuotaCreateOrConnectWithoutUserInput
    connect?: SubscriptionQuotaWhereUniqueInput
  }

  export type NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NutritionPreferenceCreateWithoutUserInput, NutritionPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NutritionPreferenceCreateOrConnectWithoutUserInput
    connect?: NutritionPreferenceWhereUniqueInput
  }

  export type NutritionAccessUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NutritionAccessCreateWithoutUserInput, NutritionAccessUncheckedCreateWithoutUserInput>
    connectOrCreate?: NutritionAccessCreateOrConnectWithoutUserInput
    connect?: NutritionAccessWhereUniqueInput
  }

  export type CoachMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CoachMessageCreateWithoutUserInput, CoachMessageUncheckedCreateWithoutUserInput> | CoachMessageCreateWithoutUserInput[] | CoachMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachMessageCreateOrConnectWithoutUserInput | CoachMessageCreateOrConnectWithoutUserInput[]
    createMany?: CoachMessageCreateManyUserInputEnvelope
    connect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type CoachUpdateOneWithoutUserNestedInput = {
    create?: XOR<CoachCreateWithoutUserInput, CoachUncheckedCreateWithoutUserInput>
    connectOrCreate?: CoachCreateOrConnectWithoutUserInput
    upsert?: CoachUpsertWithoutUserInput
    disconnect?: CoachWhereInput | boolean
    delete?: CoachWhereInput | boolean
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutUserInput, CoachUpdateWithoutUserInput>, CoachUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MilestoneUpdateManyWithoutUserNestedInput = {
    create?: XOR<MilestoneCreateWithoutUserInput, MilestoneUncheckedCreateWithoutUserInput> | MilestoneCreateWithoutUserInput[] | MilestoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutUserInput | MilestoneCreateOrConnectWithoutUserInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutUserInput | MilestoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MilestoneCreateManyUserInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutUserInput | MilestoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutUserInput | MilestoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RecommendationUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput> | RecommendationCreateWithoutUserInput[] | RecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutUserInput | RecommendationCreateOrConnectWithoutUserInput[]
    upsert?: RecommendationUpsertWithWhereUniqueWithoutUserInput | RecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecommendationCreateManyUserInputEnvelope
    set?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    disconnect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    delete?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    update?: RecommendationUpdateWithWhereUniqueWithoutUserInput | RecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecommendationUpdateManyWithWhereWithoutUserInput | RecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
  }

  export type CommissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommissionCreateWithoutUserInput, CommissionUncheckedCreateWithoutUserInput> | CommissionCreateWithoutUserInput[] | CommissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutUserInput | CommissionCreateOrConnectWithoutUserInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutUserInput | CommissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommissionCreateManyUserInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutUserInput | CommissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutUserInput | CommissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type CoachUpdateOneWithoutClientsNestedInput = {
    create?: XOR<CoachCreateWithoutClientsInput, CoachUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutClientsInput
    upsert?: CoachUpsertWithoutClientsInput
    disconnect?: CoachWhereInput | boolean
    delete?: CoachWhereInput | boolean
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutClientsInput, CoachUpdateWithoutClientsInput>, CoachUncheckedUpdateWithoutClientsInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type WorkoutLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkoutLogCreateWithoutUserInput, WorkoutLogUncheckedCreateWithoutUserInput> | WorkoutLogCreateWithoutUserInput[] | WorkoutLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutLogCreateOrConnectWithoutUserInput | WorkoutLogCreateOrConnectWithoutUserInput[]
    upsert?: WorkoutLogUpsertWithWhereUniqueWithoutUserInput | WorkoutLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkoutLogCreateManyUserInputEnvelope
    set?: WorkoutLogWhereUniqueInput | WorkoutLogWhereUniqueInput[]
    disconnect?: WorkoutLogWhereUniqueInput | WorkoutLogWhereUniqueInput[]
    delete?: WorkoutLogWhereUniqueInput | WorkoutLogWhereUniqueInput[]
    connect?: WorkoutLogWhereUniqueInput | WorkoutLogWhereUniqueInput[]
    update?: WorkoutLogUpdateWithWhereUniqueWithoutUserInput | WorkoutLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkoutLogUpdateManyWithWhereWithoutUserInput | WorkoutLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkoutLogScalarWhereInput | WorkoutLogScalarWhereInput[]
  }

  export type NutritionLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<NutritionLogCreateWithoutUserInput, NutritionLogUncheckedCreateWithoutUserInput> | NutritionLogCreateWithoutUserInput[] | NutritionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NutritionLogCreateOrConnectWithoutUserInput | NutritionLogCreateOrConnectWithoutUserInput[]
    upsert?: NutritionLogUpsertWithWhereUniqueWithoutUserInput | NutritionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NutritionLogCreateManyUserInputEnvelope
    set?: NutritionLogWhereUniqueInput | NutritionLogWhereUniqueInput[]
    disconnect?: NutritionLogWhereUniqueInput | NutritionLogWhereUniqueInput[]
    delete?: NutritionLogWhereUniqueInput | NutritionLogWhereUniqueInput[]
    connect?: NutritionLogWhereUniqueInput | NutritionLogWhereUniqueInput[]
    update?: NutritionLogUpdateWithWhereUniqueWithoutUserInput | NutritionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NutritionLogUpdateManyWithWhereWithoutUserInput | NutritionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NutritionLogScalarWhereInput | NutritionLogScalarWhereInput[]
  }

  export type SupplementLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupplementLogCreateWithoutUserInput, SupplementLogUncheckedCreateWithoutUserInput> | SupplementLogCreateWithoutUserInput[] | SupplementLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupplementLogCreateOrConnectWithoutUserInput | SupplementLogCreateOrConnectWithoutUserInput[]
    upsert?: SupplementLogUpsertWithWhereUniqueWithoutUserInput | SupplementLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupplementLogCreateManyUserInputEnvelope
    set?: SupplementLogWhereUniqueInput | SupplementLogWhereUniqueInput[]
    disconnect?: SupplementLogWhereUniqueInput | SupplementLogWhereUniqueInput[]
    delete?: SupplementLogWhereUniqueInput | SupplementLogWhereUniqueInput[]
    connect?: SupplementLogWhereUniqueInput | SupplementLogWhereUniqueInput[]
    update?: SupplementLogUpdateWithWhereUniqueWithoutUserInput | SupplementLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupplementLogUpdateManyWithWhereWithoutUserInput | SupplementLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupplementLogScalarWhereInput | SupplementLogScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type CoachRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoachRequestCreateWithoutUserInput, CoachRequestUncheckedCreateWithoutUserInput> | CoachRequestCreateWithoutUserInput[] | CoachRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutUserInput | CoachRequestCreateOrConnectWithoutUserInput[]
    upsert?: CoachRequestUpsertWithWhereUniqueWithoutUserInput | CoachRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoachRequestCreateManyUserInputEnvelope
    set?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    disconnect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    delete?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    update?: CoachRequestUpdateWithWhereUniqueWithoutUserInput | CoachRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoachRequestUpdateManyWithWhereWithoutUserInput | CoachRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoachRequestScalarWhereInput | CoachRequestScalarWhereInput[]
  }

  export type UserIntakeUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserIntakeCreateWithoutUserInput, UserIntakeUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserIntakeCreateOrConnectWithoutUserInput
    upsert?: UserIntakeUpsertWithoutUserInput
    disconnect?: UserIntakeWhereInput | boolean
    delete?: UserIntakeWhereInput | boolean
    connect?: UserIntakeWhereUniqueInput
    update?: XOR<XOR<UserIntakeUpdateToOneWithWhereWithoutUserInput, UserIntakeUpdateWithoutUserInput>, UserIntakeUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionQuotaUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionQuotaCreateWithoutUserInput, SubscriptionQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionQuotaCreateOrConnectWithoutUserInput
    upsert?: SubscriptionQuotaUpsertWithoutUserInput
    disconnect?: SubscriptionQuotaWhereInput | boolean
    delete?: SubscriptionQuotaWhereInput | boolean
    connect?: SubscriptionQuotaWhereUniqueInput
    update?: XOR<XOR<SubscriptionQuotaUpdateToOneWithWhereWithoutUserInput, SubscriptionQuotaUpdateWithoutUserInput>, SubscriptionQuotaUncheckedUpdateWithoutUserInput>
  }

  export type NutritionPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<NutritionPreferenceCreateWithoutUserInput, NutritionPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NutritionPreferenceCreateOrConnectWithoutUserInput
    upsert?: NutritionPreferenceUpsertWithoutUserInput
    disconnect?: NutritionPreferenceWhereInput | boolean
    delete?: NutritionPreferenceWhereInput | boolean
    connect?: NutritionPreferenceWhereUniqueInput
    update?: XOR<XOR<NutritionPreferenceUpdateToOneWithWhereWithoutUserInput, NutritionPreferenceUpdateWithoutUserInput>, NutritionPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NutritionAccessUpdateOneWithoutUserNestedInput = {
    create?: XOR<NutritionAccessCreateWithoutUserInput, NutritionAccessUncheckedCreateWithoutUserInput>
    connectOrCreate?: NutritionAccessCreateOrConnectWithoutUserInput
    upsert?: NutritionAccessUpsertWithoutUserInput
    disconnect?: NutritionAccessWhereInput | boolean
    delete?: NutritionAccessWhereInput | boolean
    connect?: NutritionAccessWhereUniqueInput
    update?: XOR<XOR<NutritionAccessUpdateToOneWithWhereWithoutUserInput, NutritionAccessUpdateWithoutUserInput>, NutritionAccessUncheckedUpdateWithoutUserInput>
  }

  export type CoachMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoachMessageCreateWithoutUserInput, CoachMessageUncheckedCreateWithoutUserInput> | CoachMessageCreateWithoutUserInput[] | CoachMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachMessageCreateOrConnectWithoutUserInput | CoachMessageCreateOrConnectWithoutUserInput[]
    upsert?: CoachMessageUpsertWithWhereUniqueWithoutUserInput | CoachMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoachMessageCreateManyUserInputEnvelope
    set?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    disconnect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    delete?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    connect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    update?: CoachMessageUpdateWithWhereUniqueWithoutUserInput | CoachMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoachMessageUpdateManyWithWhereWithoutUserInput | CoachMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoachMessageScalarWhereInput | CoachMessageScalarWhereInput[]
  }

  export type CoachUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CoachCreateWithoutUserInput, CoachUncheckedCreateWithoutUserInput>
    connectOrCreate?: CoachCreateOrConnectWithoutUserInput
    upsert?: CoachUpsertWithoutUserInput
    disconnect?: CoachWhereInput | boolean
    delete?: CoachWhereInput | boolean
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutUserInput, CoachUpdateWithoutUserInput>, CoachUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MilestoneCreateWithoutUserInput, MilestoneUncheckedCreateWithoutUserInput> | MilestoneCreateWithoutUserInput[] | MilestoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutUserInput | MilestoneCreateOrConnectWithoutUserInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutUserInput | MilestoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MilestoneCreateManyUserInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutUserInput | MilestoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutUserInput | MilestoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RecommendationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput> | RecommendationCreateWithoutUserInput[] | RecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutUserInput | RecommendationCreateOrConnectWithoutUserInput[]
    upsert?: RecommendationUpsertWithWhereUniqueWithoutUserInput | RecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecommendationCreateManyUserInputEnvelope
    set?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    disconnect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    delete?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    update?: RecommendationUpdateWithWhereUniqueWithoutUserInput | RecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecommendationUpdateManyWithWhereWithoutUserInput | RecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
  }

  export type CommissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommissionCreateWithoutUserInput, CommissionUncheckedCreateWithoutUserInput> | CommissionCreateWithoutUserInput[] | CommissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutUserInput | CommissionCreateOrConnectWithoutUserInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutUserInput | CommissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommissionCreateManyUserInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutUserInput | CommissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutUserInput | CommissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type WorkoutLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkoutLogCreateWithoutUserInput, WorkoutLogUncheckedCreateWithoutUserInput> | WorkoutLogCreateWithoutUserInput[] | WorkoutLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkoutLogCreateOrConnectWithoutUserInput | WorkoutLogCreateOrConnectWithoutUserInput[]
    upsert?: WorkoutLogUpsertWithWhereUniqueWithoutUserInput | WorkoutLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkoutLogCreateManyUserInputEnvelope
    set?: WorkoutLogWhereUniqueInput | WorkoutLogWhereUniqueInput[]
    disconnect?: WorkoutLogWhereUniqueInput | WorkoutLogWhereUniqueInput[]
    delete?: WorkoutLogWhereUniqueInput | WorkoutLogWhereUniqueInput[]
    connect?: WorkoutLogWhereUniqueInput | WorkoutLogWhereUniqueInput[]
    update?: WorkoutLogUpdateWithWhereUniqueWithoutUserInput | WorkoutLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkoutLogUpdateManyWithWhereWithoutUserInput | WorkoutLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkoutLogScalarWhereInput | WorkoutLogScalarWhereInput[]
  }

  export type NutritionLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NutritionLogCreateWithoutUserInput, NutritionLogUncheckedCreateWithoutUserInput> | NutritionLogCreateWithoutUserInput[] | NutritionLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NutritionLogCreateOrConnectWithoutUserInput | NutritionLogCreateOrConnectWithoutUserInput[]
    upsert?: NutritionLogUpsertWithWhereUniqueWithoutUserInput | NutritionLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NutritionLogCreateManyUserInputEnvelope
    set?: NutritionLogWhereUniqueInput | NutritionLogWhereUniqueInput[]
    disconnect?: NutritionLogWhereUniqueInput | NutritionLogWhereUniqueInput[]
    delete?: NutritionLogWhereUniqueInput | NutritionLogWhereUniqueInput[]
    connect?: NutritionLogWhereUniqueInput | NutritionLogWhereUniqueInput[]
    update?: NutritionLogUpdateWithWhereUniqueWithoutUserInput | NutritionLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NutritionLogUpdateManyWithWhereWithoutUserInput | NutritionLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NutritionLogScalarWhereInput | NutritionLogScalarWhereInput[]
  }

  export type SupplementLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupplementLogCreateWithoutUserInput, SupplementLogUncheckedCreateWithoutUserInput> | SupplementLogCreateWithoutUserInput[] | SupplementLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupplementLogCreateOrConnectWithoutUserInput | SupplementLogCreateOrConnectWithoutUserInput[]
    upsert?: SupplementLogUpsertWithWhereUniqueWithoutUserInput | SupplementLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupplementLogCreateManyUserInputEnvelope
    set?: SupplementLogWhereUniqueInput | SupplementLogWhereUniqueInput[]
    disconnect?: SupplementLogWhereUniqueInput | SupplementLogWhereUniqueInput[]
    delete?: SupplementLogWhereUniqueInput | SupplementLogWhereUniqueInput[]
    connect?: SupplementLogWhereUniqueInput | SupplementLogWhereUniqueInput[]
    update?: SupplementLogUpdateWithWhereUniqueWithoutUserInput | SupplementLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupplementLogUpdateManyWithWhereWithoutUserInput | SupplementLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupplementLogScalarWhereInput | SupplementLogScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type CoachRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoachRequestCreateWithoutUserInput, CoachRequestUncheckedCreateWithoutUserInput> | CoachRequestCreateWithoutUserInput[] | CoachRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutUserInput | CoachRequestCreateOrConnectWithoutUserInput[]
    upsert?: CoachRequestUpsertWithWhereUniqueWithoutUserInput | CoachRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoachRequestCreateManyUserInputEnvelope
    set?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    disconnect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    delete?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    update?: CoachRequestUpdateWithWhereUniqueWithoutUserInput | CoachRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoachRequestUpdateManyWithWhereWithoutUserInput | CoachRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoachRequestScalarWhereInput | CoachRequestScalarWhereInput[]
  }

  export type UserIntakeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserIntakeCreateWithoutUserInput, UserIntakeUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserIntakeCreateOrConnectWithoutUserInput
    upsert?: UserIntakeUpsertWithoutUserInput
    disconnect?: UserIntakeWhereInput | boolean
    delete?: UserIntakeWhereInput | boolean
    connect?: UserIntakeWhereUniqueInput
    update?: XOR<XOR<UserIntakeUpdateToOneWithWhereWithoutUserInput, UserIntakeUpdateWithoutUserInput>, UserIntakeUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionQuotaCreateWithoutUserInput, SubscriptionQuotaUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionQuotaCreateOrConnectWithoutUserInput
    upsert?: SubscriptionQuotaUpsertWithoutUserInput
    disconnect?: SubscriptionQuotaWhereInput | boolean
    delete?: SubscriptionQuotaWhereInput | boolean
    connect?: SubscriptionQuotaWhereUniqueInput
    update?: XOR<XOR<SubscriptionQuotaUpdateToOneWithWhereWithoutUserInput, SubscriptionQuotaUpdateWithoutUserInput>, SubscriptionQuotaUncheckedUpdateWithoutUserInput>
  }

  export type NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NutritionPreferenceCreateWithoutUserInput, NutritionPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: NutritionPreferenceCreateOrConnectWithoutUserInput
    upsert?: NutritionPreferenceUpsertWithoutUserInput
    disconnect?: NutritionPreferenceWhereInput | boolean
    delete?: NutritionPreferenceWhereInput | boolean
    connect?: NutritionPreferenceWhereUniqueInput
    update?: XOR<XOR<NutritionPreferenceUpdateToOneWithWhereWithoutUserInput, NutritionPreferenceUpdateWithoutUserInput>, NutritionPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NutritionAccessUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NutritionAccessCreateWithoutUserInput, NutritionAccessUncheckedCreateWithoutUserInput>
    connectOrCreate?: NutritionAccessCreateOrConnectWithoutUserInput
    upsert?: NutritionAccessUpsertWithoutUserInput
    disconnect?: NutritionAccessWhereInput | boolean
    delete?: NutritionAccessWhereInput | boolean
    connect?: NutritionAccessWhereUniqueInput
    update?: XOR<XOR<NutritionAccessUpdateToOneWithWhereWithoutUserInput, NutritionAccessUpdateWithoutUserInput>, NutritionAccessUncheckedUpdateWithoutUserInput>
  }

  export type CoachMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoachMessageCreateWithoutUserInput, CoachMessageUncheckedCreateWithoutUserInput> | CoachMessageCreateWithoutUserInput[] | CoachMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachMessageCreateOrConnectWithoutUserInput | CoachMessageCreateOrConnectWithoutUserInput[]
    upsert?: CoachMessageUpsertWithWhereUniqueWithoutUserInput | CoachMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoachMessageCreateManyUserInputEnvelope
    set?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    disconnect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    delete?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    connect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    update?: CoachMessageUpdateWithWhereUniqueWithoutUserInput | CoachMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoachMessageUpdateManyWithWhereWithoutUserInput | CoachMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoachMessageScalarWhereInput | CoachMessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    connect?: UserWhereUniqueInput
  }

  export type CoachCreateNestedOneWithoutSessionsInput = {
    create?: XOR<CoachCreateWithoutSessionsInput, CoachUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutSessionsInput
    connect?: CoachWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionInput
    upsert?: UserUpsertWithoutSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionInput, UserUpdateWithoutSessionInput>, UserUncheckedUpdateWithoutSessionInput>
  }

  export type CoachUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<CoachCreateWithoutSessionsInput, CoachUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutSessionsInput
    upsert?: CoachUpsertWithoutSessionsInput
    disconnect?: CoachWhereInput | boolean
    delete?: CoachWhereInput | boolean
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutSessionsInput, CoachUpdateWithoutSessionsInput>, CoachUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutOrderInput = {
    create?: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CommissionCreateNestedManyWithoutOrderInput = {
    create?: XOR<CommissionCreateWithoutOrderInput, CommissionUncheckedCreateWithoutOrderInput> | CommissionCreateWithoutOrderInput[] | CommissionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutOrderInput | CommissionCreateOrConnectWithoutOrderInput[]
    createMany?: CommissionCreateManyOrderInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DeliveryCreateNestedOneWithoutOrderInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput
    connect?: DeliveryWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CommissionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<CommissionCreateWithoutOrderInput, CommissionUncheckedCreateWithoutOrderInput> | CommissionCreateWithoutOrderInput[] | CommissionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutOrderInput | CommissionCreateOrConnectWithoutOrderInput[]
    createMany?: CommissionCreateManyOrderInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput
    connect?: DeliveryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderInput
    upsert?: UserUpsertWithoutOrderInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrderInput, UserUpdateWithoutOrderInput>, UserUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CommissionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<CommissionCreateWithoutOrderInput, CommissionUncheckedCreateWithoutOrderInput> | CommissionCreateWithoutOrderInput[] | CommissionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutOrderInput | CommissionCreateOrConnectWithoutOrderInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutOrderInput | CommissionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: CommissionCreateManyOrderInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutOrderInput | CommissionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutOrderInput | CommissionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DeliveryUpdateOneWithoutOrderNestedInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput
    upsert?: DeliveryUpsertWithoutOrderInput
    disconnect?: DeliveryWhereInput | boolean
    delete?: DeliveryWhereInput | boolean
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutOrderInput, DeliveryUpdateWithoutOrderInput>, DeliveryUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CommissionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<CommissionCreateWithoutOrderInput, CommissionUncheckedCreateWithoutOrderInput> | CommissionCreateWithoutOrderInput[] | CommissionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutOrderInput | CommissionCreateOrConnectWithoutOrderInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutOrderInput | CommissionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: CommissionCreateManyOrderInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutOrderInput | CommissionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutOrderInput | CommissionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput
    upsert?: DeliveryUpsertWithoutOrderInput
    disconnect?: DeliveryWhereInput | boolean
    delete?: DeliveryWhereInput | boolean
    connect?: DeliveryWhereUniqueInput
    update?: XOR<XOR<DeliveryUpdateToOneWithWhereWithoutOrderInput, DeliveryUpdateWithoutOrderInput>, DeliveryUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type CoachCreatespecializationsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCoachInput = {
    create?: XOR<UserCreateWithoutCoachInput, UserUncheckedCreateWithoutCoachInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCoachClientsInput = {
    create?: XOR<UserCreateWithoutCoachClientsInput, UserUncheckedCreateWithoutCoachClientsInput> | UserCreateWithoutCoachClientsInput[] | UserUncheckedCreateWithoutCoachClientsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCoachClientsInput | UserCreateOrConnectWithoutCoachClientsInput[]
    createMany?: UserCreateManyCoachClientsInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CommissionCreateNestedManyWithoutCoachInput = {
    create?: XOR<CommissionCreateWithoutCoachInput, CommissionUncheckedCreateWithoutCoachInput> | CommissionCreateWithoutCoachInput[] | CommissionUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutCoachInput | CommissionCreateOrConnectWithoutCoachInput[]
    createMany?: CommissionCreateManyCoachInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type RecommendationCreateNestedManyWithoutCoachInput = {
    create?: XOR<RecommendationCreateWithoutCoachInput, RecommendationUncheckedCreateWithoutCoachInput> | RecommendationCreateWithoutCoachInput[] | RecommendationUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutCoachInput | RecommendationCreateOrConnectWithoutCoachInput[]
    createMany?: RecommendationCreateManyCoachInputEnvelope
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutCoachInput = {
    create?: XOR<SessionCreateWithoutCoachInput, SessionUncheckedCreateWithoutCoachInput> | SessionCreateWithoutCoachInput[] | SessionUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCoachInput | SessionCreateOrConnectWithoutCoachInput[]
    createMany?: SessionCreateManyCoachInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CoachMessageCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachMessageCreateWithoutCoachInput, CoachMessageUncheckedCreateWithoutCoachInput> | CoachMessageCreateWithoutCoachInput[] | CoachMessageUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachMessageCreateOrConnectWithoutCoachInput | CoachMessageCreateOrConnectWithoutCoachInput[]
    createMany?: CoachMessageCreateManyCoachInputEnvelope
    connect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
  }

  export type CoachCertificateCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachCertificateCreateWithoutCoachInput, CoachCertificateUncheckedCreateWithoutCoachInput> | CoachCertificateCreateWithoutCoachInput[] | CoachCertificateUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachCertificateCreateOrConnectWithoutCoachInput | CoachCertificateCreateOrConnectWithoutCoachInput[]
    createMany?: CoachCertificateCreateManyCoachInputEnvelope
    connect?: CoachCertificateWhereUniqueInput | CoachCertificateWhereUniqueInput[]
  }

  export type CoachExperienceCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachExperienceCreateWithoutCoachInput, CoachExperienceUncheckedCreateWithoutCoachInput> | CoachExperienceCreateWithoutCoachInput[] | CoachExperienceUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachExperienceCreateOrConnectWithoutCoachInput | CoachExperienceCreateOrConnectWithoutCoachInput[]
    createMany?: CoachExperienceCreateManyCoachInputEnvelope
    connect?: CoachExperienceWhereUniqueInput | CoachExperienceWhereUniqueInput[]
  }

  export type CoachAchievementCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachAchievementCreateWithoutCoachInput, CoachAchievementUncheckedCreateWithoutCoachInput> | CoachAchievementCreateWithoutCoachInput[] | CoachAchievementUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachAchievementCreateOrConnectWithoutCoachInput | CoachAchievementCreateOrConnectWithoutCoachInput[]
    createMany?: CoachAchievementCreateManyCoachInputEnvelope
    connect?: CoachAchievementWhereUniqueInput | CoachAchievementWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCoachClientsInput = {
    create?: XOR<UserCreateWithoutCoachClientsInput, UserUncheckedCreateWithoutCoachClientsInput> | UserCreateWithoutCoachClientsInput[] | UserUncheckedCreateWithoutCoachClientsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCoachClientsInput | UserCreateOrConnectWithoutCoachClientsInput[]
    createMany?: UserCreateManyCoachClientsInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CommissionUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<CommissionCreateWithoutCoachInput, CommissionUncheckedCreateWithoutCoachInput> | CommissionCreateWithoutCoachInput[] | CommissionUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutCoachInput | CommissionCreateOrConnectWithoutCoachInput[]
    createMany?: CommissionCreateManyCoachInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type RecommendationUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<RecommendationCreateWithoutCoachInput, RecommendationUncheckedCreateWithoutCoachInput> | RecommendationCreateWithoutCoachInput[] | RecommendationUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutCoachInput | RecommendationCreateOrConnectWithoutCoachInput[]
    createMany?: RecommendationCreateManyCoachInputEnvelope
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<SessionCreateWithoutCoachInput, SessionUncheckedCreateWithoutCoachInput> | SessionCreateWithoutCoachInput[] | SessionUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCoachInput | SessionCreateOrConnectWithoutCoachInput[]
    createMany?: SessionCreateManyCoachInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CoachMessageUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachMessageCreateWithoutCoachInput, CoachMessageUncheckedCreateWithoutCoachInput> | CoachMessageCreateWithoutCoachInput[] | CoachMessageUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachMessageCreateOrConnectWithoutCoachInput | CoachMessageCreateOrConnectWithoutCoachInput[]
    createMany?: CoachMessageCreateManyCoachInputEnvelope
    connect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
  }

  export type CoachCertificateUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachCertificateCreateWithoutCoachInput, CoachCertificateUncheckedCreateWithoutCoachInput> | CoachCertificateCreateWithoutCoachInput[] | CoachCertificateUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachCertificateCreateOrConnectWithoutCoachInput | CoachCertificateCreateOrConnectWithoutCoachInput[]
    createMany?: CoachCertificateCreateManyCoachInputEnvelope
    connect?: CoachCertificateWhereUniqueInput | CoachCertificateWhereUniqueInput[]
  }

  export type CoachExperienceUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachExperienceCreateWithoutCoachInput, CoachExperienceUncheckedCreateWithoutCoachInput> | CoachExperienceCreateWithoutCoachInput[] | CoachExperienceUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachExperienceCreateOrConnectWithoutCoachInput | CoachExperienceCreateOrConnectWithoutCoachInput[]
    createMany?: CoachExperienceCreateManyCoachInputEnvelope
    connect?: CoachExperienceWhereUniqueInput | CoachExperienceWhereUniqueInput[]
  }

  export type CoachAchievementUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachAchievementCreateWithoutCoachInput, CoachAchievementUncheckedCreateWithoutCoachInput> | CoachAchievementCreateWithoutCoachInput[] | CoachAchievementUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachAchievementCreateOrConnectWithoutCoachInput | CoachAchievementCreateOrConnectWithoutCoachInput[]
    createMany?: CoachAchievementCreateManyCoachInputEnvelope
    connect?: CoachAchievementWhereUniqueInput | CoachAchievementWhereUniqueInput[]
  }

  export type CoachUpdatespecializationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutCoachNestedInput = {
    create?: XOR<UserCreateWithoutCoachInput, UserUncheckedCreateWithoutCoachInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachInput
    upsert?: UserUpsertWithoutCoachInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoachInput, UserUpdateWithoutCoachInput>, UserUncheckedUpdateWithoutCoachInput>
  }

  export type UserUpdateManyWithoutCoachClientsNestedInput = {
    create?: XOR<UserCreateWithoutCoachClientsInput, UserUncheckedCreateWithoutCoachClientsInput> | UserCreateWithoutCoachClientsInput[] | UserUncheckedCreateWithoutCoachClientsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCoachClientsInput | UserCreateOrConnectWithoutCoachClientsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCoachClientsInput | UserUpsertWithWhereUniqueWithoutCoachClientsInput[]
    createMany?: UserCreateManyCoachClientsInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCoachClientsInput | UserUpdateWithWhereUniqueWithoutCoachClientsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCoachClientsInput | UserUpdateManyWithWhereWithoutCoachClientsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CommissionUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CommissionCreateWithoutCoachInput, CommissionUncheckedCreateWithoutCoachInput> | CommissionCreateWithoutCoachInput[] | CommissionUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutCoachInput | CommissionCreateOrConnectWithoutCoachInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutCoachInput | CommissionUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CommissionCreateManyCoachInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutCoachInput | CommissionUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutCoachInput | CommissionUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type RecommendationUpdateManyWithoutCoachNestedInput = {
    create?: XOR<RecommendationCreateWithoutCoachInput, RecommendationUncheckedCreateWithoutCoachInput> | RecommendationCreateWithoutCoachInput[] | RecommendationUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutCoachInput | RecommendationCreateOrConnectWithoutCoachInput[]
    upsert?: RecommendationUpsertWithWhereUniqueWithoutCoachInput | RecommendationUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: RecommendationCreateManyCoachInputEnvelope
    set?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    disconnect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    delete?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    update?: RecommendationUpdateWithWhereUniqueWithoutCoachInput | RecommendationUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: RecommendationUpdateManyWithWhereWithoutCoachInput | RecommendationUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutCoachNestedInput = {
    create?: XOR<SessionCreateWithoutCoachInput, SessionUncheckedCreateWithoutCoachInput> | SessionCreateWithoutCoachInput[] | SessionUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCoachInput | SessionCreateOrConnectWithoutCoachInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutCoachInput | SessionUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: SessionCreateManyCoachInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutCoachInput | SessionUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutCoachInput | SessionUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CoachMessageUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachMessageCreateWithoutCoachInput, CoachMessageUncheckedCreateWithoutCoachInput> | CoachMessageCreateWithoutCoachInput[] | CoachMessageUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachMessageCreateOrConnectWithoutCoachInput | CoachMessageCreateOrConnectWithoutCoachInput[]
    upsert?: CoachMessageUpsertWithWhereUniqueWithoutCoachInput | CoachMessageUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachMessageCreateManyCoachInputEnvelope
    set?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    disconnect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    delete?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    connect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    update?: CoachMessageUpdateWithWhereUniqueWithoutCoachInput | CoachMessageUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachMessageUpdateManyWithWhereWithoutCoachInput | CoachMessageUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachMessageScalarWhereInput | CoachMessageScalarWhereInput[]
  }

  export type CoachCertificateUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachCertificateCreateWithoutCoachInput, CoachCertificateUncheckedCreateWithoutCoachInput> | CoachCertificateCreateWithoutCoachInput[] | CoachCertificateUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachCertificateCreateOrConnectWithoutCoachInput | CoachCertificateCreateOrConnectWithoutCoachInput[]
    upsert?: CoachCertificateUpsertWithWhereUniqueWithoutCoachInput | CoachCertificateUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachCertificateCreateManyCoachInputEnvelope
    set?: CoachCertificateWhereUniqueInput | CoachCertificateWhereUniqueInput[]
    disconnect?: CoachCertificateWhereUniqueInput | CoachCertificateWhereUniqueInput[]
    delete?: CoachCertificateWhereUniqueInput | CoachCertificateWhereUniqueInput[]
    connect?: CoachCertificateWhereUniqueInput | CoachCertificateWhereUniqueInput[]
    update?: CoachCertificateUpdateWithWhereUniqueWithoutCoachInput | CoachCertificateUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachCertificateUpdateManyWithWhereWithoutCoachInput | CoachCertificateUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachCertificateScalarWhereInput | CoachCertificateScalarWhereInput[]
  }

  export type CoachExperienceUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachExperienceCreateWithoutCoachInput, CoachExperienceUncheckedCreateWithoutCoachInput> | CoachExperienceCreateWithoutCoachInput[] | CoachExperienceUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachExperienceCreateOrConnectWithoutCoachInput | CoachExperienceCreateOrConnectWithoutCoachInput[]
    upsert?: CoachExperienceUpsertWithWhereUniqueWithoutCoachInput | CoachExperienceUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachExperienceCreateManyCoachInputEnvelope
    set?: CoachExperienceWhereUniqueInput | CoachExperienceWhereUniqueInput[]
    disconnect?: CoachExperienceWhereUniqueInput | CoachExperienceWhereUniqueInput[]
    delete?: CoachExperienceWhereUniqueInput | CoachExperienceWhereUniqueInput[]
    connect?: CoachExperienceWhereUniqueInput | CoachExperienceWhereUniqueInput[]
    update?: CoachExperienceUpdateWithWhereUniqueWithoutCoachInput | CoachExperienceUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachExperienceUpdateManyWithWhereWithoutCoachInput | CoachExperienceUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachExperienceScalarWhereInput | CoachExperienceScalarWhereInput[]
  }

  export type CoachAchievementUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachAchievementCreateWithoutCoachInput, CoachAchievementUncheckedCreateWithoutCoachInput> | CoachAchievementCreateWithoutCoachInput[] | CoachAchievementUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachAchievementCreateOrConnectWithoutCoachInput | CoachAchievementCreateOrConnectWithoutCoachInput[]
    upsert?: CoachAchievementUpsertWithWhereUniqueWithoutCoachInput | CoachAchievementUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachAchievementCreateManyCoachInputEnvelope
    set?: CoachAchievementWhereUniqueInput | CoachAchievementWhereUniqueInput[]
    disconnect?: CoachAchievementWhereUniqueInput | CoachAchievementWhereUniqueInput[]
    delete?: CoachAchievementWhereUniqueInput | CoachAchievementWhereUniqueInput[]
    connect?: CoachAchievementWhereUniqueInput | CoachAchievementWhereUniqueInput[]
    update?: CoachAchievementUpdateWithWhereUniqueWithoutCoachInput | CoachAchievementUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachAchievementUpdateManyWithWhereWithoutCoachInput | CoachAchievementUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachAchievementScalarWhereInput | CoachAchievementScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCoachClientsNestedInput = {
    create?: XOR<UserCreateWithoutCoachClientsInput, UserUncheckedCreateWithoutCoachClientsInput> | UserCreateWithoutCoachClientsInput[] | UserUncheckedCreateWithoutCoachClientsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCoachClientsInput | UserCreateOrConnectWithoutCoachClientsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCoachClientsInput | UserUpsertWithWhereUniqueWithoutCoachClientsInput[]
    createMany?: UserCreateManyCoachClientsInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCoachClientsInput | UserUpdateWithWhereUniqueWithoutCoachClientsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCoachClientsInput | UserUpdateManyWithWhereWithoutCoachClientsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CommissionUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CommissionCreateWithoutCoachInput, CommissionUncheckedCreateWithoutCoachInput> | CommissionCreateWithoutCoachInput[] | CommissionUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutCoachInput | CommissionCreateOrConnectWithoutCoachInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutCoachInput | CommissionUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CommissionCreateManyCoachInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutCoachInput | CommissionUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutCoachInput | CommissionUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type RecommendationUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<RecommendationCreateWithoutCoachInput, RecommendationUncheckedCreateWithoutCoachInput> | RecommendationCreateWithoutCoachInput[] | RecommendationUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: RecommendationCreateOrConnectWithoutCoachInput | RecommendationCreateOrConnectWithoutCoachInput[]
    upsert?: RecommendationUpsertWithWhereUniqueWithoutCoachInput | RecommendationUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: RecommendationCreateManyCoachInputEnvelope
    set?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    disconnect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    delete?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    connect?: RecommendationWhereUniqueInput | RecommendationWhereUniqueInput[]
    update?: RecommendationUpdateWithWhereUniqueWithoutCoachInput | RecommendationUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: RecommendationUpdateManyWithWhereWithoutCoachInput | RecommendationUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<SessionCreateWithoutCoachInput, SessionUncheckedCreateWithoutCoachInput> | SessionCreateWithoutCoachInput[] | SessionUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCoachInput | SessionCreateOrConnectWithoutCoachInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutCoachInput | SessionUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: SessionCreateManyCoachInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutCoachInput | SessionUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutCoachInput | SessionUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CoachMessageUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachMessageCreateWithoutCoachInput, CoachMessageUncheckedCreateWithoutCoachInput> | CoachMessageCreateWithoutCoachInput[] | CoachMessageUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachMessageCreateOrConnectWithoutCoachInput | CoachMessageCreateOrConnectWithoutCoachInput[]
    upsert?: CoachMessageUpsertWithWhereUniqueWithoutCoachInput | CoachMessageUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachMessageCreateManyCoachInputEnvelope
    set?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    disconnect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    delete?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    connect?: CoachMessageWhereUniqueInput | CoachMessageWhereUniqueInput[]
    update?: CoachMessageUpdateWithWhereUniqueWithoutCoachInput | CoachMessageUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachMessageUpdateManyWithWhereWithoutCoachInput | CoachMessageUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachMessageScalarWhereInput | CoachMessageScalarWhereInput[]
  }

  export type CoachCertificateUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachCertificateCreateWithoutCoachInput, CoachCertificateUncheckedCreateWithoutCoachInput> | CoachCertificateCreateWithoutCoachInput[] | CoachCertificateUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachCertificateCreateOrConnectWithoutCoachInput | CoachCertificateCreateOrConnectWithoutCoachInput[]
    upsert?: CoachCertificateUpsertWithWhereUniqueWithoutCoachInput | CoachCertificateUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachCertificateCreateManyCoachInputEnvelope
    set?: CoachCertificateWhereUniqueInput | CoachCertificateWhereUniqueInput[]
    disconnect?: CoachCertificateWhereUniqueInput | CoachCertificateWhereUniqueInput[]
    delete?: CoachCertificateWhereUniqueInput | CoachCertificateWhereUniqueInput[]
    connect?: CoachCertificateWhereUniqueInput | CoachCertificateWhereUniqueInput[]
    update?: CoachCertificateUpdateWithWhereUniqueWithoutCoachInput | CoachCertificateUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachCertificateUpdateManyWithWhereWithoutCoachInput | CoachCertificateUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachCertificateScalarWhereInput | CoachCertificateScalarWhereInput[]
  }

  export type CoachExperienceUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachExperienceCreateWithoutCoachInput, CoachExperienceUncheckedCreateWithoutCoachInput> | CoachExperienceCreateWithoutCoachInput[] | CoachExperienceUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachExperienceCreateOrConnectWithoutCoachInput | CoachExperienceCreateOrConnectWithoutCoachInput[]
    upsert?: CoachExperienceUpsertWithWhereUniqueWithoutCoachInput | CoachExperienceUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachExperienceCreateManyCoachInputEnvelope
    set?: CoachExperienceWhereUniqueInput | CoachExperienceWhereUniqueInput[]
    disconnect?: CoachExperienceWhereUniqueInput | CoachExperienceWhereUniqueInput[]
    delete?: CoachExperienceWhereUniqueInput | CoachExperienceWhereUniqueInput[]
    connect?: CoachExperienceWhereUniqueInput | CoachExperienceWhereUniqueInput[]
    update?: CoachExperienceUpdateWithWhereUniqueWithoutCoachInput | CoachExperienceUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachExperienceUpdateManyWithWhereWithoutCoachInput | CoachExperienceUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachExperienceScalarWhereInput | CoachExperienceScalarWhereInput[]
  }

  export type CoachAchievementUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachAchievementCreateWithoutCoachInput, CoachAchievementUncheckedCreateWithoutCoachInput> | CoachAchievementCreateWithoutCoachInput[] | CoachAchievementUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachAchievementCreateOrConnectWithoutCoachInput | CoachAchievementCreateOrConnectWithoutCoachInput[]
    upsert?: CoachAchievementUpsertWithWhereUniqueWithoutCoachInput | CoachAchievementUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachAchievementCreateManyCoachInputEnvelope
    set?: CoachAchievementWhereUniqueInput | CoachAchievementWhereUniqueInput[]
    disconnect?: CoachAchievementWhereUniqueInput | CoachAchievementWhereUniqueInput[]
    delete?: CoachAchievementWhereUniqueInput | CoachAchievementWhereUniqueInput[]
    connect?: CoachAchievementWhereUniqueInput | CoachAchievementWhereUniqueInput[]
    update?: CoachAchievementUpdateWithWhereUniqueWithoutCoachInput | CoachAchievementUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachAchievementUpdateManyWithWhereWithoutCoachInput | CoachAchievementUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachAchievementScalarWhereInput | CoachAchievementScalarWhereInput[]
  }

  export type CoachCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<CoachCreateWithoutCertificatesInput, CoachUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CoachCreateOrConnectWithoutCertificatesInput
    connect?: CoachWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CoachUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<CoachCreateWithoutCertificatesInput, CoachUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CoachCreateOrConnectWithoutCertificatesInput
    upsert?: CoachUpsertWithoutCertificatesInput
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutCertificatesInput, CoachUpdateWithoutCertificatesInput>, CoachUncheckedUpdateWithoutCertificatesInput>
  }

  export type CoachCreateNestedOneWithoutExperiencesInput = {
    create?: XOR<CoachCreateWithoutExperiencesInput, CoachUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: CoachCreateOrConnectWithoutExperiencesInput
    connect?: CoachWhereUniqueInput
  }

  export type CoachUpdateOneRequiredWithoutExperiencesNestedInput = {
    create?: XOR<CoachCreateWithoutExperiencesInput, CoachUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: CoachCreateOrConnectWithoutExperiencesInput
    upsert?: CoachUpsertWithoutExperiencesInput
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutExperiencesInput, CoachUpdateWithoutExperiencesInput>, CoachUncheckedUpdateWithoutExperiencesInput>
  }

  export type CoachCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<CoachCreateWithoutAchievementsInput, CoachUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutAchievementsInput
    connect?: CoachWhereUniqueInput
  }

  export type CoachUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<CoachCreateWithoutAchievementsInput, CoachUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutAchievementsInput
    upsert?: CoachUpsertWithoutAchievementsInput
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutAchievementsInput, CoachUpdateWithoutAchievementsInput>, CoachUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserCreateNestedOneWithoutWorkoutLogInput = {
    create?: XOR<UserCreateWithoutWorkoutLogInput, UserUncheckedCreateWithoutWorkoutLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWorkoutLogNestedInput = {
    create?: XOR<UserCreateWithoutWorkoutLogInput, UserUncheckedCreateWithoutWorkoutLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutLogInput
    upsert?: UserUpsertWithoutWorkoutLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkoutLogInput, UserUpdateWithoutWorkoutLogInput>, UserUncheckedUpdateWithoutWorkoutLogInput>
  }

  export type UserCreateNestedOneWithoutNutritionLogInput = {
    create?: XOR<UserCreateWithoutNutritionLogInput, UserUncheckedCreateWithoutNutritionLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutNutritionLogInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutNutritionLogNestedInput = {
    create?: XOR<UserCreateWithoutNutritionLogInput, UserUncheckedCreateWithoutNutritionLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutNutritionLogInput
    upsert?: UserUpsertWithoutNutritionLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNutritionLogInput, UserUpdateWithoutNutritionLogInput>, UserUncheckedUpdateWithoutNutritionLogInput>
  }

  export type UserCreateNestedOneWithoutSupplementLogInput = {
    create?: XOR<UserCreateWithoutSupplementLogInput, UserUncheckedCreateWithoutSupplementLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupplementLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSupplementLogNestedInput = {
    create?: XOR<UserCreateWithoutSupplementLogInput, UserUncheckedCreateWithoutSupplementLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupplementLogInput
    upsert?: UserUpsertWithoutSupplementLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupplementLogInput, UserUpdateWithoutSupplementLogInput>, UserUncheckedUpdateWithoutSupplementLogInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRecommendationsInput = {
    create?: XOR<UserCreateWithoutRecommendationsInput, UserUncheckedCreateWithoutRecommendationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecommendationsInput
    connect?: UserWhereUniqueInput
  }

  export type CoachCreateNestedOneWithoutRecommendationsInput = {
    create?: XOR<CoachCreateWithoutRecommendationsInput, CoachUncheckedCreateWithoutRecommendationsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutRecommendationsInput
    connect?: CoachWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRecommendationsNestedInput = {
    create?: XOR<UserCreateWithoutRecommendationsInput, UserUncheckedCreateWithoutRecommendationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecommendationsInput
    upsert?: UserUpsertWithoutRecommendationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecommendationsInput, UserUpdateWithoutRecommendationsInput>, UserUncheckedUpdateWithoutRecommendationsInput>
  }

  export type CoachUpdateOneWithoutRecommendationsNestedInput = {
    create?: XOR<CoachCreateWithoutRecommendationsInput, CoachUncheckedCreateWithoutRecommendationsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutRecommendationsInput
    upsert?: CoachUpsertWithoutRecommendationsInput
    disconnect?: CoachWhereInput | boolean
    delete?: CoachWhereInput | boolean
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutRecommendationsInput, CoachUpdateWithoutRecommendationsInput>, CoachUncheckedUpdateWithoutRecommendationsInput>
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutBundlesInput = {
    create?: XOR<ProductCreateWithoutBundlesInput, ProductUncheckedCreateWithoutBundlesInput> | ProductCreateWithoutBundlesInput[] | ProductUncheckedCreateWithoutBundlesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBundlesInput | ProductCreateOrConnectWithoutBundlesInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBundlesInput = {
    create?: XOR<ProductCreateWithoutBundlesInput, ProductUncheckedCreateWithoutBundlesInput> | ProductCreateWithoutBundlesInput[] | ProductUncheckedCreateWithoutBundlesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBundlesInput | ProductCreateOrConnectWithoutBundlesInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateManyWithoutBundlesNestedInput = {
    create?: XOR<ProductCreateWithoutBundlesInput, ProductUncheckedCreateWithoutBundlesInput> | ProductCreateWithoutBundlesInput[] | ProductUncheckedCreateWithoutBundlesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBundlesInput | ProductCreateOrConnectWithoutBundlesInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBundlesInput | ProductUpsertWithWhereUniqueWithoutBundlesInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBundlesInput | ProductUpdateWithWhereUniqueWithoutBundlesInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBundlesInput | ProductUpdateManyWithWhereWithoutBundlesInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBundlesNestedInput = {
    create?: XOR<ProductCreateWithoutBundlesInput, ProductUncheckedCreateWithoutBundlesInput> | ProductCreateWithoutBundlesInput[] | ProductUncheckedCreateWithoutBundlesInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBundlesInput | ProductCreateOrConnectWithoutBundlesInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBundlesInput | ProductUpsertWithWhereUniqueWithoutBundlesInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBundlesInput | ProductUpdateWithWhereUniqueWithoutBundlesInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBundlesInput | ProductUpdateManyWithWhereWithoutBundlesInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type BundleCreateNestedManyWithoutProductsInput = {
    create?: XOR<BundleCreateWithoutProductsInput, BundleUncheckedCreateWithoutProductsInput> | BundleCreateWithoutProductsInput[] | BundleUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: BundleCreateOrConnectWithoutProductsInput | BundleCreateOrConnectWithoutProductsInput[]
    connect?: BundleWhereUniqueInput | BundleWhereUniqueInput[]
  }

  export type BundleUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<BundleCreateWithoutProductsInput, BundleUncheckedCreateWithoutProductsInput> | BundleCreateWithoutProductsInput[] | BundleUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: BundleCreateOrConnectWithoutProductsInput | BundleCreateOrConnectWithoutProductsInput[]
    connect?: BundleWhereUniqueInput | BundleWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type BundleUpdateManyWithoutProductsNestedInput = {
    create?: XOR<BundleCreateWithoutProductsInput, BundleUncheckedCreateWithoutProductsInput> | BundleCreateWithoutProductsInput[] | BundleUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: BundleCreateOrConnectWithoutProductsInput | BundleCreateOrConnectWithoutProductsInput[]
    upsert?: BundleUpsertWithWhereUniqueWithoutProductsInput | BundleUpsertWithWhereUniqueWithoutProductsInput[]
    set?: BundleWhereUniqueInput | BundleWhereUniqueInput[]
    disconnect?: BundleWhereUniqueInput | BundleWhereUniqueInput[]
    delete?: BundleWhereUniqueInput | BundleWhereUniqueInput[]
    connect?: BundleWhereUniqueInput | BundleWhereUniqueInput[]
    update?: BundleUpdateWithWhereUniqueWithoutProductsInput | BundleUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: BundleUpdateManyWithWhereWithoutProductsInput | BundleUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: BundleScalarWhereInput | BundleScalarWhereInput[]
  }

  export type BundleUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<BundleCreateWithoutProductsInput, BundleUncheckedCreateWithoutProductsInput> | BundleCreateWithoutProductsInput[] | BundleUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: BundleCreateOrConnectWithoutProductsInput | BundleCreateOrConnectWithoutProductsInput[]
    upsert?: BundleUpsertWithWhereUniqueWithoutProductsInput | BundleUpsertWithWhereUniqueWithoutProductsInput[]
    set?: BundleWhereUniqueInput | BundleWhereUniqueInput[]
    disconnect?: BundleWhereUniqueInput | BundleWhereUniqueInput[]
    delete?: BundleWhereUniqueInput | BundleWhereUniqueInput[]
    connect?: BundleWhereUniqueInput | BundleWhereUniqueInput[]
    update?: BundleUpdateWithWhereUniqueWithoutProductsInput | BundleUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: BundleUpdateManyWithWhereWithoutProductsInput | BundleUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: BundleScalarWhereInput | BundleScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutDeliveryInput = {
    create?: XOR<OrderCreateWithoutDeliveryInput, OrderUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutDeliveryNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryInput, OrderUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryInput
    upsert?: OrderUpsertWithoutDeliveryInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutDeliveryInput, OrderUpdateWithoutDeliveryInput>, OrderUncheckedUpdateWithoutDeliveryInput>
  }

  export type CommissionCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput> | CommissionCreateWithoutAffiliateInput[] | CommissionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutAffiliateInput | CommissionCreateOrConnectWithoutAffiliateInput[]
    createMany?: CommissionCreateManyAffiliateInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type CommissionUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput> | CommissionCreateWithoutAffiliateInput[] | CommissionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutAffiliateInput | CommissionCreateOrConnectWithoutAffiliateInput[]
    createMany?: CommissionCreateManyAffiliateInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type CommissionUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput> | CommissionCreateWithoutAffiliateInput[] | CommissionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutAffiliateInput | CommissionCreateOrConnectWithoutAffiliateInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutAffiliateInput | CommissionUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: CommissionCreateManyAffiliateInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutAffiliateInput | CommissionUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutAffiliateInput | CommissionUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type CommissionUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput> | CommissionCreateWithoutAffiliateInput[] | CommissionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutAffiliateInput | CommissionCreateOrConnectWithoutAffiliateInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutAffiliateInput | CommissionUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: CommissionCreateManyAffiliateInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutAffiliateInput | CommissionUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutAffiliateInput | CommissionUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type CoachCreateNestedOneWithoutMessagesInput = {
    create?: XOR<CoachCreateWithoutMessagesInput, CoachUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CoachCreateOrConnectWithoutMessagesInput
    connect?: CoachWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCoachMessagesInput = {
    create?: XOR<UserCreateWithoutCoachMessagesInput, UserUncheckedCreateWithoutCoachMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type CoachUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<CoachCreateWithoutMessagesInput, CoachUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: CoachCreateOrConnectWithoutMessagesInput
    upsert?: CoachUpsertWithoutMessagesInput
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutMessagesInput, CoachUpdateWithoutMessagesInput>, CoachUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutCoachMessagesNestedInput = {
    create?: XOR<UserCreateWithoutCoachMessagesInput, UserUncheckedCreateWithoutCoachMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachMessagesInput
    upsert?: UserUpsertWithoutCoachMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoachMessagesInput, UserUpdateWithoutCoachMessagesInput>, UserUncheckedUpdateWithoutCoachMessagesInput>
  }

  export type CoachCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<CoachCreateWithoutCommissionsInput, CoachUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutCommissionsInput
    connect?: CoachWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<OrderCreateWithoutCommissionsInput, OrderUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCommissionsInput
    connect?: OrderWhereUniqueInput
  }

  export type AffiliateCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<AffiliateCreateWithoutCommissionsInput, AffiliateUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: AffiliateCreateOrConnectWithoutCommissionsInput
    connect?: AffiliateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommissionsInput
    connect?: UserWhereUniqueInput
  }

  export type CoachUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<CoachCreateWithoutCommissionsInput, CoachUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: CoachCreateOrConnectWithoutCommissionsInput
    upsert?: CoachUpsertWithoutCommissionsInput
    connect?: CoachWhereUniqueInput
    update?: XOR<XOR<CoachUpdateToOneWithWhereWithoutCommissionsInput, CoachUpdateWithoutCommissionsInput>, CoachUncheckedUpdateWithoutCommissionsInput>
  }

  export type OrderUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<OrderCreateWithoutCommissionsInput, OrderUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCommissionsInput
    upsert?: OrderUpsertWithoutCommissionsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutCommissionsInput, OrderUpdateWithoutCommissionsInput>, OrderUncheckedUpdateWithoutCommissionsInput>
  }

  export type AffiliateUpdateOneWithoutCommissionsNestedInput = {
    create?: XOR<AffiliateCreateWithoutCommissionsInput, AffiliateUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: AffiliateCreateOrConnectWithoutCommissionsInput
    upsert?: AffiliateUpsertWithoutCommissionsInput
    disconnect?: AffiliateWhereInput | boolean
    delete?: AffiliateWhereInput | boolean
    connect?: AffiliateWhereUniqueInput
    update?: XOR<XOR<AffiliateUpdateToOneWithWhereWithoutCommissionsInput, AffiliateUpdateWithoutCommissionsInput>, AffiliateUncheckedUpdateWithoutCommissionsInput>
  }

  export type UserUpdateOneWithoutCommissionsNestedInput = {
    create?: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommissionsInput
    upsert?: UserUpsertWithoutCommissionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommissionsInput, UserUpdateWithoutCommissionsInput>, UserUncheckedUpdateWithoutCommissionsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<UserCreateWithoutMilestonesInput, UserUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMilestonesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<UserCreateWithoutMilestonesInput, UserUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMilestonesInput
    upsert?: UserUpsertWithoutMilestonesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMilestonesInput, UserUpdateWithoutMilestonesInput>, UserUncheckedUpdateWithoutMilestonesInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    upsert?: SubscriptionUpsertWithoutPaymentsInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPaymentsInput, SubscriptionUpdateWithoutPaymentsInput>, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutCoachRequestsInput = {
    create?: XOR<UserCreateWithoutCoachRequestsInput, UserUncheckedCreateWithoutCoachRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCoachRequestsNestedInput = {
    create?: XOR<UserCreateWithoutCoachRequestsInput, UserUncheckedCreateWithoutCoachRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachRequestsInput
    upsert?: UserUpsertWithoutCoachRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoachRequestsInput, UserUpdateWithoutCoachRequestsInput>, UserUncheckedUpdateWithoutCoachRequestsInput>
  }

  export type UserIntakeCreateinjuriesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutIntakeInput = {
    create?: XOR<UserCreateWithoutIntakeInput, UserUncheckedCreateWithoutIntakeInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntakeInput
    connect?: UserWhereUniqueInput
  }

  export type UserIntakeUpdateinjuriesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutIntakeNestedInput = {
    create?: XOR<UserCreateWithoutIntakeInput, UserUncheckedCreateWithoutIntakeInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntakeInput
    upsert?: UserUpsertWithoutIntakeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIntakeInput, UserUpdateWithoutIntakeInput>, UserUncheckedUpdateWithoutIntakeInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionQuotaInput = {
    create?: XOR<UserCreateWithoutSubscriptionQuotaInput, UserUncheckedCreateWithoutSubscriptionQuotaInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionQuotaInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type UserUpdateOneRequiredWithoutSubscriptionQuotaNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionQuotaInput, UserUncheckedCreateWithoutSubscriptionQuotaInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionQuotaInput
    upsert?: UserUpsertWithoutSubscriptionQuotaInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionQuotaInput, UserUpdateWithoutSubscriptionQuotaInput>, UserUncheckedUpdateWithoutSubscriptionQuotaInput>
  }

  export type NutritionPreferenceCreateproteinSourcesInput = {
    set: string[]
  }

  export type NutritionPreferenceCreateproteinAllergiesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutNutritionPreferenceInput = {
    create?: XOR<UserCreateWithoutNutritionPreferenceInput, UserUncheckedCreateWithoutNutritionPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutNutritionPreferenceInput
    connect?: UserWhereUniqueInput
  }

  export type NutritionPreferenceUpdateproteinSourcesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NutritionPreferenceUpdateproteinAllergiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutNutritionPreferenceNestedInput = {
    create?: XOR<UserCreateWithoutNutritionPreferenceInput, UserUncheckedCreateWithoutNutritionPreferenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutNutritionPreferenceInput
    upsert?: UserUpsertWithoutNutritionPreferenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNutritionPreferenceInput, UserUpdateWithoutNutritionPreferenceInput>, UserUncheckedUpdateWithoutNutritionPreferenceInput>
  }

  export type UserCreateNestedOneWithoutNutritionAccessInput = {
    create?: XOR<UserCreateWithoutNutritionAccessInput, UserUncheckedCreateWithoutNutritionAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutNutritionAccessInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNutritionAccessNestedInput = {
    create?: XOR<UserCreateWithoutNutritionAccessInput, UserUncheckedCreateWithoutNutritionAccessInput>
    connectOrCreate?: UserCreateOrConnectWithoutNutritionAccessInput
    upsert?: UserUpsertWithoutNutritionAccessInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNutritionAccessInput, UserUpdateWithoutNutritionAccessInput>, UserUncheckedUpdateWithoutNutritionAccessInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type CoachCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    clients?: UserCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationCreateNestedManyWithoutCoachInput
    sessions?: SessionCreateNestedManyWithoutCoachInput
    messages?: CoachMessageCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    clients?: UserUncheckedCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutCoachInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCoachInput
    messages?: CoachMessageUncheckedCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateUncheckedCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceUncheckedCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutUserInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutUserInput, CoachUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MilestoneCreateWithoutUserInput = {
    id?: string
    type: string
    description?: string | null
    achievedAt?: Date | string | null
  }

  export type MilestoneUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    description?: string | null
    achievedAt?: Date | string | null
  }

  export type MilestoneCreateOrConnectWithoutUserInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutUserInput, MilestoneUncheckedCreateWithoutUserInput>
  }

  export type MilestoneCreateManyUserInputEnvelope = {
    data: MilestoneCreateManyUserInput | MilestoneCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutPaymentsInput
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    orderId?: string | null
    subscriptionId?: string | null
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RecommendationCreateWithoutUserInput = {
    id?: string
    type: string
    content: string
    createdAt?: Date | string
    coach?: CoachCreateNestedOneWithoutRecommendationsInput
  }

  export type RecommendationUncheckedCreateWithoutUserInput = {
    id?: string
    coachId?: string | null
    type: string
    content: string
    createdAt?: Date | string
  }

  export type RecommendationCreateOrConnectWithoutUserInput = {
    where: RecommendationWhereUniqueInput
    create: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput>
  }

  export type RecommendationCreateManyUserInputEnvelope = {
    data: RecommendationCreateManyUserInput | RecommendationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommissionCreateWithoutUserInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    coach: CoachCreateNestedOneWithoutCommissionsInput
    order: OrderCreateNestedOneWithoutCommissionsInput
    affiliate?: AffiliateCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionUncheckedCreateWithoutUserInput = {
    id?: string
    coachId: string
    orderId: string
    affiliateId?: string | null
    amount: number
    createdAt?: Date | string
  }

  export type CommissionCreateOrConnectWithoutUserInput = {
    where: CommissionWhereUniqueInput
    create: XOR<CommissionCreateWithoutUserInput, CommissionUncheckedCreateWithoutUserInput>
  }

  export type CommissionCreateManyUserInputEnvelope = {
    data: CommissionCreateManyUserInput | CommissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CoachCreateWithoutClientsInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    user: UserCreateNestedOneWithoutCoachInput
    commissions?: CommissionCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationCreateNestedManyWithoutCoachInput
    sessions?: SessionCreateNestedManyWithoutCoachInput
    messages?: CoachMessageCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutClientsInput = {
    id?: string
    userId: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    commissions?: CommissionUncheckedCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutCoachInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCoachInput
    messages?: CoachMessageUncheckedCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateUncheckedCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceUncheckedCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutClientsInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutClientsInput, CoachUncheckedCreateWithoutClientsInput>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    scheduledAt: Date | string
    durationMin?: number
    status?: string
    agoraChannel?: string | null
    rating?: number | null
    ratingNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coach?: CoachCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    coachId?: string | null
    scheduledAt: Date | string
    durationMin?: number
    status?: string
    agoraChannel?: string | null
    rating?: number | null
    ratingNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    commissions?: CommissionCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Delivery?: DeliveryCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutLogCreateWithoutUserInput = {
    id?: string
    date: Date | string
    activity: string
    duration: number
    notes?: string | null
  }

  export type WorkoutLogUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    activity: string
    duration: number
    notes?: string | null
  }

  export type WorkoutLogCreateOrConnectWithoutUserInput = {
    where: WorkoutLogWhereUniqueInput
    create: XOR<WorkoutLogCreateWithoutUserInput, WorkoutLogUncheckedCreateWithoutUserInput>
  }

  export type WorkoutLogCreateManyUserInputEnvelope = {
    data: WorkoutLogCreateManyUserInput | WorkoutLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NutritionLogCreateWithoutUserInput = {
    id?: string
    date: Date | string
    meal: string
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    mealType?: string | null
    notes?: string | null
  }

  export type NutritionLogUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    meal: string
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    mealType?: string | null
    notes?: string | null
  }

  export type NutritionLogCreateOrConnectWithoutUserInput = {
    where: NutritionLogWhereUniqueInput
    create: XOR<NutritionLogCreateWithoutUserInput, NutritionLogUncheckedCreateWithoutUserInput>
  }

  export type NutritionLogCreateManyUserInputEnvelope = {
    data: NutritionLogCreateManyUserInput | NutritionLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupplementLogCreateWithoutUserInput = {
    id?: string
    date: Date | string
    supplementName: string
    dose: string
    notes?: string | null
  }

  export type SupplementLogUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    supplementName: string
    dose: string
    notes?: string | null
  }

  export type SupplementLogCreateOrConnectWithoutUserInput = {
    where: SupplementLogWhereUniqueInput
    create: XOR<SupplementLogCreateWithoutUserInput, SupplementLogUncheckedCreateWithoutUserInput>
  }

  export type SupplementLogCreateManyUserInputEnvelope = {
    data: SupplementLogCreateManyUserInput | SupplementLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    stripeSubscriptionId?: string | null
    status?: string
    planCode?: string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    stripeSubscriptionId?: string | null
    status?: string
    planCode?: string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CoachRequestCreateWithoutUserInput = {
    id?: string
    status: string
    createdAt?: Date | string
  }

  export type CoachRequestUncheckedCreateWithoutUserInput = {
    id?: string
    status: string
    createdAt?: Date | string
  }

  export type CoachRequestCreateOrConnectWithoutUserInput = {
    where: CoachRequestWhereUniqueInput
    create: XOR<CoachRequestCreateWithoutUserInput, CoachRequestUncheckedCreateWithoutUserInput>
  }

  export type CoachRequestCreateManyUserInputEnvelope = {
    data: CoachRequestCreateManyUserInput | CoachRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserIntakeCreateWithoutUserInput = {
    id?: string
    gender?: string | null
    mainGoal?: string | null
    workoutLocation?: string | null
    firstCompletedAt?: Date | string | null
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    experienceLevel?: string | null
    workoutFrequency?: number | null
    injuries?: UserIntakeCreateinjuriesInput | string[]
    secondCompletedAt?: Date | string | null
    skippedSecond?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIntakeUncheckedCreateWithoutUserInput = {
    id?: string
    gender?: string | null
    mainGoal?: string | null
    workoutLocation?: string | null
    firstCompletedAt?: Date | string | null
    age?: number | null
    weightKg?: number | null
    heightCm?: number | null
    experienceLevel?: string | null
    workoutFrequency?: number | null
    injuries?: UserIntakeCreateinjuriesInput | string[]
    secondCompletedAt?: Date | string | null
    skippedSecond?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserIntakeCreateOrConnectWithoutUserInput = {
    where: UserIntakeWhereUniqueInput
    create: XOR<UserIntakeCreateWithoutUserInput, UserIntakeUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionQuotaCreateWithoutUserInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    messagesUsed?: number
    callsUsed?: number
    attachmentsUsed?: number
    resetAt?: Date | string
    nutritionWindowDays?: number | null
    nutritionExpiresAt?: Date | string | null
    nutritionLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionQuotaUncheckedCreateWithoutUserInput = {
    id?: string
    tier?: $Enums.SubscriptionTier
    messagesUsed?: number
    callsUsed?: number
    attachmentsUsed?: number
    resetAt?: Date | string
    nutritionWindowDays?: number | null
    nutritionExpiresAt?: Date | string | null
    nutritionLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionQuotaCreateOrConnectWithoutUserInput = {
    where: SubscriptionQuotaWhereUniqueInput
    create: XOR<SubscriptionQuotaCreateWithoutUserInput, SubscriptionQuotaUncheckedCreateWithoutUserInput>
  }

  export type NutritionPreferenceCreateWithoutUserInput = {
    id?: string
    proteinSources?: NutritionPreferenceCreateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceCreateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    proteinSources?: NutritionPreferenceCreateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceCreateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionPreferenceCreateOrConnectWithoutUserInput = {
    where: NutritionPreferenceWhereUniqueInput
    create: XOR<NutritionPreferenceCreateWithoutUserInput, NutritionPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NutritionAccessCreateWithoutUserInput = {
    id?: string
    planGeneratedAt: Date | string
    expiresAt?: Date | string | null
    locked?: boolean
    windowDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionAccessUncheckedCreateWithoutUserInput = {
    id?: string
    planGeneratedAt: Date | string
    expiresAt?: Date | string | null
    locked?: boolean
    windowDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NutritionAccessCreateOrConnectWithoutUserInput = {
    where: NutritionAccessWhereUniqueInput
    create: XOR<NutritionAccessCreateWithoutUserInput, NutritionAccessUncheckedCreateWithoutUserInput>
  }

  export type CoachMessageCreateWithoutUserInput = {
    id?: string
    sender: string
    body?: string | null
    attachmentUrl?: string | null
    attachmentName?: string | null
    attachmentType?: string | null
    attachmentSize?: number | null
    createdAt?: Date | string
    coach: CoachCreateNestedOneWithoutMessagesInput
  }

  export type CoachMessageUncheckedCreateWithoutUserInput = {
    id?: string
    coachId: string
    sender: string
    body?: string | null
    attachmentUrl?: string | null
    attachmentName?: string | null
    attachmentType?: string | null
    attachmentSize?: number | null
    createdAt?: Date | string
  }

  export type CoachMessageCreateOrConnectWithoutUserInput = {
    where: CoachMessageWhereUniqueInput
    create: XOR<CoachMessageCreateWithoutUserInput, CoachMessageUncheckedCreateWithoutUserInput>
  }

  export type CoachMessageCreateManyUserInputEnvelope = {
    data: CoachMessageCreateManyUserInput | CoachMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CoachUpsertWithoutUserInput = {
    update: XOR<CoachUpdateWithoutUserInput, CoachUncheckedUpdateWithoutUserInput>
    create: XOR<CoachCreateWithoutUserInput, CoachUncheckedCreateWithoutUserInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutUserInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutUserInput, CoachUncheckedUpdateWithoutUserInput>
  }

  export type CoachUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    clients?: UserUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUpdateManyWithoutCoachNestedInput
    sessions?: SessionUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    clients?: UserUncheckedUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutCoachNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUncheckedUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUncheckedUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUncheckedUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type MilestoneUpsertWithWhereUniqueWithoutUserInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutUserInput, MilestoneUncheckedUpdateWithoutUserInput>
    create: XOR<MilestoneCreateWithoutUserInput, MilestoneUncheckedCreateWithoutUserInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutUserInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutUserInput, MilestoneUncheckedUpdateWithoutUserInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutUserInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutUserInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    userId?: StringFilter<"Milestone"> | string
    type?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    achievedAt?: DateTimeNullableFilter<"Milestone"> | Date | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    orderId?: StringNullableFilter<"Payment"> | string | null
    subscriptionId?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatNullableFilter<"Payment"> | number | null
    amountCents?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    providerId?: StringNullableFilter<"Payment"> | string | null
    raw?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type RecommendationUpsertWithWhereUniqueWithoutUserInput = {
    where: RecommendationWhereUniqueInput
    update: XOR<RecommendationUpdateWithoutUserInput, RecommendationUncheckedUpdateWithoutUserInput>
    create: XOR<RecommendationCreateWithoutUserInput, RecommendationUncheckedCreateWithoutUserInput>
  }

  export type RecommendationUpdateWithWhereUniqueWithoutUserInput = {
    where: RecommendationWhereUniqueInput
    data: XOR<RecommendationUpdateWithoutUserInput, RecommendationUncheckedUpdateWithoutUserInput>
  }

  export type RecommendationUpdateManyWithWhereWithoutUserInput = {
    where: RecommendationScalarWhereInput
    data: XOR<RecommendationUpdateManyMutationInput, RecommendationUncheckedUpdateManyWithoutUserInput>
  }

  export type RecommendationScalarWhereInput = {
    AND?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
    OR?: RecommendationScalarWhereInput[]
    NOT?: RecommendationScalarWhereInput | RecommendationScalarWhereInput[]
    id?: StringFilter<"Recommendation"> | string
    userId?: StringFilter<"Recommendation"> | string
    coachId?: StringNullableFilter<"Recommendation"> | string | null
    type?: StringFilter<"Recommendation"> | string
    content?: StringFilter<"Recommendation"> | string
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
  }

  export type CommissionUpsertWithWhereUniqueWithoutUserInput = {
    where: CommissionWhereUniqueInput
    update: XOR<CommissionUpdateWithoutUserInput, CommissionUncheckedUpdateWithoutUserInput>
    create: XOR<CommissionCreateWithoutUserInput, CommissionUncheckedCreateWithoutUserInput>
  }

  export type CommissionUpdateWithWhereUniqueWithoutUserInput = {
    where: CommissionWhereUniqueInput
    data: XOR<CommissionUpdateWithoutUserInput, CommissionUncheckedUpdateWithoutUserInput>
  }

  export type CommissionUpdateManyWithWhereWithoutUserInput = {
    where: CommissionScalarWhereInput
    data: XOR<CommissionUpdateManyMutationInput, CommissionUncheckedUpdateManyWithoutUserInput>
  }

  export type CommissionScalarWhereInput = {
    AND?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
    OR?: CommissionScalarWhereInput[]
    NOT?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
    id?: StringFilter<"Commission"> | string
    coachId?: StringFilter<"Commission"> | string
    orderId?: StringFilter<"Commission"> | string
    affiliateId?: StringNullableFilter<"Commission"> | string | null
    amount?: FloatFilter<"Commission"> | number
    createdAt?: DateTimeFilter<"Commission"> | Date | string
    userId?: StringNullableFilter<"Commission"> | string | null
  }

  export type CoachUpsertWithoutClientsInput = {
    update: XOR<CoachUpdateWithoutClientsInput, CoachUncheckedUpdateWithoutClientsInput>
    create: XOR<CoachCreateWithoutClientsInput, CoachUncheckedCreateWithoutClientsInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutClientsInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutClientsInput, CoachUncheckedUpdateWithoutClientsInput>
  }

  export type CoachUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCoachNestedInput
    commissions?: CommissionUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUpdateManyWithoutCoachNestedInput
    sessions?: SessionUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    commissions?: CommissionUncheckedUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutCoachNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUncheckedUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUncheckedUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUncheckedUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    coachId?: StringNullableFilter<"Session"> | string | null
    scheduledAt?: DateTimeFilter<"Session"> | Date | string
    durationMin?: IntFilter<"Session"> | number
    status?: StringFilter<"Session"> | string
    agoraChannel?: StringNullableFilter<"Session"> | string | null
    rating?: IntNullableFilter<"Session"> | number | null
    ratingNote?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    totalCents?: IntFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type WorkoutLogUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkoutLogWhereUniqueInput
    update: XOR<WorkoutLogUpdateWithoutUserInput, WorkoutLogUncheckedUpdateWithoutUserInput>
    create: XOR<WorkoutLogCreateWithoutUserInput, WorkoutLogUncheckedCreateWithoutUserInput>
  }

  export type WorkoutLogUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkoutLogWhereUniqueInput
    data: XOR<WorkoutLogUpdateWithoutUserInput, WorkoutLogUncheckedUpdateWithoutUserInput>
  }

  export type WorkoutLogUpdateManyWithWhereWithoutUserInput = {
    where: WorkoutLogScalarWhereInput
    data: XOR<WorkoutLogUpdateManyMutationInput, WorkoutLogUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkoutLogScalarWhereInput = {
    AND?: WorkoutLogScalarWhereInput | WorkoutLogScalarWhereInput[]
    OR?: WorkoutLogScalarWhereInput[]
    NOT?: WorkoutLogScalarWhereInput | WorkoutLogScalarWhereInput[]
    id?: StringFilter<"WorkoutLog"> | string
    userId?: StringFilter<"WorkoutLog"> | string
    date?: DateTimeFilter<"WorkoutLog"> | Date | string
    activity?: StringFilter<"WorkoutLog"> | string
    duration?: IntFilter<"WorkoutLog"> | number
    notes?: StringNullableFilter<"WorkoutLog"> | string | null
  }

  export type NutritionLogUpsertWithWhereUniqueWithoutUserInput = {
    where: NutritionLogWhereUniqueInput
    update: XOR<NutritionLogUpdateWithoutUserInput, NutritionLogUncheckedUpdateWithoutUserInput>
    create: XOR<NutritionLogCreateWithoutUserInput, NutritionLogUncheckedCreateWithoutUserInput>
  }

  export type NutritionLogUpdateWithWhereUniqueWithoutUserInput = {
    where: NutritionLogWhereUniqueInput
    data: XOR<NutritionLogUpdateWithoutUserInput, NutritionLogUncheckedUpdateWithoutUserInput>
  }

  export type NutritionLogUpdateManyWithWhereWithoutUserInput = {
    where: NutritionLogScalarWhereInput
    data: XOR<NutritionLogUpdateManyMutationInput, NutritionLogUncheckedUpdateManyWithoutUserInput>
  }

  export type NutritionLogScalarWhereInput = {
    AND?: NutritionLogScalarWhereInput | NutritionLogScalarWhereInput[]
    OR?: NutritionLogScalarWhereInput[]
    NOT?: NutritionLogScalarWhereInput | NutritionLogScalarWhereInput[]
    id?: StringFilter<"NutritionLog"> | string
    userId?: StringFilter<"NutritionLog"> | string
    date?: DateTimeFilter<"NutritionLog"> | Date | string
    meal?: StringFilter<"NutritionLog"> | string
    calories?: IntFilter<"NutritionLog"> | number
    protein?: FloatNullableFilter<"NutritionLog"> | number | null
    carbs?: FloatNullableFilter<"NutritionLog"> | number | null
    fats?: FloatNullableFilter<"NutritionLog"> | number | null
    mealType?: StringNullableFilter<"NutritionLog"> | string | null
    notes?: StringNullableFilter<"NutritionLog"> | string | null
  }

  export type SupplementLogUpsertWithWhereUniqueWithoutUserInput = {
    where: SupplementLogWhereUniqueInput
    update: XOR<SupplementLogUpdateWithoutUserInput, SupplementLogUncheckedUpdateWithoutUserInput>
    create: XOR<SupplementLogCreateWithoutUserInput, SupplementLogUncheckedCreateWithoutUserInput>
  }

  export type SupplementLogUpdateWithWhereUniqueWithoutUserInput = {
    where: SupplementLogWhereUniqueInput
    data: XOR<SupplementLogUpdateWithoutUserInput, SupplementLogUncheckedUpdateWithoutUserInput>
  }

  export type SupplementLogUpdateManyWithWhereWithoutUserInput = {
    where: SupplementLogScalarWhereInput
    data: XOR<SupplementLogUpdateManyMutationInput, SupplementLogUncheckedUpdateManyWithoutUserInput>
  }

  export type SupplementLogScalarWhereInput = {
    AND?: SupplementLogScalarWhereInput | SupplementLogScalarWhereInput[]
    OR?: SupplementLogScalarWhereInput[]
    NOT?: SupplementLogScalarWhereInput | SupplementLogScalarWhereInput[]
    id?: StringFilter<"SupplementLog"> | string
    userId?: StringFilter<"SupplementLog"> | string
    date?: DateTimeFilter<"SupplementLog"> | Date | string
    supplementName?: StringFilter<"SupplementLog"> | string
    dose?: StringFilter<"SupplementLog"> | string
    notes?: StringNullableFilter<"SupplementLog"> | string | null
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    planCode?: StringNullableFilter<"Subscription"> | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type CoachRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: CoachRequestWhereUniqueInput
    update: XOR<CoachRequestUpdateWithoutUserInput, CoachRequestUncheckedUpdateWithoutUserInput>
    create: XOR<CoachRequestCreateWithoutUserInput, CoachRequestUncheckedCreateWithoutUserInput>
  }

  export type CoachRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: CoachRequestWhereUniqueInput
    data: XOR<CoachRequestUpdateWithoutUserInput, CoachRequestUncheckedUpdateWithoutUserInput>
  }

  export type CoachRequestUpdateManyWithWhereWithoutUserInput = {
    where: CoachRequestScalarWhereInput
    data: XOR<CoachRequestUpdateManyMutationInput, CoachRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type CoachRequestScalarWhereInput = {
    AND?: CoachRequestScalarWhereInput | CoachRequestScalarWhereInput[]
    OR?: CoachRequestScalarWhereInput[]
    NOT?: CoachRequestScalarWhereInput | CoachRequestScalarWhereInput[]
    id?: StringFilter<"CoachRequest"> | string
    userId?: StringFilter<"CoachRequest"> | string
    status?: StringFilter<"CoachRequest"> | string
    createdAt?: DateTimeFilter<"CoachRequest"> | Date | string
  }

  export type UserIntakeUpsertWithoutUserInput = {
    update: XOR<UserIntakeUpdateWithoutUserInput, UserIntakeUncheckedUpdateWithoutUserInput>
    create: XOR<UserIntakeCreateWithoutUserInput, UserIntakeUncheckedCreateWithoutUserInput>
    where?: UserIntakeWhereInput
  }

  export type UserIntakeUpdateToOneWithWhereWithoutUserInput = {
    where?: UserIntakeWhereInput
    data: XOR<UserIntakeUpdateWithoutUserInput, UserIntakeUncheckedUpdateWithoutUserInput>
  }

  export type UserIntakeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    mainGoal?: NullableStringFieldUpdateOperationsInput | string | null
    workoutLocation?: NullableStringFieldUpdateOperationsInput | string | null
    firstCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    injuries?: UserIntakeUpdateinjuriesInput | string[]
    secondCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skippedSecond?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIntakeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    mainGoal?: NullableStringFieldUpdateOperationsInput | string | null
    workoutLocation?: NullableStringFieldUpdateOperationsInput | string | null
    firstCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null
    workoutFrequency?: NullableIntFieldUpdateOperationsInput | number | null
    injuries?: UserIntakeUpdateinjuriesInput | string[]
    secondCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skippedSecond?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionQuotaUpsertWithoutUserInput = {
    update: XOR<SubscriptionQuotaUpdateWithoutUserInput, SubscriptionQuotaUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionQuotaCreateWithoutUserInput, SubscriptionQuotaUncheckedCreateWithoutUserInput>
    where?: SubscriptionQuotaWhereInput
  }

  export type SubscriptionQuotaUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionQuotaWhereInput
    data: XOR<SubscriptionQuotaUpdateWithoutUserInput, SubscriptionQuotaUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionQuotaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    messagesUsed?: IntFieldUpdateOperationsInput | number
    callsUsed?: IntFieldUpdateOperationsInput | number
    attachmentsUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nutritionWindowDays?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nutritionLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionQuotaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    messagesUsed?: IntFieldUpdateOperationsInput | number
    callsUsed?: IntFieldUpdateOperationsInput | number
    attachmentsUsed?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nutritionWindowDays?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nutritionLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionPreferenceUpsertWithoutUserInput = {
    update: XOR<NutritionPreferenceUpdateWithoutUserInput, NutritionPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NutritionPreferenceCreateWithoutUserInput, NutritionPreferenceUncheckedCreateWithoutUserInput>
    where?: NutritionPreferenceWhereInput
  }

  export type NutritionPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: NutritionPreferenceWhereInput
    data: XOR<NutritionPreferenceUpdateWithoutUserInput, NutritionPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NutritionPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    proteinSources?: NutritionPreferenceUpdateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceUpdateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    proteinSources?: NutritionPreferenceUpdateproteinSourcesInput | string[]
    proteinAllergies?: NutritionPreferenceUpdateproteinAllergiesInput | string[]
    dinnerPreferences?: NullableJsonNullValueInput | InputJsonValue
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionAccessUpsertWithoutUserInput = {
    update: XOR<NutritionAccessUpdateWithoutUserInput, NutritionAccessUncheckedUpdateWithoutUserInput>
    create: XOR<NutritionAccessCreateWithoutUserInput, NutritionAccessUncheckedCreateWithoutUserInput>
    where?: NutritionAccessWhereInput
  }

  export type NutritionAccessUpdateToOneWithWhereWithoutUserInput = {
    where?: NutritionAccessWhereInput
    data: XOR<NutritionAccessUpdateWithoutUserInput, NutritionAccessUncheckedUpdateWithoutUserInput>
  }

  export type NutritionAccessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    windowDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NutritionAccessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planGeneratedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locked?: BoolFieldUpdateOperationsInput | boolean
    windowDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: CoachMessageWhereUniqueInput
    update: XOR<CoachMessageUpdateWithoutUserInput, CoachMessageUncheckedUpdateWithoutUserInput>
    create: XOR<CoachMessageCreateWithoutUserInput, CoachMessageUncheckedCreateWithoutUserInput>
  }

  export type CoachMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: CoachMessageWhereUniqueInput
    data: XOR<CoachMessageUpdateWithoutUserInput, CoachMessageUncheckedUpdateWithoutUserInput>
  }

  export type CoachMessageUpdateManyWithWhereWithoutUserInput = {
    where: CoachMessageScalarWhereInput
    data: XOR<CoachMessageUpdateManyMutationInput, CoachMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type CoachMessageScalarWhereInput = {
    AND?: CoachMessageScalarWhereInput | CoachMessageScalarWhereInput[]
    OR?: CoachMessageScalarWhereInput[]
    NOT?: CoachMessageScalarWhereInput | CoachMessageScalarWhereInput[]
    id?: StringFilter<"CoachMessage"> | string
    coachId?: StringFilter<"CoachMessage"> | string
    userId?: StringFilter<"CoachMessage"> | string
    sender?: StringFilter<"CoachMessage"> | string
    body?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentUrl?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentName?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentType?: StringNullableFilter<"CoachMessage"> | string | null
    attachmentSize?: IntNullableFilter<"CoachMessage"> | number | null
    createdAt?: DateTimeFilter<"CoachMessage"> | Date | string
  }

  export type UserCreateWithoutSessionInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
  }

  export type CoachCreateWithoutSessionsInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    user: UserCreateNestedOneWithoutCoachInput
    clients?: UserCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationCreateNestedManyWithoutCoachInput
    messages?: CoachMessageCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutSessionsInput = {
    id?: string
    userId: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    clients?: UserUncheckedCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutCoachInput
    messages?: CoachMessageUncheckedCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateUncheckedCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceUncheckedCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutSessionsInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutSessionsInput, CoachUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionInput = {
    update: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
    create: XOR<UserCreateWithoutSessionInput, UserUncheckedCreateWithoutSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionInput, UserUncheckedUpdateWithoutSessionInput>
  }

  export type UserUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CoachUpsertWithoutSessionsInput = {
    update: XOR<CoachUpdateWithoutSessionsInput, CoachUncheckedUpdateWithoutSessionsInput>
    create: XOR<CoachCreateWithoutSessionsInput, CoachUncheckedCreateWithoutSessionsInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutSessionsInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutSessionsInput, CoachUncheckedUpdateWithoutSessionsInput>
  }

  export type CoachUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCoachNestedInput
    clients?: UserUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    clients?: UserUncheckedUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUncheckedUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUncheckedUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUncheckedUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserCreateWithoutOrderInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrderInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    sku: string
    qty: number
    priceCents: number
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    sku: string
    qty: number
    priceCents: number
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CommissionCreateWithoutOrderInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    coach: CoachCreateNestedOneWithoutCommissionsInput
    affiliate?: AffiliateCreateNestedOneWithoutCommissionsInput
    User?: UserCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionUncheckedCreateWithoutOrderInput = {
    id?: string
    coachId: string
    affiliateId?: string | null
    amount: number
    createdAt?: Date | string
    userId?: string | null
  }

  export type CommissionCreateOrConnectWithoutOrderInput = {
    where: CommissionWhereUniqueInput
    create: XOR<CommissionCreateWithoutOrderInput, CommissionUncheckedCreateWithoutOrderInput>
  }

  export type CommissionCreateManyOrderInputEnvelope = {
    data: CommissionCreateManyOrderInput | CommissionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    subscription?: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutOrderInput = {
    id?: string
    status: string
    trackingUrl?: string | null
    address: string
    courier?: string | null
    estimatedDate?: Date | string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type DeliveryUncheckedCreateWithoutOrderInput = {
    id?: string
    status: string
    trackingUrl?: string | null
    address: string
    courier?: string | null
    estimatedDate?: Date | string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type DeliveryCreateOrConnectWithoutOrderInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
  }

  export type UserUpsertWithoutOrderInput = {
    update: XOR<UserUpdateWithoutOrderInput, UserUncheckedUpdateWithoutOrderInput>
    create: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrderInput, UserUncheckedUpdateWithoutOrderInput>
  }

  export type UserUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    sku?: StringFilter<"OrderItem"> | string
    qty?: IntFilter<"OrderItem"> | number
    priceCents?: IntFilter<"OrderItem"> | number
  }

  export type CommissionUpsertWithWhereUniqueWithoutOrderInput = {
    where: CommissionWhereUniqueInput
    update: XOR<CommissionUpdateWithoutOrderInput, CommissionUncheckedUpdateWithoutOrderInput>
    create: XOR<CommissionCreateWithoutOrderInput, CommissionUncheckedCreateWithoutOrderInput>
  }

  export type CommissionUpdateWithWhereUniqueWithoutOrderInput = {
    where: CommissionWhereUniqueInput
    data: XOR<CommissionUpdateWithoutOrderInput, CommissionUncheckedUpdateWithoutOrderInput>
  }

  export type CommissionUpdateManyWithWhereWithoutOrderInput = {
    where: CommissionScalarWhereInput
    data: XOR<CommissionUpdateManyMutationInput, CommissionUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type DeliveryUpsertWithoutOrderInput = {
    update: XOR<DeliveryUpdateWithoutOrderInput, DeliveryUncheckedUpdateWithoutOrderInput>
    create: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
    where?: DeliveryWhereInput
  }

  export type DeliveryUpdateToOneWithWhereWithoutOrderInput = {
    where?: DeliveryWhereInput
    data: XOR<DeliveryUpdateWithoutOrderInput, DeliveryUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trackingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    courier?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    trackingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    courier?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrderInput
    commissions?: CommissionCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Delivery?: DeliveryCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    commissions?: CommissionUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
    commissions?: CommissionUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Delivery?: DeliveryUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: CommissionUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type UserCreateWithoutCoachInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoachInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoachInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoachInput, UserUncheckedCreateWithoutCoachInput>
  }

  export type UserCreateWithoutCoachClientsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoachClientsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoachClientsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoachClientsInput, UserUncheckedCreateWithoutCoachClientsInput>
  }

  export type UserCreateManyCoachClientsInputEnvelope = {
    data: UserCreateManyCoachClientsInput | UserCreateManyCoachClientsInput[]
    skipDuplicates?: boolean
  }

  export type CommissionCreateWithoutCoachInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutCommissionsInput
    affiliate?: AffiliateCreateNestedOneWithoutCommissionsInput
    User?: UserCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionUncheckedCreateWithoutCoachInput = {
    id?: string
    orderId: string
    affiliateId?: string | null
    amount: number
    createdAt?: Date | string
    userId?: string | null
  }

  export type CommissionCreateOrConnectWithoutCoachInput = {
    where: CommissionWhereUniqueInput
    create: XOR<CommissionCreateWithoutCoachInput, CommissionUncheckedCreateWithoutCoachInput>
  }

  export type CommissionCreateManyCoachInputEnvelope = {
    data: CommissionCreateManyCoachInput | CommissionCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type RecommendationCreateWithoutCoachInput = {
    id?: string
    type: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRecommendationsInput
  }

  export type RecommendationUncheckedCreateWithoutCoachInput = {
    id?: string
    userId: string
    type: string
    content: string
    createdAt?: Date | string
  }

  export type RecommendationCreateOrConnectWithoutCoachInput = {
    where: RecommendationWhereUniqueInput
    create: XOR<RecommendationCreateWithoutCoachInput, RecommendationUncheckedCreateWithoutCoachInput>
  }

  export type RecommendationCreateManyCoachInputEnvelope = {
    data: RecommendationCreateManyCoachInput | RecommendationCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutCoachInput = {
    id?: string
    scheduledAt: Date | string
    durationMin?: number
    status?: string
    agoraChannel?: string | null
    rating?: number | null
    ratingNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutCoachInput = {
    id?: string
    userId: string
    scheduledAt: Date | string
    durationMin?: number
    status?: string
    agoraChannel?: string | null
    rating?: number | null
    ratingNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutCoachInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutCoachInput, SessionUncheckedCreateWithoutCoachInput>
  }

  export type SessionCreateManyCoachInputEnvelope = {
    data: SessionCreateManyCoachInput | SessionCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type CoachMessageCreateWithoutCoachInput = {
    id?: string
    sender: string
    body?: string | null
    attachmentUrl?: string | null
    attachmentName?: string | null
    attachmentType?: string | null
    attachmentSize?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCoachMessagesInput
  }

  export type CoachMessageUncheckedCreateWithoutCoachInput = {
    id?: string
    userId: string
    sender: string
    body?: string | null
    attachmentUrl?: string | null
    attachmentName?: string | null
    attachmentType?: string | null
    attachmentSize?: number | null
    createdAt?: Date | string
  }

  export type CoachMessageCreateOrConnectWithoutCoachInput = {
    where: CoachMessageWhereUniqueInput
    create: XOR<CoachMessageCreateWithoutCoachInput, CoachMessageUncheckedCreateWithoutCoachInput>
  }

  export type CoachMessageCreateManyCoachInputEnvelope = {
    data: CoachMessageCreateManyCoachInput | CoachMessageCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type CoachCertificateCreateWithoutCoachInput = {
    id?: string
    name: string
    issuingOrganization: string
    issuedAt: Date | string
    expiresAt?: Date | string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachCertificateUncheckedCreateWithoutCoachInput = {
    id?: string
    name: string
    issuingOrganization: string
    issuedAt: Date | string
    expiresAt?: Date | string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachCertificateCreateOrConnectWithoutCoachInput = {
    where: CoachCertificateWhereUniqueInput
    create: XOR<CoachCertificateCreateWithoutCoachInput, CoachCertificateUncheckedCreateWithoutCoachInput>
  }

  export type CoachCertificateCreateManyCoachInputEnvelope = {
    data: CoachCertificateCreateManyCoachInput | CoachCertificateCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type CoachExperienceCreateWithoutCoachInput = {
    id?: string
    title: string
    organization: string
    startDate: Date | string
    endDate?: Date | string | null
    isCurrent?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachExperienceUncheckedCreateWithoutCoachInput = {
    id?: string
    title: string
    organization: string
    startDate: Date | string
    endDate?: Date | string | null
    isCurrent?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachExperienceCreateOrConnectWithoutCoachInput = {
    where: CoachExperienceWhereUniqueInput
    create: XOR<CoachExperienceCreateWithoutCoachInput, CoachExperienceUncheckedCreateWithoutCoachInput>
  }

  export type CoachExperienceCreateManyCoachInputEnvelope = {
    data: CoachExperienceCreateManyCoachInput | CoachExperienceCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type CoachAchievementCreateWithoutCoachInput = {
    id?: string
    title: string
    description?: string | null
    achievedAt: Date | string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachAchievementUncheckedCreateWithoutCoachInput = {
    id?: string
    title: string
    description?: string | null
    achievedAt: Date | string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachAchievementCreateOrConnectWithoutCoachInput = {
    where: CoachAchievementWhereUniqueInput
    create: XOR<CoachAchievementCreateWithoutCoachInput, CoachAchievementUncheckedCreateWithoutCoachInput>
  }

  export type CoachAchievementCreateManyCoachInputEnvelope = {
    data: CoachAchievementCreateManyCoachInput | CoachAchievementCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCoachInput = {
    update: XOR<UserUpdateWithoutCoachInput, UserUncheckedUpdateWithoutCoachInput>
    create: XOR<UserCreateWithoutCoachInput, UserUncheckedCreateWithoutCoachInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoachInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoachInput, UserUncheckedUpdateWithoutCoachInput>
  }

  export type UserUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCoachClientsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCoachClientsInput, UserUncheckedUpdateWithoutCoachClientsInput>
    create: XOR<UserCreateWithoutCoachClientsInput, UserUncheckedCreateWithoutCoachClientsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCoachClientsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCoachClientsInput, UserUncheckedUpdateWithoutCoachClientsInput>
  }

  export type UserUpdateManyWithWhereWithoutCoachClientsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCoachClientsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    preferredLocale?: StringNullableFilter<"User"> | string | null
    deviceToken?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    coachId?: StringNullableFilter<"User"> | string | null
    coachClientsId?: StringNullableFilter<"User"> | string | null
  }

  export type CommissionUpsertWithWhereUniqueWithoutCoachInput = {
    where: CommissionWhereUniqueInput
    update: XOR<CommissionUpdateWithoutCoachInput, CommissionUncheckedUpdateWithoutCoachInput>
    create: XOR<CommissionCreateWithoutCoachInput, CommissionUncheckedCreateWithoutCoachInput>
  }

  export type CommissionUpdateWithWhereUniqueWithoutCoachInput = {
    where: CommissionWhereUniqueInput
    data: XOR<CommissionUpdateWithoutCoachInput, CommissionUncheckedUpdateWithoutCoachInput>
  }

  export type CommissionUpdateManyWithWhereWithoutCoachInput = {
    where: CommissionScalarWhereInput
    data: XOR<CommissionUpdateManyMutationInput, CommissionUncheckedUpdateManyWithoutCoachInput>
  }

  export type RecommendationUpsertWithWhereUniqueWithoutCoachInput = {
    where: RecommendationWhereUniqueInput
    update: XOR<RecommendationUpdateWithoutCoachInput, RecommendationUncheckedUpdateWithoutCoachInput>
    create: XOR<RecommendationCreateWithoutCoachInput, RecommendationUncheckedCreateWithoutCoachInput>
  }

  export type RecommendationUpdateWithWhereUniqueWithoutCoachInput = {
    where: RecommendationWhereUniqueInput
    data: XOR<RecommendationUpdateWithoutCoachInput, RecommendationUncheckedUpdateWithoutCoachInput>
  }

  export type RecommendationUpdateManyWithWhereWithoutCoachInput = {
    where: RecommendationScalarWhereInput
    data: XOR<RecommendationUpdateManyMutationInput, RecommendationUncheckedUpdateManyWithoutCoachInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutCoachInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutCoachInput, SessionUncheckedUpdateWithoutCoachInput>
    create: XOR<SessionCreateWithoutCoachInput, SessionUncheckedCreateWithoutCoachInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutCoachInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutCoachInput, SessionUncheckedUpdateWithoutCoachInput>
  }

  export type SessionUpdateManyWithWhereWithoutCoachInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutCoachInput>
  }

  export type CoachMessageUpsertWithWhereUniqueWithoutCoachInput = {
    where: CoachMessageWhereUniqueInput
    update: XOR<CoachMessageUpdateWithoutCoachInput, CoachMessageUncheckedUpdateWithoutCoachInput>
    create: XOR<CoachMessageCreateWithoutCoachInput, CoachMessageUncheckedCreateWithoutCoachInput>
  }

  export type CoachMessageUpdateWithWhereUniqueWithoutCoachInput = {
    where: CoachMessageWhereUniqueInput
    data: XOR<CoachMessageUpdateWithoutCoachInput, CoachMessageUncheckedUpdateWithoutCoachInput>
  }

  export type CoachMessageUpdateManyWithWhereWithoutCoachInput = {
    where: CoachMessageScalarWhereInput
    data: XOR<CoachMessageUpdateManyMutationInput, CoachMessageUncheckedUpdateManyWithoutCoachInput>
  }

  export type CoachCertificateUpsertWithWhereUniqueWithoutCoachInput = {
    where: CoachCertificateWhereUniqueInput
    update: XOR<CoachCertificateUpdateWithoutCoachInput, CoachCertificateUncheckedUpdateWithoutCoachInput>
    create: XOR<CoachCertificateCreateWithoutCoachInput, CoachCertificateUncheckedCreateWithoutCoachInput>
  }

  export type CoachCertificateUpdateWithWhereUniqueWithoutCoachInput = {
    where: CoachCertificateWhereUniqueInput
    data: XOR<CoachCertificateUpdateWithoutCoachInput, CoachCertificateUncheckedUpdateWithoutCoachInput>
  }

  export type CoachCertificateUpdateManyWithWhereWithoutCoachInput = {
    where: CoachCertificateScalarWhereInput
    data: XOR<CoachCertificateUpdateManyMutationInput, CoachCertificateUncheckedUpdateManyWithoutCoachInput>
  }

  export type CoachCertificateScalarWhereInput = {
    AND?: CoachCertificateScalarWhereInput | CoachCertificateScalarWhereInput[]
    OR?: CoachCertificateScalarWhereInput[]
    NOT?: CoachCertificateScalarWhereInput | CoachCertificateScalarWhereInput[]
    id?: StringFilter<"CoachCertificate"> | string
    coachId?: StringFilter<"CoachCertificate"> | string
    name?: StringFilter<"CoachCertificate"> | string
    issuingOrganization?: StringFilter<"CoachCertificate"> | string
    issuedAt?: DateTimeFilter<"CoachCertificate"> | Date | string
    expiresAt?: DateTimeNullableFilter<"CoachCertificate"> | Date | string | null
    certificateUrl?: StringNullableFilter<"CoachCertificate"> | string | null
    createdAt?: DateTimeFilter<"CoachCertificate"> | Date | string
    updatedAt?: DateTimeFilter<"CoachCertificate"> | Date | string
  }

  export type CoachExperienceUpsertWithWhereUniqueWithoutCoachInput = {
    where: CoachExperienceWhereUniqueInput
    update: XOR<CoachExperienceUpdateWithoutCoachInput, CoachExperienceUncheckedUpdateWithoutCoachInput>
    create: XOR<CoachExperienceCreateWithoutCoachInput, CoachExperienceUncheckedCreateWithoutCoachInput>
  }

  export type CoachExperienceUpdateWithWhereUniqueWithoutCoachInput = {
    where: CoachExperienceWhereUniqueInput
    data: XOR<CoachExperienceUpdateWithoutCoachInput, CoachExperienceUncheckedUpdateWithoutCoachInput>
  }

  export type CoachExperienceUpdateManyWithWhereWithoutCoachInput = {
    where: CoachExperienceScalarWhereInput
    data: XOR<CoachExperienceUpdateManyMutationInput, CoachExperienceUncheckedUpdateManyWithoutCoachInput>
  }

  export type CoachExperienceScalarWhereInput = {
    AND?: CoachExperienceScalarWhereInput | CoachExperienceScalarWhereInput[]
    OR?: CoachExperienceScalarWhereInput[]
    NOT?: CoachExperienceScalarWhereInput | CoachExperienceScalarWhereInput[]
    id?: StringFilter<"CoachExperience"> | string
    coachId?: StringFilter<"CoachExperience"> | string
    title?: StringFilter<"CoachExperience"> | string
    organization?: StringFilter<"CoachExperience"> | string
    startDate?: DateTimeFilter<"CoachExperience"> | Date | string
    endDate?: DateTimeNullableFilter<"CoachExperience"> | Date | string | null
    isCurrent?: BoolFilter<"CoachExperience"> | boolean
    description?: StringNullableFilter<"CoachExperience"> | string | null
    createdAt?: DateTimeFilter<"CoachExperience"> | Date | string
    updatedAt?: DateTimeFilter<"CoachExperience"> | Date | string
  }

  export type CoachAchievementUpsertWithWhereUniqueWithoutCoachInput = {
    where: CoachAchievementWhereUniqueInput
    update: XOR<CoachAchievementUpdateWithoutCoachInput, CoachAchievementUncheckedUpdateWithoutCoachInput>
    create: XOR<CoachAchievementCreateWithoutCoachInput, CoachAchievementUncheckedCreateWithoutCoachInput>
  }

  export type CoachAchievementUpdateWithWhereUniqueWithoutCoachInput = {
    where: CoachAchievementWhereUniqueInput
    data: XOR<CoachAchievementUpdateWithoutCoachInput, CoachAchievementUncheckedUpdateWithoutCoachInput>
  }

  export type CoachAchievementUpdateManyWithWhereWithoutCoachInput = {
    where: CoachAchievementScalarWhereInput
    data: XOR<CoachAchievementUpdateManyMutationInput, CoachAchievementUncheckedUpdateManyWithoutCoachInput>
  }

  export type CoachAchievementScalarWhereInput = {
    AND?: CoachAchievementScalarWhereInput | CoachAchievementScalarWhereInput[]
    OR?: CoachAchievementScalarWhereInput[]
    NOT?: CoachAchievementScalarWhereInput | CoachAchievementScalarWhereInput[]
    id?: StringFilter<"CoachAchievement"> | string
    coachId?: StringFilter<"CoachAchievement"> | string
    title?: StringFilter<"CoachAchievement"> | string
    description?: StringNullableFilter<"CoachAchievement"> | string | null
    achievedAt?: DateTimeFilter<"CoachAchievement"> | Date | string
    type?: StringFilter<"CoachAchievement"> | string
    createdAt?: DateTimeFilter<"CoachAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"CoachAchievement"> | Date | string
  }

  export type CoachCreateWithoutCertificatesInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    user: UserCreateNestedOneWithoutCoachInput
    clients?: UserCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationCreateNestedManyWithoutCoachInput
    sessions?: SessionCreateNestedManyWithoutCoachInput
    messages?: CoachMessageCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutCertificatesInput = {
    id?: string
    userId: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    clients?: UserUncheckedCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutCoachInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCoachInput
    messages?: CoachMessageUncheckedCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceUncheckedCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutCertificatesInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutCertificatesInput, CoachUncheckedCreateWithoutCertificatesInput>
  }

  export type CoachUpsertWithoutCertificatesInput = {
    update: XOR<CoachUpdateWithoutCertificatesInput, CoachUncheckedUpdateWithoutCertificatesInput>
    create: XOR<CoachCreateWithoutCertificatesInput, CoachUncheckedCreateWithoutCertificatesInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutCertificatesInput, CoachUncheckedUpdateWithoutCertificatesInput>
  }

  export type CoachUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCoachNestedInput
    clients?: UserUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUpdateManyWithoutCoachNestedInput
    sessions?: SessionUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    clients?: UserUncheckedUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutCoachNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUncheckedUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUncheckedUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type CoachCreateWithoutExperiencesInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    user: UserCreateNestedOneWithoutCoachInput
    clients?: UserCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationCreateNestedManyWithoutCoachInput
    sessions?: SessionCreateNestedManyWithoutCoachInput
    messages?: CoachMessageCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutExperiencesInput = {
    id?: string
    userId: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    clients?: UserUncheckedCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutCoachInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCoachInput
    messages?: CoachMessageUncheckedCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateUncheckedCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutExperiencesInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutExperiencesInput, CoachUncheckedCreateWithoutExperiencesInput>
  }

  export type CoachUpsertWithoutExperiencesInput = {
    update: XOR<CoachUpdateWithoutExperiencesInput, CoachUncheckedUpdateWithoutExperiencesInput>
    create: XOR<CoachCreateWithoutExperiencesInput, CoachUncheckedCreateWithoutExperiencesInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutExperiencesInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutExperiencesInput, CoachUncheckedUpdateWithoutExperiencesInput>
  }

  export type CoachUpdateWithoutExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCoachNestedInput
    clients?: UserUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUpdateManyWithoutCoachNestedInput
    sessions?: SessionUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutExperiencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    clients?: UserUncheckedUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutCoachNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUncheckedUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUncheckedUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type CoachCreateWithoutAchievementsInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    user: UserCreateNestedOneWithoutCoachInput
    clients?: UserCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationCreateNestedManyWithoutCoachInput
    sessions?: SessionCreateNestedManyWithoutCoachInput
    messages?: CoachMessageCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutAchievementsInput = {
    id?: string
    userId: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    clients?: UserUncheckedCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutCoachInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCoachInput
    messages?: CoachMessageUncheckedCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateUncheckedCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutAchievementsInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutAchievementsInput, CoachUncheckedCreateWithoutAchievementsInput>
  }

  export type CoachUpsertWithoutAchievementsInput = {
    update: XOR<CoachUpdateWithoutAchievementsInput, CoachUncheckedUpdateWithoutAchievementsInput>
    create: XOR<CoachCreateWithoutAchievementsInput, CoachUncheckedCreateWithoutAchievementsInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutAchievementsInput, CoachUncheckedUpdateWithoutAchievementsInput>
  }

  export type CoachUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCoachNestedInput
    clients?: UserUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUpdateManyWithoutCoachNestedInput
    sessions?: SessionUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    clients?: UserUncheckedUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutCoachNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUncheckedUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUncheckedUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserCreateWithoutWorkoutLogInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkoutLogInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkoutLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkoutLogInput, UserUncheckedCreateWithoutWorkoutLogInput>
  }

  export type UserUpsertWithoutWorkoutLogInput = {
    update: XOR<UserUpdateWithoutWorkoutLogInput, UserUncheckedUpdateWithoutWorkoutLogInput>
    create: XOR<UserCreateWithoutWorkoutLogInput, UserUncheckedCreateWithoutWorkoutLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkoutLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkoutLogInput, UserUncheckedUpdateWithoutWorkoutLogInput>
  }

  export type UserUpdateWithoutWorkoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkoutLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNutritionLogInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNutritionLogInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNutritionLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNutritionLogInput, UserUncheckedCreateWithoutNutritionLogInput>
  }

  export type UserUpsertWithoutNutritionLogInput = {
    update: XOR<UserUpdateWithoutNutritionLogInput, UserUncheckedUpdateWithoutNutritionLogInput>
    create: XOR<UserCreateWithoutNutritionLogInput, UserUncheckedCreateWithoutNutritionLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNutritionLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNutritionLogInput, UserUncheckedUpdateWithoutNutritionLogInput>
  }

  export type UserUpdateWithoutNutritionLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNutritionLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSupplementLogInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupplementLogInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupplementLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupplementLogInput, UserUncheckedCreateWithoutSupplementLogInput>
  }

  export type UserUpsertWithoutSupplementLogInput = {
    update: XOR<UserUpdateWithoutSupplementLogInput, UserUncheckedUpdateWithoutSupplementLogInput>
    create: XOR<UserCreateWithoutSupplementLogInput, UserUncheckedCreateWithoutSupplementLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupplementLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupplementLogInput, UserUncheckedUpdateWithoutSupplementLogInput>
  }

  export type UserUpdateWithoutSupplementLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupplementLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentCreateWithoutSubscriptionInput = {
    id?: string
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    order?: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    userId: string
    orderId?: string | null
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentCreateManySubscriptionInputEnvelope = {
    data: PaymentCreateManySubscriptionInput | PaymentCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UserCreateWithoutRecommendationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecommendationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecommendationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecommendationsInput, UserUncheckedCreateWithoutRecommendationsInput>
  }

  export type CoachCreateWithoutRecommendationsInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    user: UserCreateNestedOneWithoutCoachInput
    clients?: UserCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionCreateNestedManyWithoutCoachInput
    sessions?: SessionCreateNestedManyWithoutCoachInput
    messages?: CoachMessageCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutRecommendationsInput = {
    id?: string
    userId: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    clients?: UserUncheckedCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutCoachInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCoachInput
    messages?: CoachMessageUncheckedCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateUncheckedCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceUncheckedCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutRecommendationsInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutRecommendationsInput, CoachUncheckedCreateWithoutRecommendationsInput>
  }

  export type UserUpsertWithoutRecommendationsInput = {
    update: XOR<UserUpdateWithoutRecommendationsInput, UserUncheckedUpdateWithoutRecommendationsInput>
    create: XOR<UserCreateWithoutRecommendationsInput, UserUncheckedCreateWithoutRecommendationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecommendationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecommendationsInput, UserUncheckedUpdateWithoutRecommendationsInput>
  }

  export type UserUpdateWithoutRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CoachUpsertWithoutRecommendationsInput = {
    update: XOR<CoachUpdateWithoutRecommendationsInput, CoachUncheckedUpdateWithoutRecommendationsInput>
    create: XOR<CoachCreateWithoutRecommendationsInput, CoachUncheckedCreateWithoutRecommendationsInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutRecommendationsInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutRecommendationsInput, CoachUncheckedUpdateWithoutRecommendationsInput>
  }

  export type CoachUpdateWithoutRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCoachNestedInput
    clients?: UserUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUpdateManyWithoutCoachNestedInput
    sessions?: SessionUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    clients?: UserUncheckedUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutCoachNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUncheckedUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUncheckedUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUncheckedUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    price?: number | null
    priceCents: number
    currency?: string
    inventory?: number
    bundles?: BundleCreateNestedManyWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    price?: number | null
    priceCents: number
    currency?: string
    inventory?: number
    bundles?: BundleUncheckedCreateNestedManyWithoutProductsInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatNullableFilter<"Product"> | number | null
    priceCents?: IntFilter<"Product"> | number
    currency?: StringFilter<"Product"> | string
    inventory?: IntFilter<"Product"> | number
    categoryId?: StringFilter<"Product"> | string
  }

  export type ProductCreateWithoutBundlesInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    price?: number | null
    priceCents: number
    currency?: string
    inventory?: number
    category: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutBundlesInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    price?: number | null
    priceCents: number
    currency?: string
    inventory?: number
    categoryId: string
  }

  export type ProductCreateOrConnectWithoutBundlesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBundlesInput, ProductUncheckedCreateWithoutBundlesInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutBundlesInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBundlesInput, ProductUncheckedUpdateWithoutBundlesInput>
    create: XOR<ProductCreateWithoutBundlesInput, ProductUncheckedCreateWithoutBundlesInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBundlesInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBundlesInput, ProductUncheckedUpdateWithoutBundlesInput>
  }

  export type ProductUpdateManyWithWhereWithoutBundlesInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBundlesInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type BundleCreateWithoutProductsInput = {
    id?: string
    name: string
    price: number
  }

  export type BundleUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    price: number
  }

  export type BundleCreateOrConnectWithoutProductsInput = {
    where: BundleWhereUniqueInput
    create: XOR<BundleCreateWithoutProductsInput, BundleUncheckedCreateWithoutProductsInput>
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BundleUpsertWithWhereUniqueWithoutProductsInput = {
    where: BundleWhereUniqueInput
    update: XOR<BundleUpdateWithoutProductsInput, BundleUncheckedUpdateWithoutProductsInput>
    create: XOR<BundleCreateWithoutProductsInput, BundleUncheckedCreateWithoutProductsInput>
  }

  export type BundleUpdateWithWhereUniqueWithoutProductsInput = {
    where: BundleWhereUniqueInput
    data: XOR<BundleUpdateWithoutProductsInput, BundleUncheckedUpdateWithoutProductsInput>
  }

  export type BundleUpdateManyWithWhereWithoutProductsInput = {
    where: BundleScalarWhereInput
    data: XOR<BundleUpdateManyMutationInput, BundleUncheckedUpdateManyWithoutProductsInput>
  }

  export type BundleScalarWhereInput = {
    AND?: BundleScalarWhereInput | BundleScalarWhereInput[]
    OR?: BundleScalarWhereInput[]
    NOT?: BundleScalarWhereInput | BundleScalarWhereInput[]
    id?: StringFilter<"Bundle"> | string
    name?: StringFilter<"Bundle"> | string
    price?: FloatFilter<"Bundle"> | number
  }

  export type OrderCreateWithoutDeliveryInput = {
    id?: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    commissions?: CommissionCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDeliveryInput = {
    id?: string
    userId: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDeliveryInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDeliveryInput, OrderUncheckedCreateWithoutDeliveryInput>
  }

  export type OrderUpsertWithoutDeliveryInput = {
    update: XOR<OrderUpdateWithoutDeliveryInput, OrderUncheckedUpdateWithoutDeliveryInput>
    create: XOR<OrderCreateWithoutDeliveryInput, OrderUncheckedCreateWithoutDeliveryInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutDeliveryInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutDeliveryInput, OrderUncheckedUpdateWithoutDeliveryInput>
  }

  export type OrderUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    commissions?: CommissionUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDeliveryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CommissionCreateWithoutAffiliateInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    coach: CoachCreateNestedOneWithoutCommissionsInput
    order: OrderCreateNestedOneWithoutCommissionsInput
    User?: UserCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionUncheckedCreateWithoutAffiliateInput = {
    id?: string
    coachId: string
    orderId: string
    amount: number
    createdAt?: Date | string
    userId?: string | null
  }

  export type CommissionCreateOrConnectWithoutAffiliateInput = {
    where: CommissionWhereUniqueInput
    create: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput>
  }

  export type CommissionCreateManyAffiliateInputEnvelope = {
    data: CommissionCreateManyAffiliateInput | CommissionCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type CommissionUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: CommissionWhereUniqueInput
    update: XOR<CommissionUpdateWithoutAffiliateInput, CommissionUncheckedUpdateWithoutAffiliateInput>
    create: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput>
  }

  export type CommissionUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: CommissionWhereUniqueInput
    data: XOR<CommissionUpdateWithoutAffiliateInput, CommissionUncheckedUpdateWithoutAffiliateInput>
  }

  export type CommissionUpdateManyWithWhereWithoutAffiliateInput = {
    where: CommissionScalarWhereInput
    data: XOR<CommissionUpdateManyMutationInput, CommissionUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type CoachCreateWithoutMessagesInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    user: UserCreateNestedOneWithoutCoachInput
    clients?: UserCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationCreateNestedManyWithoutCoachInput
    sessions?: SessionCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    clients?: UserUncheckedCreateNestedManyWithoutCoachClientsInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutCoachInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutCoachInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateUncheckedCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceUncheckedCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutMessagesInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutMessagesInput, CoachUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutCoachMessagesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoachMessagesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoachMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoachMessagesInput, UserUncheckedCreateWithoutCoachMessagesInput>
  }

  export type CoachUpsertWithoutMessagesInput = {
    update: XOR<CoachUpdateWithoutMessagesInput, CoachUncheckedUpdateWithoutMessagesInput>
    create: XOR<CoachCreateWithoutMessagesInput, CoachUncheckedCreateWithoutMessagesInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutMessagesInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutMessagesInput, CoachUncheckedUpdateWithoutMessagesInput>
  }

  export type CoachUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCoachNestedInput
    clients?: UserUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUpdateManyWithoutCoachNestedInput
    sessions?: SessionUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    clients?: UserUncheckedUpdateManyWithoutCoachClientsNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutCoachNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutCoachNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUncheckedUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUncheckedUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type UserUpsertWithoutCoachMessagesInput = {
    update: XOR<UserUpdateWithoutCoachMessagesInput, UserUncheckedUpdateWithoutCoachMessagesInput>
    create: XOR<UserCreateWithoutCoachMessagesInput, UserUncheckedCreateWithoutCoachMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoachMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoachMessagesInput, UserUncheckedUpdateWithoutCoachMessagesInput>
  }

  export type UserUpdateWithoutCoachMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoachMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CoachCreateWithoutCommissionsInput = {
    id?: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    user: UserCreateNestedOneWithoutCoachInput
    clients?: UserCreateNestedManyWithoutCoachClientsInput
    recommendations?: RecommendationCreateNestedManyWithoutCoachInput
    sessions?: SessionCreateNestedManyWithoutCoachInput
    messages?: CoachMessageCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementCreateNestedManyWithoutCoachInput
  }

  export type CoachUncheckedCreateWithoutCommissionsInput = {
    id?: string
    userId: string
    bio?: string | null
    certifications?: string | null
    referralCode?: string | null
    specializations?: CoachCreatespecializationsInput | string[]
    experienceYears?: number | null
    headline?: string | null
    verified?: boolean
    clients?: UserUncheckedCreateNestedManyWithoutCoachClientsInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutCoachInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCoachInput
    messages?: CoachMessageUncheckedCreateNestedManyWithoutCoachInput
    certificates?: CoachCertificateUncheckedCreateNestedManyWithoutCoachInput
    experiences?: CoachExperienceUncheckedCreateNestedManyWithoutCoachInput
    achievements?: CoachAchievementUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachCreateOrConnectWithoutCommissionsInput = {
    where: CoachWhereUniqueInput
    create: XOR<CoachCreateWithoutCommissionsInput, CoachUncheckedCreateWithoutCommissionsInput>
  }

  export type OrderCreateWithoutCommissionsInput = {
    id?: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    Delivery?: DeliveryCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCommissionsInput = {
    id?: string
    userId: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    Delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCommissionsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCommissionsInput, OrderUncheckedCreateWithoutCommissionsInput>
  }

  export type AffiliateCreateWithoutCommissionsInput = {
    id?: string
    name: string
    referralCode: string
    brandUrl?: string | null
  }

  export type AffiliateUncheckedCreateWithoutCommissionsInput = {
    id?: string
    name: string
    referralCode: string
    brandUrl?: string | null
  }

  export type AffiliateCreateOrConnectWithoutCommissionsInput = {
    where: AffiliateWhereUniqueInput
    create: XOR<AffiliateCreateWithoutCommissionsInput, AffiliateUncheckedCreateWithoutCommissionsInput>
  }

  export type UserCreateWithoutCommissionsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommissionsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
  }

  export type CoachUpsertWithoutCommissionsInput = {
    update: XOR<CoachUpdateWithoutCommissionsInput, CoachUncheckedUpdateWithoutCommissionsInput>
    create: XOR<CoachCreateWithoutCommissionsInput, CoachUncheckedCreateWithoutCommissionsInput>
    where?: CoachWhereInput
  }

  export type CoachUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: CoachWhereInput
    data: XOR<CoachUpdateWithoutCommissionsInput, CoachUncheckedUpdateWithoutCommissionsInput>
  }

  export type CoachUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCoachNestedInput
    clients?: UserUpdateManyWithoutCoachClientsNestedInput
    recommendations?: RecommendationUpdateManyWithoutCoachNestedInput
    sessions?: SessionUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUpdateManyWithoutCoachNestedInput
  }

  export type CoachUncheckedUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: CoachUpdatespecializationsInput | string[]
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    clients?: UserUncheckedUpdateManyWithoutCoachClientsNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutCoachNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCoachNestedInput
    messages?: CoachMessageUncheckedUpdateManyWithoutCoachNestedInput
    certificates?: CoachCertificateUncheckedUpdateManyWithoutCoachNestedInput
    experiences?: CoachExperienceUncheckedUpdateManyWithoutCoachNestedInput
    achievements?: CoachAchievementUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type OrderUpsertWithoutCommissionsInput = {
    update: XOR<OrderUpdateWithoutCommissionsInput, OrderUncheckedUpdateWithoutCommissionsInput>
    create: XOR<OrderCreateWithoutCommissionsInput, OrderUncheckedCreateWithoutCommissionsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutCommissionsInput, OrderUncheckedUpdateWithoutCommissionsInput>
  }

  export type OrderUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Delivery?: DeliveryUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type AffiliateUpsertWithoutCommissionsInput = {
    update: XOR<AffiliateUpdateWithoutCommissionsInput, AffiliateUncheckedUpdateWithoutCommissionsInput>
    create: XOR<AffiliateCreateWithoutCommissionsInput, AffiliateUncheckedCreateWithoutCommissionsInput>
    where?: AffiliateWhereInput
  }

  export type AffiliateUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: AffiliateWhereInput
    data: XOR<AffiliateUpdateWithoutCommissionsInput, AffiliateUncheckedUpdateWithoutCommissionsInput>
  }

  export type AffiliateUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    brandUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AffiliateUncheckedUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    brandUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutCommissionsInput = {
    update: XOR<UserUpdateWithoutCommissionsInput, UserUncheckedUpdateWithoutCommissionsInput>
    create: XOR<UserCreateWithoutCommissionsInput, UserUncheckedCreateWithoutCommissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommissionsInput, UserUncheckedUpdateWithoutCommissionsInput>
  }

  export type UserUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMilestonesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMilestonesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMilestonesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMilestonesInput, UserUncheckedCreateWithoutMilestonesInput>
  }

  export type UserUpsertWithoutMilestonesInput = {
    update: XOR<UserUpdateWithoutMilestonesInput, UserUncheckedUpdateWithoutMilestonesInput>
    create: XOR<UserCreateWithoutMilestonesInput, UserUncheckedCreateWithoutMilestonesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMilestonesInput, UserUncheckedUpdateWithoutMilestonesInput>
  }

  export type UserUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type OrderCreateWithoutPaymentsInput = {
    id?: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    commissions?: CommissionCreateNestedManyWithoutOrderInput
    Delivery?: DeliveryCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutOrderInput
    Delivery?: DeliveryUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type SubscriptionCreateWithoutPaymentsInput = {
    id?: string
    stripeSubscriptionId?: string | null
    status?: string
    planCode?: string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    stripeSubscriptionId?: string | null
    status?: string
    planCode?: string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPaymentsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    commissions?: CommissionUpdateManyWithoutOrderNestedInput
    Delivery?: DeliveryUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutOrderNestedInput
    Delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type SubscriptionUpsertWithoutPaymentsInput = {
    update: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    planCode?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    planCode?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCoachRequestsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoachRequestsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoachRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoachRequestsInput, UserUncheckedCreateWithoutCoachRequestsInput>
  }

  export type UserUpsertWithoutCoachRequestsInput = {
    update: XOR<UserUpdateWithoutCoachRequestsInput, UserUncheckedUpdateWithoutCoachRequestsInput>
    create: XOR<UserCreateWithoutCoachRequestsInput, UserUncheckedCreateWithoutCoachRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoachRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoachRequestsInput, UserUncheckedUpdateWithoutCoachRequestsInput>
  }

  export type UserUpdateWithoutCoachRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoachRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutIntakeInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIntakeInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIntakeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIntakeInput, UserUncheckedCreateWithoutIntakeInput>
  }

  export type UserUpsertWithoutIntakeInput = {
    update: XOR<UserUpdateWithoutIntakeInput, UserUncheckedUpdateWithoutIntakeInput>
    create: XOR<UserCreateWithoutIntakeInput, UserUncheckedCreateWithoutIntakeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIntakeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIntakeInput, UserUncheckedUpdateWithoutIntakeInput>
  }

  export type UserUpdateWithoutIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIntakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSubscriptionQuotaInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionQuotaInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionQuotaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionQuotaInput, UserUncheckedCreateWithoutSubscriptionQuotaInput>
  }

  export type UserUpsertWithoutSubscriptionQuotaInput = {
    update: XOR<UserUpdateWithoutSubscriptionQuotaInput, UserUncheckedUpdateWithoutSubscriptionQuotaInput>
    create: XOR<UserCreateWithoutSubscriptionQuotaInput, UserUncheckedCreateWithoutSubscriptionQuotaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionQuotaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionQuotaInput, UserUncheckedUpdateWithoutSubscriptionQuotaInput>
  }

  export type UserUpdateWithoutSubscriptionQuotaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionQuotaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNutritionPreferenceInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNutritionPreferenceInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionAccess?: NutritionAccessUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNutritionPreferenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNutritionPreferenceInput, UserUncheckedCreateWithoutNutritionPreferenceInput>
  }

  export type UserUpsertWithoutNutritionPreferenceInput = {
    update: XOR<UserUpdateWithoutNutritionPreferenceInput, UserUncheckedUpdateWithoutNutritionPreferenceInput>
    create: XOR<UserCreateWithoutNutritionPreferenceInput, UserUncheckedCreateWithoutNutritionPreferenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNutritionPreferenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNutritionPreferenceInput, UserUncheckedUpdateWithoutNutritionPreferenceInput>
  }

  export type UserUpdateWithoutNutritionPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNutritionPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNutritionAccessInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coach?: CoachCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    milestones?: MilestoneCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    recommendations?: RecommendationCreateNestedManyWithoutUserInput
    commissions?: CommissionCreateNestedManyWithoutUserInput
    coachClients?: CoachCreateNestedOneWithoutClientsInput
    Session?: SessionCreateNestedManyWithoutUserInput
    Order?: OrderCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestCreateNestedManyWithoutUserInput
    intake?: UserIntakeCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNutritionAccessInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
    coachClientsId?: string | null
    coach?: CoachUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    recommendations?: RecommendationUncheckedCreateNestedManyWithoutUserInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutUserInput
    Session?: SessionUncheckedCreateNestedManyWithoutUserInput
    Order?: OrderUncheckedCreateNestedManyWithoutUserInput
    WorkoutLog?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
    NutritionLog?: NutritionLogUncheckedCreateNestedManyWithoutUserInput
    SupplementLog?: SupplementLogUncheckedCreateNestedManyWithoutUserInput
    Subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutUserInput
    intake?: UserIntakeUncheckedCreateNestedOneWithoutUserInput
    subscriptionQuota?: SubscriptionQuotaUncheckedCreateNestedOneWithoutUserInput
    nutritionPreference?: NutritionPreferenceUncheckedCreateNestedOneWithoutUserInput
    coachMessages?: CoachMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNutritionAccessInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNutritionAccessInput, UserUncheckedCreateWithoutNutritionAccessInput>
  }

  export type UserUpsertWithoutNutritionAccessInput = {
    update: XOR<UserUpdateWithoutNutritionAccessInput, UserUncheckedUpdateWithoutNutritionAccessInput>
    create: XOR<UserCreateWithoutNutritionAccessInput, UserUncheckedCreateWithoutNutritionAccessInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNutritionAccessInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNutritionAccessInput, UserUncheckedUpdateWithoutNutritionAccessInput>
  }

  export type UserUpdateWithoutNutritionAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    coachClients?: CoachUpdateOneWithoutClientsNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNutritionAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coachClientsId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type MilestoneCreateManyUserInput = {
    id?: string
    type: string
    description?: string | null
    achievedAt?: Date | string | null
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    orderId?: string | null
    subscriptionId?: string | null
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RecommendationCreateManyUserInput = {
    id?: string
    coachId?: string | null
    type: string
    content: string
    createdAt?: Date | string
  }

  export type CommissionCreateManyUserInput = {
    id?: string
    coachId: string
    orderId: string
    affiliateId?: string | null
    amount: number
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    coachId?: string | null
    scheduledAt: Date | string
    durationMin?: number
    status?: string
    agoraChannel?: string | null
    rating?: number | null
    ratingNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    totalCents?: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkoutLogCreateManyUserInput = {
    id?: string
    date: Date | string
    activity: string
    duration: number
    notes?: string | null
  }

  export type NutritionLogCreateManyUserInput = {
    id?: string
    date: Date | string
    meal: string
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    mealType?: string | null
    notes?: string | null
  }

  export type SupplementLogCreateManyUserInput = {
    id?: string
    date: Date | string
    supplementName: string
    dose: string
    notes?: string | null
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    stripeSubscriptionId?: string | null
    status?: string
    planCode?: string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachRequestCreateManyUserInput = {
    id?: string
    status: string
    createdAt?: Date | string
  }

  export type CoachMessageCreateManyUserInput = {
    id?: string
    coachId: string
    sender: string
    body?: string | null
    attachmentUrl?: string | null
    attachmentName?: string | null
    attachmentType?: string | null
    attachmentSize?: number | null
    createdAt?: Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MilestoneUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MilestoneUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutPaymentsNestedInput
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneWithoutRecommendationsNestedInput
  }

  export type RecommendationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneRequiredWithoutCommissionsNestedInput
    order?: OrderUpdateOneRequiredWithoutCommissionsNestedInput
    affiliate?: AffiliateUpdateOneWithoutCommissionsNestedInput
  }

  export type CommissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMin?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    agoraChannel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    ratingNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMin?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    agoraChannel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    ratingNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMin?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    agoraChannel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    ratingNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    commissions?: CommissionUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    Delivery?: DeliveryUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    Delivery?: DeliveryUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkoutLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkoutLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NutritionLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NutritionLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NutritionLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal?: StringFieldUpdateOperationsInput | string
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    mealType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplementLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplementName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplementLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplementName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplementLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplementName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    planCode?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    planCode?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    planCode?: NullableStringFieldUpdateOperationsInput | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentName?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentType?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type CoachMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentName?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentType?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentName?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentType?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    sku: string
    qty: number
    priceCents: number
  }

  export type CommissionCreateManyOrderInput = {
    id?: string
    coachId: string
    affiliateId?: string | null
    amount: number
    createdAt?: Date | string
    userId?: string | null
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    userId: string
    subscriptionId?: string | null
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    priceCents?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    priceCents?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
    priceCents?: IntFieldUpdateOperationsInput | number
  }

  export type CommissionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneRequiredWithoutCommissionsNestedInput
    affiliate?: AffiliateUpdateOneWithoutCommissionsNestedInput
    User?: UserUpdateOneWithoutCommissionsNestedInput
  }

  export type CommissionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommissionUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    subscription?: SubscriptionUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyCoachClientsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    phone?: string | null
    preferredLocale?: string | null
    deviceToken?: string | null
    role: $Enums.UserRole
    coachId?: string | null
  }

  export type CommissionCreateManyCoachInput = {
    id?: string
    orderId: string
    affiliateId?: string | null
    amount: number
    createdAt?: Date | string
    userId?: string | null
  }

  export type RecommendationCreateManyCoachInput = {
    id?: string
    userId: string
    type: string
    content: string
    createdAt?: Date | string
  }

  export type SessionCreateManyCoachInput = {
    id?: string
    userId: string
    scheduledAt: Date | string
    durationMin?: number
    status?: string
    agoraChannel?: string | null
    rating?: number | null
    ratingNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachMessageCreateManyCoachInput = {
    id?: string
    userId: string
    sender: string
    body?: string | null
    attachmentUrl?: string | null
    attachmentName?: string | null
    attachmentType?: string | null
    attachmentSize?: number | null
    createdAt?: Date | string
  }

  export type CoachCertificateCreateManyCoachInput = {
    id?: string
    name: string
    issuingOrganization: string
    issuedAt: Date | string
    expiresAt?: Date | string | null
    certificateUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachExperienceCreateManyCoachInput = {
    id?: string
    title: string
    organization: string
    startDate: Date | string
    endDate?: Date | string | null
    isCurrent?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachAchievementCreateManyCoachInput = {
    id?: string
    title: string
    description?: string | null
    achievedAt: Date | string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCoachClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUpdateManyWithoutUserNestedInput
    commissions?: CommissionUpdateManyWithoutUserNestedInput
    Session?: SessionUpdateManyWithoutUserNestedInput
    Order?: OrderUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoachClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    coach?: CoachUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    recommendations?: RecommendationUncheckedUpdateManyWithoutUserNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutUserNestedInput
    Session?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    WorkoutLog?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
    NutritionLog?: NutritionLogUncheckedUpdateManyWithoutUserNestedInput
    SupplementLog?: SupplementLogUncheckedUpdateManyWithoutUserNestedInput
    Subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutUserNestedInput
    intake?: UserIntakeUncheckedUpdateOneWithoutUserNestedInput
    subscriptionQuota?: SubscriptionQuotaUncheckedUpdateOneWithoutUserNestedInput
    nutritionPreference?: NutritionPreferenceUncheckedUpdateOneWithoutUserNestedInput
    nutritionAccess?: NutritionAccessUncheckedUpdateOneWithoutUserNestedInput
    coachMessages?: CoachMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCoachClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLocale?: NullableStringFieldUpdateOperationsInput | string | null
    deviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommissionUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutCommissionsNestedInput
    affiliate?: AffiliateUpdateOneWithoutCommissionsNestedInput
    User?: UserUpdateOneWithoutCommissionsNestedInput
  }

  export type CommissionUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommissionUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    affiliateId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecommendationUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecommendationsNestedInput
  }

  export type RecommendationUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMin?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    agoraChannel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    ratingNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMin?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    agoraChannel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    ratingNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMin?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    agoraChannel?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    ratingNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachMessageUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentName?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentType?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachMessagesNestedInput
  }

  export type CoachMessageUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentName?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentType?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachMessageUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentName?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentType?: NullableStringFieldUpdateOperationsInput | string | null
    attachmentSize?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachCertificateUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuingOrganization?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachCertificateUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuingOrganization?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachCertificateUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuingOrganization?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachExperienceUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachExperienceUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachExperienceUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAchievementUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAchievementUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachAchievementUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManySubscriptionInput = {
    id?: string
    userId: string
    orderId?: string | null
    amount?: number | null
    amountCents?: number
    currency: string
    status: string
    provider: string
    providerId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    order?: OrderUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    amountCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    price?: number | null
    priceCents: number
    currency?: string
    inventory?: number
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    bundles?: BundleUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    bundles?: BundleUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutBundlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutBundlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUncheckedUpdateManyWithoutBundlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    priceCents?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type BundleUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type BundleUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type BundleUncheckedUpdateManyWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type CommissionCreateManyAffiliateInput = {
    id?: string
    coachId: string
    orderId: string
    amount: number
    createdAt?: Date | string
    userId?: string | null
  }

  export type CommissionUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachUpdateOneRequiredWithoutCommissionsNestedInput
    order?: OrderUpdateOneRequiredWithoutCommissionsNestedInput
    User?: UserUpdateOneWithoutCommissionsNestedInput
  }

  export type CommissionUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommissionUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachCountOutputTypeDefaultArgs instead
     */
    export type CoachCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BundleCountOutputTypeDefaultArgs instead
     */
    export type BundleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BundleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateCountOutputTypeDefaultArgs instead
     */
    export type AffiliateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachDefaultArgs instead
     */
    export type CoachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachCertificateDefaultArgs instead
     */
    export type CoachCertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachCertificateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachExperienceDefaultArgs instead
     */
    export type CoachExperienceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachExperienceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachAchievementDefaultArgs instead
     */
    export type CoachAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkoutLogDefaultArgs instead
     */
    export type WorkoutLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkoutLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NutritionLogDefaultArgs instead
     */
    export type NutritionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NutritionLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplementLogDefaultArgs instead
     */
    export type SupplementLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplementLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecommendationDefaultArgs instead
     */
    export type RecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecommendationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BundleDefaultArgs instead
     */
    export type BundleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BundleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryDefaultArgs instead
     */
    export type DeliveryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeliveryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateDefaultArgs instead
     */
    export type AffiliateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachMessageDefaultArgs instead
     */
    export type CoachMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommissionDefaultArgs instead
     */
    export type CommissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalyticsDefaultArgs instead
     */
    export type AnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MilestoneDefaultArgs instead
     */
    export type MilestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MilestoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookEventDefaultArgs instead
     */
    export type WebhookEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachRequestDefaultArgs instead
     */
    export type CoachRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserIntakeDefaultArgs instead
     */
    export type UserIntakeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserIntakeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionQuotaDefaultArgs instead
     */
    export type SubscriptionQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionQuotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NutritionPreferenceDefaultArgs instead
     */
    export type NutritionPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NutritionPreferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NutritionAccessDefaultArgs instead
     */
    export type NutritionAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NutritionAccessDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}